module.exports = addAclRlsStorageEntities

/**
 * Add entities for storing ACL of aclRLS mixin
 * @param {object<string, {modelName: string, meta: object, langs: object<string, object>}>} domainJson
 * @param {object} serverConfig
 */
function addAclRlsStorageEntities (domainJson, serverConfig) {
  const verifiedExisted = new Set()
  for (const entityName in domainJson) {
    const entityMeta = domainJson[entityName].meta
    const props = entityMeta.mixins && entityMeta.mixins.aclRls
    if (!props || (props.enabled === false)) return // no aclRls mixin

    if (!Array.isArray(props.onEntities) || !props.onEntities.length) {
      throwConfigError("'onEntities' must be non empty array")
    }

    let masterEntityName, aclStorageEntityName, aclStorageAlias
    if (props.useUnityName) {
      if (!entityMeta.mixins.unity) throwConfigError("if 'useUnityName' is true entity must have a unity mixin")
      masterEntityName = entityMeta.mixins.unity.entity
      if (!domainJson[masterEntityName]) throwConfigError(`unity mixin points to non-existent entity '${masterEntityName}'`)
      const unityEntityMeta = domainJson[masterEntityName].meta
      aclStorageEntityName = masterEntityName + '_acl'
      aclStorageAlias = (unityEntityMeta.sqlAlias || aclStorageEntityName) + 'acl'
    } else {
      masterEntityName = entityName
      aclStorageEntityName = masterEntityName + '_acl'
      aclStorageAlias = (entityMeta.sqlAlias || aclStorageEntityName) + 'acl'
    }

    for (const linkedE of props.onEntities) {
      const le = domainJson[entityName]
      if (!le) throwConfigError(`entity '${linkedE}' specified in 'onEntities' not in domain`)
      if (!le.meta.sqlAlias) throwConfigError(`expect entity '${linkedE}' listed in 'onEntities' to have an sqlAlias`)
    }
    if (domainJson[aclStorageEntityName]) {
      if (!verifiedExisted.has(aclStorageEntityName)) { // log only once for each entity
        console.info(`Existed entity '${aclStorageEntityName}' is used for storing ACL for '${entityName}'`)
      }
      continue
    }

    const aclStorageMeta = {
      code: aclStorageEntityName,
      name: aclStorageEntityName,
      caption: "Autogenerated storage for 'aclRls' data",
      sqlAlias: aclStorageAlias,
      connectionName: entityMeta.connectionName,
      attributes: [{
        name: 'instanceID',
        caption: 'instanceID',
        dataType: 'Entity',
        associatedEntity: masterEntityName,
        allowNull: false
      }, {
        name: 'valueID',
        caption: 'valueID',
        dataType: ' BigInt',
        allowNull: false
      }],
      // compared to native impl. we skip "all not null" check constraint creation - it verified by aclRlsStorage mixin
      mixins: {
        audit: {
          enabled: (entityMeta.mixins && entityMeta.mixins.audit && entityMeta.mixins.audit.enabled),
          parentIdentifier: 'sourceID',
          parentEntity: entityName
        }
      }
    }
    verifiedExisted.add(aclStorageEntityName) // mark as added - do not put in log info about using existed entity

    if (props.useUnityName) {

    } else {

    }
    // FaclParentEntity := FUnityEntity.name
    // FactEntityAlias := FUnityEntity.sqlAlias + 'acl';
    for (const attr of entityMeta.attributes) {
      if (attr.dataType !== 'Many') continue
      if (domainJson[attr.associationManyData]) continue // many data entity already added
      const addedManyEntity = {
        code: attr.associationManyData,
        name: attr.associationManyData,
        isManyManyRef: true,
        connectionName: entityMeta.connectionName,
        attributes: [{
          name: 'sourceID',
          caption: 'sourceID',
          dataType: 'Entity',
          associatedEntity: entityName,
          cascadeDelete: (entityMeta.mixins && entityMeta.mixins.mStorage && !entityMeta.mixins.mStorage.safeDelete),
          allowNull: false
        }, {
          name: 'destID',
          caption: 'destID',
          dataType: 'Entity',
          associatedEntity: attr.associatedEntity,
          cascadeDelete: attr.cascadeDelete,
          allowNull: false
        }],
        mixins: {
          audit: {
            enabled: (entityMeta.mixins && entityMeta.mixins.audit && entityMeta.mixins.audit.enabled),
            parentIdentifier: 'sourceID',
            parentEntity: entityName
          }
        }
      }
      domainJson[attr.associationManyData] = {
        modelName: domainJson[entityName].modelName,
        meta: addedManyEntity,
        langs: null
      }
    }
  }
}

function throwConfigError(entityName, msg) {
  throw new Error(`Invalid 'aclRls' mixin config for ${entityName}: ${msg}`)
}
