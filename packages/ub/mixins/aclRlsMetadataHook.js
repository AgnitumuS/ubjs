module.exports = addAclRlsStorageEntities

let allModels

/**
 * Verify model exists in domain
 *
 * @param {object} domainJson
 * @param {string} modelName
 * @returns {boolean}
 */
function modelExists (domainJson, modelName) {
  if (!allModels) {
    allModels = new Set()
    for (const entityName in domainJson) {
      allModels.add(domainJson[entityName].modelName)
    }
  }
  return allModels.has(modelName)
}

/**
 * Add entities for storing ACL of aclRLS mixin
 *
 * @param {object<string, {modelName: string, meta: object, langs: object<string, object>}>} domainJson
 * @param {object} serverConfig
 */
function addAclRlsStorageEntities (domainJson, serverConfig) {
  const verifiedExisted = new Set()
  for (const entityName in domainJson) {
    const entityMeta = domainJson[entityName].meta
    const props = entityMeta.mixins && entityMeta.mixins.aclRls
    if (!props || (props.enabled === false)) continue // no aclRls mixin
    console.debug('Start adding AclRlsStorageEntiti for ', entityName)
    if (!Array.isArray(props.onEntities) || !props.onEntities.length) {
      throwConfigError("'onEntities' must be non empty array")
    }

    let masterEntityName, aclStorageEntityName, aclStorageAlias
    if (props.useUnityName) {
      if (!entityMeta.mixins.unity) throwConfigError(entityName, "if 'useUnityName' is true entity must have a unity mixin")
      masterEntityName = entityMeta.mixins.unity.entity
      if (!domainJson[masterEntityName]) throwConfigError(entityName, `unity mixin points to non-existent entity '${masterEntityName}'`)
      const unityEntityMeta = domainJson[masterEntityName].meta
      if (!unityEntityMeta.sqlAlias) throwConfigError(entityName, `expect unity entity '${masterEntityName}' to have an sqlAlias - because 'useUnityName=true'`)
      aclStorageEntityName = masterEntityName + '_acl'
      aclStorageAlias = unityEntityMeta.sqlAlias + 'acl'
    } else {
      masterEntityName = entityName
      aclStorageEntityName = masterEntityName + '_acl'
      if (!entityMeta.sqlAlias) throwConfigError(entityName, 'expect entity to have a sqlAlias')
      aclStorageAlias = entityMeta.sqlAlias + 'acl'
    }
    if (domainJson[aclStorageEntityName]) {
      if (!verifiedExisted.has(aclStorageEntityName)) { // log only once for each entity
        console.info(`Existed entity '${aclStorageEntityName}' is used for storing ACL for '${entityName}'`)
      }
      continue
    }

    let aclStorageModel = props.model
    if (aclStorageModel && !modelExists(domainJson, aclStorageModel)) {
      throwConfigError(entityName, `model '${aclStorageModel}' specified in 'aclRls.model' not in domain`)
    }
    if (!aclStorageModel) aclStorageModel = domainJson[masterEntityName].modelName

    const aclStorageMeta = {
      code: aclStorageEntityName,
      name: aclStorageEntityName,
      caption: "Autogenerated storage for 'aclRls' data",
      sqlAlias: aclStorageAlias,
      connectionName: entityMeta.connectionName,
      attributes: [{
        name: 'instanceID',
        caption: 'instanceID',
        dataType: 'Entity',
        associatedEntity: masterEntityName,
        allowNull: false
      }, {
        name: 'valueID',
        caption: 'valueID',
        dataType: 'BigInt',
        allowNull: false
      }],
      dbKeys: {}, // added below
      mixins: {
        audit: {
          enabled: (entityMeta.mixins && entityMeta.mixins.audit && entityMeta.mixins.audit.enabled),
          parentIdentifier: 'instanceID',
          parentEntity: entityName
        },
        mStorage: {},
        aclRlsStorage: {}
      }
    }
    // unique index on instanceID + valueID (aclRls.insert skip inserting of duplicates)
    aclStorageMeta.dbKeys[`UIDX_${aclStorageAlias}_IIVI`] = {
      instanceID: {},
      valueID: {}
    }

    for (const linkedE of props.onEntities) {
      const le = domainJson[linkedE]
      if (!le) throwConfigError(entityName, `entity '${linkedE}' specified in 'onEntities' not in domain`)
      if (!le.meta.sqlAlias) {
        throwConfigError(entityName, `expect entity '${linkedE}' listed in 'onEntities' to have an sqlAlias`)
      }
      const attrCode = `${le.meta.sqlAlias}ID`
      aclStorageMeta.attributes.push({
        code: attrCode,
        name: attrCode,
        dataType: 'Entity',
        associatedEntity: linkedE,
        customSettings: {
          hiddenInDetails: true
        }
      })
    }

    domainJson[aclStorageEntityName] = {
      modelName: aclStorageModel,
      meta: aclStorageMeta,
      langs: null
    }
    // console.debug('Added:', JSON.stringify(domainJson[aclStorageEntityName], null, '  '))
  }
}

/**
 * @param entityName
 * @param msg
 */
function throwConfigError (entityName, msg) {
  throw new Error(`Invalid 'aclRls' mixin config for '${entityName}': ${msg}`)
}
