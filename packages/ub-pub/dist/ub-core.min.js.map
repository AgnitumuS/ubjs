{"version":3,"sources":["webpack:///ub-core.min.js","webpack:///./index.js","webpack:///./utils.js","webpack:///./~/@unitybase/CryptoJS/core.js","webpack:///./events.js","webpack:///./i18n.js","webpack:///./~/@unitybase/CryptoJS/md5.js","webpack:///./~/@unitybase/CryptoJS/sha256.js","webpack:///./../base/LocalDataStore.js","webpack:///./ClientRepository.js","webpack:///./UBNativeMessage.js","webpack:///./transport.js","webpack:///(webpack)/buildin/module.js","webpack:///./../base/CustomRepository.js","webpack:///./../base/UBDomain.js","webpack:///./../base/UBSession.js","webpack:///./UBCache.js","webpack:///./UBConnection.js","webpack:///./UBNativeDSTUCrypto.js","webpack:///./UBNativeIITCrypto.js","webpack:///./UBNotifierWSProtocol.js","webpack:///./injection.js"],"names":["webpackJsonp","module","exports","__webpack_require__","localization","utils","transport","conn","injection","ClientRepository","SHA256","MD5","i18n","i18nExtend","format","apply","ns","booleanParse","iso8601Parse","iso8601ParseAsDate","base64FromAny","base64toArrayBuffer","UBError","UBAbortError","xhr","get","post","connect","log","logError","logWarn","logDebug","userAgent","isChrome","isWebKit","isGecko","isOpera","isMac","isSecureBrowser","inject","addResourceVersion","message","detail","code","this","name","Error","captureStackTrace","stack","_","objectTo","objectsFrom","Array","prototype","forEach","call","arguments","obj","Object","keys","key","FORMAT_RE","stringToFormat","values","args","toArray","slice","replace","m","i","namespacePath","root","window","parts","part","j","subLn","split","length","value","Date","res","setTime","getTime","getTimezoneOffset","v","undefined","data","Promise","resolve","reject","reader","FileReader","blob","Blob","addEventListener","result","event","readAsDataURL","BASE64STRING","BASE64ARR","l","push","BASE64DECODELOOKUP","Uint8Array","charCodeAt","base64","bufferLength","len","p","encoded1","encoded2","encoded3","encoded4","arrayBuffer","ArrayBuffer","bytes","constructor","msg","console","error","warn","info","bind","navigator","toLowerCase","test","factory","CryptoJS","Math","C","C_lib","lib","Base","F","extend","overrides","subtype","mixIn","hasOwnProperty","init","$super","create","instance","properties","propertyName","toString","clone","WordArray","words","sigBytes","encoder","Hex","stringify","concat","wordArray","thisWords","thatWords","thisSigBytes","thatSigBytes","clamp","thatByte","ceil","random","nBytes","rcache","r","m_w","m_z","mask","_r","C_enc","enc","hexChars","bite","join","parse","hexStr","hexStrLength","parseInt","substr","Latin1","latin1Chars","String","fromCharCode","latin1Str","latin1StrLength","Utf8","decodeURIComponent","escape","e","utf8Str","unescape","encodeURIComponent","BufferedBlockAlgorithm","reset","_data","_nDataBytes","_append","_process","doFlush","dataWords","dataSigBytes","blockSize","blockSizeBytes","nBlocksReady","max","_minBufferSize","nWordsReady","nBytesReady","min","offset","_doProcessBlock","processedWords","splice","C_algo","Hasher","cfg","_doReset","update","messageUpdate","finalize","hash","_doFinalize","_createHelper","hasher","_createHmacHelper","HMAC","algo","EventEmitter","$getMaxListeners","that","_maxListeners","defaultMaxListeners","emitNone","handler","isFn","self","listeners","arrayClone","emitOne","arg1","emitTwo","arg2","emitThree","arg3","emitMany","listenerCount","type","events","_events","evlistener","spliceOne","list","index","k","n","pop","arr","copy","getPrototypeOf","_eventsCount","setMaxListeners","isNaN","TypeError","getMaxListeners","emit","er","doError","err","context","addListener","listener","existing","newListener","warned","trace","on","once","g","removeListener","fired","position","removeAllListeners","ret","emitter","localeString","__i18n","localizationObject","merge","monkeyRequestsDetected","FF","a","b","c","d","x","s","t","GG","HH","II","T","abs","sin","_hash","M","offset_i","M_offset_i","H","M_offset_0","M_offset_1","M_offset_2","M_offset_3","M_offset_4","M_offset_5","M_offset_6","M_offset_7","M_offset_8","M_offset_9","M_offset_10","M_offset_11","M_offset_12","M_offset_13","M_offset_14","M_offset_15","nBitsTotal","nBitsLeft","nBitsTotalH","floor","nBitsTotalL","H_i","HmacMD5","K","isPrime","sqrtN","sqrt","factor","getFractionalBits","nPrime","pow","W","f","h","gamma0x","gamma0","gamma1x","gamma1","ch","maj","sigma0","sigma1","t1","t2","HmacSHA256","whereListToFunctions","request","fieldList","transformClause","clause","property","expression","condition","trim","propIdx","indexOf","fValue","filters","filterFabricFn","escapeForRegexp","text","whereList","propertyIdx","regExpFilter","RegExp","record","val","str","ID","doFilterAndSort","cachedData","ubRequest","rangeStart","filteredData","doFiltration","totalLength","doSorting","options","start","limit","resultData","fields","total","byID","IDValue","isAcceptable","rawDataArray","byPrimaryKey","filterFabric","filterCount","filteredArray","preparedOrder","orderList","each","orderItem","attrIdx","idx","modifier","order","orderLen","compareFn","v1","v2","colNum","sort","selectResultToArrayOfObjects","selectResult","fieldAlias","inData","inAttributes","inDataLength","alias","field","zipObject","flatten","requestedFieldList","fldIdxArr","cachedFields","rowIdx","col","pos","rowCount","row","fieldCount","arrayOfObjectsToSelectResult","arrayOfObject","attributeNames","attribute","connection","entityName","CustomRepository","LocalDataStore","selectAsObject","fieldAliases","select","ubql","then","selectAsArray","selectAsStore","selectSingle","selectScalar","selectById","where","UBNativeMessage","feature","me","__messageCounter","getMessageId","idCounter","id","pendingMessages","pluginName","hostAppName","features","host","featureVersion","callTimeOut","ubUtils","eventElm","assign","document","getElementById","parent","onContentMessage","pending","messageID","msgType","totalParts","currentPart","clientID","clearTimeout","timerID","deffer","doOnDisconnect","onMessage","setTimeout","onMsgTimeOut","timeoutValue","notify","partials","charAt","JSON","isUserMessage","match","onDisconnected","extension","UIName","minVersion","installer","dstu","libraryName","iit","pdfsigner","scanner","docedit","versionToNumber","versionStr","mutliplier","invoke","methodName","methodParams","timeout","messageToSend","msgID","connected","method","params","pendingRequest","stTime","iFarmeMode","postMessage","messageType","dispatchEvent","CustomEvent","extensionExists","getAttribute","reason","rejections","onParentWinMessage","timeOut","promise","timeId","createFeatureUpdateMsg","removeEventListener","extensionVersion","versionNum","requiredVersion","catch","disconnect","featureName","currentVersion","isUpdate","featureInfo","lowercase","parseHeaders","headers","parsed","line","headersGetter","headersObj","_typeof","transformData","fns","fn","transformDataPromise","rPromise","isSuccess","status","iterator","forEachSorted","buildUrl","url","isArray","requestConfig","defaults","xhrDefaults","config","transformRequest","transformResponse","mergeHeaders","defHeaders","reqHeaders","defHeaderName","lowercaseDefHeaderName","reqHeaderName","execHeaders","headerFn","header","headerContent","common","defaultHeadersIteration","toUpperCase","serverRequest","response","trdData","reqData","prevReqTime","__lastRequestTime","__lastRequestURL","__lastRequestData","withCredentials","sendReq","interceptors","filter","interceptor","requestError","map","success","failure","responseError","XHR","aborted","timeoutId","pendingRequests","open","setRequestHeader","onreadystatechange","readyState","responseHeaders","getAllResponseHeaders","responseType","responseText","onProgress","upload","onprogress","send","abort","Symbol","allowRequestReiteration","CONTENT_TYPE_APPLICATION_JSON","Content-Type","Accept","put","patch","XMLHttpRequest","webpackPolyfill","deprecate","paths","children","_classCallCheck","Constructor","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","protoProps","staticProps","bracketsRe","conditionInCaseValueIsNull","equal","notEqual","custom","groupList","logicalPredicates","joinAs","__description","__misc","attr","clauseName","subQueryType","originalCondition","WhereCondition","wrongCondition","debug","isDate","whereItem","subRepository","subQueryAttribute","masterAttribute","predicate","whereItemName","direction","isString","rowsLimit","orderCnt","req","entity","storeConfig","flags","totalRequired","getRunListItem","gt",">","more","lt","<","less","eq","=","ge","geq",">=","moreEqual","le","leq","<=","lessEqual","ne","neq","<>","!=","!==","contains","like","notContains","notLike","isNull","null","notNull","notIsNull","isNotNull","beginWith","startWith","startsWith","startswith","notBeginWith","notStartWith","notStartsWith","includes","in","notIncludes","notIn","subquery","exists","notExists","UBDomain","domainInfo","entityCodes","domain","isV4API","entityMethods","entities","connections","entityCode","UBEntity","models","modelCodes","modelCode","UBModel","path","needInit","needLocalize","forceMIMEConvertors","UBEntityAttributes","UBEntityMapping","maping","selectName","execName","pkGenerator","entityInfo","mixinNames","mixinInfo","i18nMixin","dialectProiority","modelName","caption","description","documentation","descriptionAttribute","cacheType","dsType","sqlAlias","connectionName","isFTSDataTable","connectionConfig","find","mapping","dialectsPriority","dialect","dbKeys","dbExtensions","attributes","attributeInfo","attributeCode","UBEntityAttribute","mixins","mixinCode","UBEntityStoreMixin","UBEntityHistoryMixin","UBEntityAclRlsMixin","UBEntityFtsMixin","UBEntityAlsMixin","UBEntityMixin","UBEntityAttributeMapping","expressionType","dataType","associatedEntity","associationAttr","size","allowNull","allowSort","isUnique","defaultValue","readOnly","isMultiLang","cascadeDelete","enumGroup","customSettings","associationManyData","storeName","generateFK","defaultView","physicalDataType","getPhysicalDataType","isEntityMethodsAccessible","methodNames","haveAccessToMethods","haveAccessToMethod","raiseErrorIfNotExists","has","eachEntity","callBack","filterEntities","isFunction","item","prop","ubDataTypes","Int","BigInt","Float","Currency","Boolean","DateTime","Text","Entity","Document","Many","TimeLog","Enum","BLOB","ExpressionType","Field","Expression","ubMixins","dataHistory","mStorage","unity","treePath","ubServiceFields","dateFrom","dateTo","EntityDataSourceType","Normal","External","System","Virtual","EntityCacheTypes","None","Session","SessionEntity","MSSQL2012","MSSQL2008","MSSQL","Oracle11","Oracle10","Oracle9","Oracle","PostgreSQL","AnsiSQL","Firebird","SQLite3","typeMap","physicalTypeMap","asJSON","propName","getEntityCaption","simple","getEntityAttribute","eachAttribute","mixin","hasMixin","enabled","checkMixin","methodCode","filterAttribute","haveAccessToAnyMethods","methods","fMethods","getConvertRules","rules","types","fieldName","convertFn","getDescriptionAttribute","getEntityAttributeInfo","attributeName","deep","domainEntity","attributeNameParts","currentLevel","complexAttr","currentEntity","shift","getAssociatedEntity","getAttributeNames","getEntityRequirements","fieldNameParts","tail","union","checkAttributeExist","contextMessage","getEntityDescription","simpleAudit","safeDelete","historyType","aclRlsUseUnityName","aclRlsSelectionRule","scope","dataProvider","alsOptimistic","UBSession","authResponse","secretWord","authSchema","hexa8ID","hexa8","userData","uData","lang","login","sessionWord","sessionPwdHash","sessionSaltCRC","ncrc32","logonname","signature","timeStampI","hexaTime","crc32","isAnonymous","authHeader","num","CRC32_POLYTABLES","polynomial","initialValue","finalXORValue","table","crc","reverse","RangeError","UBCache","dbName","version","_this","_dbPromise","iDB","errMsg","errDetails","openRequest","onerror","onblocked","onsuccess","onupgradeneeded","db","tx","transaction","oldVersion","newVersion","dbInfo","stores","objectStoreNames","objectStore","clear","createObjectStore","ready","indexedDB","webkitIndexedDB","mozIndexedDB","OIndexedDB","msIndexedDB","SESSION","PERMANENT","cacheTypes","onTransactionComplete","onTransactionAbort","errorCode","onTransactionError","trans","oncomplete","onabort","getAllKeys","results","openCursor","cursor","continue","remove","delete","removeIfMach","regExp","allKeys","machKeys","anonymousRequestAuthParams","isRepeat","AUTH_SCHEMA_FOR_ANONYMOUS","ANONYMOUS_USER","UBConnection","connectionParams","appName","requestAuthParams","baseURL","serverURL","currentSession","ubNotifier","appConfig","preferredLocale","serverUrl","location","origin","exchangeKeysPromise","channelEncryptor","_pki","isPKIReady","cache","lastLoginName","useCacheForXHR","ActiveXObject","_bufferedRequests","_bufferTimeoutID","isAuthorized","userLogin","userLang","authorize","authParams","doAuth","session","authorizationClear","authHandshakeUBIP","AUTH_METHOD_URL","Authorization","authHandshakeOpenIDConnect","authHandshakeUB","password","AUTHTYPE","userName","resp","serverNonce","pwdHash","pwdForAuth","clientNonce","toISOString","connectionID","realm","nonce","useSasl","CryptoJSCore","btoa","appForAuth","authHandshakeCERT","pki","urlParams","registration","pkiInit","readPK","certInfo","ownIITCert","ownIITEncryptCert","ownIITEncryptSignature","aValues","authData","serverMessage","byteLength","respObj","errCode","CONNECTIONID","setRecipientCertificate","envelop","decryptEnvelope","secretWordB64","atob","encryptEnvelope","encryptEnvelopeRes","closePK","USERNAME","ubSession","supportedLanguages","rejectReason","errInfo","codeMsg","serverErrorByCode","recordedXHRs","recorderEnabled","onCredentialRequired","onAuthorizationFail","onNeedChangePassword","getAppInfo","appInfo","applicationName","applicationTitle","loginWindowTopLogoURL","loginWindowBottomLogoURL","themeName","userDbVersion","defaultLang","UBNotifierWSProtocol","LDS","getItem","onGotApplicationConfig","initEncriptionIfNeed","initCache","myLocale","setItem","getDomainInfo","onGotApplicationDomain","UBNativeDSTUCrypto","UBNativeIITCrypto","NON_AUTH_URLS_RE","NON_ENCRYPTED_URLS_RE","BUFFERED_DELAY","cachedSessionEntityRequested","cacheKeyCalculate","keyPart","cacheOccurrenceRefresh","cacheKey","machRe","domainMixin","cacheOccurrenceRemove","cacheStore","cacheClearAll","all","_pkiInit","exchangeKeys","doneAt","now","isFulfilled","encryptionKeyLifetime","valueOf","doneTime","doKeyExchange","decryptResponse","encoding","compressed","encrypted","jsonContent","resAsBase64","dataPromise","decryptArr","isBase64","substring","trafficEncryption","sendData","_ret","compress","encryptToArray","encryptToArrayRes","head","serverCertificate","authMethods","supportedWSProtocols","serverVersion","uiSettings","adminUI","getEnvelopeWithKey","envelope","initEncryptionRequest","processBuffer","bufferCopy","responses","bufferedRequest","deferred","failReason","query","ubq","allowBuffer","run","convertResponseDataToJsTypes","serverResponse","convertRules","rulesLen","dataLen","column","notModified","resultLock","lockTime","addNew","invalidateCache","none","insert","doDelete","bypassCache","serverRequestWOLimits","cKey","cacheStoreName","processVersionedResponse","__mip_disablecache","responseWithTotal","__totalRecCount","resRowCount","opt","cachedPromise","cacheResponse","runTrans","ubRequestArray","ALLOWED_GET_DOCUMENT_PARAMS","getDocument","reqParams","resultIsBinary","logout","serverErrorCodes","1","2","3","4","5","6","7","8","9","10","11","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48","49","50","51","52","53","54","55","56","57","58","67","69","72","73","74","errorNum","Repository","localStorage","nm","crypto","initialized","waitTimeout","base64encrypted","toBase64","isCompressed","b64","loadCerts","certListResult","certificates","reqArr","certName","cert","base64Data","keyIsReaded","settingsOk","pkResult","lastError","certificateInfo","ownIITCer","rejection","setServerCertificate","base64encodedCert","resultAsBase64","base64string","signData","dataIsBase64","verifySignature","_createWSConnection","supported","$ws","WebSocket","wsURL","onopen","doDebug","protocol","notifier","onmessage","delayedCmd","command","isConnectionAccepted","bufferedCommands","sendCommand","onclose","_onUBConnectionAuthorized","ubConnection","WS_PROTOCOL","inDebug","set","newValue","MAX_BUFFERED_COMMANDS","charset","__loadedScript","elm","isCSS","createElement","rel","async","oError","href","src","onload","_elm","parentNode","removeChild","__head","appendChild","getResourceVersion","uri","MODEL_RE","exec","__ubVersion","ver","getElementsByTagName"],"mappings":"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","file":"ub-core.min.js","sourcesContent":["webpackJsonp([1],[\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\r\n\t * Created by pavel.mash on 03.09.2016.\r\n\t */\n\t\n\tvar localization = __webpack_require__(6);\n\tvar utils = __webpack_require__(1);\n\tvar transport = __webpack_require__(12);\n\tvar conn = __webpack_require__(18);\n\tvar injection = __webpack_require__(22);\n\tvar ClientRepository = __webpack_require__(10);\n\tvar SHA256 = __webpack_require__(8);\n\tvar MD5 = __webpack_require__(7);\n\t\n\tmodule.exports = {\n\t  i18n: localization.i18n,\n\t  i18nExtend: localization.i18nExtend,\n\t\n\t  format: utils.format,\n\t  apply: utils.apply,\n\t  ns: utils.ns,\n\t  booleanParse: utils.booleanParse,\n\t  iso8601Parse: utils.iso8601Parse,\n\t  iso8601ParseAsDate: utils.iso8601ParseAsDate,\n\t\n\t  base64FromAny: utils.base64FromAny,\n\t  base64toArrayBuffer: utils.base64toArrayBuffer,\n\t\n\t  UBError: utils.UBError,\n\t  UBAbortError: utils.UBAbortError,\n\t\n\t  xhr: transport.xhr,\n\t  get: transport.get,\n\t  post: transport.post,\n\t\n\t  connect: conn.connect,\n\t  ClientRepository: ClientRepository,\n\t\n\t  log: utils.log,\n\t  logError: utils.logError,\n\t  logWarn: utils.logWarn,\n\t  logDebug: utils.logDebug,\n\t\n\t  userAgent: utils.userAgent,\n\t  isChrome: utils.isChrome,\n\t  isWebKit: utils.isWebKit,\n\t  isGecko: utils.isGecko,\n\t  isOpera: utils.isOpera,\n\t  isMac: utils.isMac,\n\t  isSecureBrowser: utils.isSecureBrowser,\n\t\n\t  inject: injection.inject,\n\t  addResourceVersion: injection.addResourceVersion,\n\t\n\t  SHA256: SHA256,\n\t  MD5: MD5\n\t};\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\r\n\t * Created by pavel.mash on 01.12.2016.\r\n\t */\n\t/* global FileReader, Blob */\n\tvar _ = __webpack_require__(2);\n\t/**\r\n\t * Copies all the properties of one or several objectsFrom to the specified objectTo.\r\n\t * Non-simple type copied by reference!\r\n\t * @param {Object} objectTo The receiver of the properties\r\n\t * @param {...Object} objectsFrom The source(s) of the properties\r\n\t * @return {Object} returns objectTo\r\n\t */\n\tmodule.exports.apply = function (objectTo, objectsFrom) {\n\t  Array.prototype.forEach.call(arguments, function (obj) {\n\t    if (obj && obj !== objectTo) {\n\t      Object.keys(obj).forEach(function (key) {\n\t        objectTo[key] = obj[key];\n\t      });\n\t    }\n\t  });\n\t  return objectTo;\n\t};\n\t\n\tvar FORMAT_RE = /\\{(\\d+)}/g;\n\t/**\r\n\t * Allows you to define a tokenized string and pass an arbitrary number of arguments to replace the tokens.  Each\r\n\t * token must be unique, and must increment in the format {0}, {1}, etc.  Example usage:\r\n\t *\r\n\t *     var s = UB.format('{1}/ext-lang-{0}.js', 'en', 'locale');\r\n\t *     // s now contains the string: ''locale/ext-lang-en.js''\r\n\t *\r\n\t * @param {String} stringToFormat The string to be formatted.\r\n\t * @param {...*} values The values to replace tokens `{0}`, `{1}`, etc in order.\r\n\t * @return {String} The formatted string.\r\n\t */\n\tmodule.exports.format = function (stringToFormat, values) {\n\t  var args = _.toArray(arguments).slice(1);\n\t  return stringToFormat.replace(FORMAT_RE, function (m, i) {\n\t    return args[i];\n\t  });\n\t};\n\t\n\t/**\r\n\t * Creates namespaces to be used for scoping variables and classes so that they are not global.\r\n\t * @example\r\n\t *     UB.ns('DOC.Report');\r\n\t *\r\n\t *     DOC.Report.myReport = function() { ... };\r\n\t *\r\n\t * @method\r\n\t * @param {String} namespacePath\r\n\t * @return {Object} The namespace object.\r\n\t */\n\tmodule.exports.ns = function (namespacePath) {\n\t  var root = window;\n\t  var parts = void 0,\n\t      part = void 0,\n\t      j = void 0,\n\t      subLn = void 0;\n\t\n\t  parts = namespacePath.split('.');\n\t\n\t  for (j = 0, subLn = parts.length; j < subLn; j++) {\n\t    part = parts[j];\n\t    if (!root[part]) root[part] = {};\n\t    root = root[part];\n\t  }\n\t  return root;\n\t};\n\t\n\t/**\r\n\t * Convert UnityBase server dateTime response to Date object\r\n\t * @param value\r\n\t * @returns {Date}\r\n\t */\n\tmodule.exports.iso8601Parse = function (value) {\n\t  return value ? new Date(value) : null;\n\t};\n\t\n\t/**\r\n\t * Convert UnityBase server date response to Date object.\r\n\t * date response is a day with 00 time (2015-07-17T00:00Z), to get a real date we must add current timezone shift\r\n\t * @param value\r\n\t * @returns {Date}\r\n\t */\n\tmodule.exports.iso8601ParseAsDate = function (value) {\n\t  var res = value ? new Date(value) : null;\n\t  if (res) {\n\t    res.setTime(res.getTime() + res.getTimezoneOffset() * 60 * 1000);\n\t  }\n\t  return res;\n\t};\n\t\n\t/**\r\n\t * Convert UnityBase server Boolean response to Boolean (0 = false & 1 = trhe)\r\n\t * @param v Value to convert\r\n\t * @returns {Boolean|null}\r\n\t */\n\tmodule.exports.booleanParse = function (v) {\n\t  if (typeof v === 'boolean') return v;\n\t  if (v === undefined || v === null || v === '') return null;\n\t  return v === 1;\n\t};\n\t\n\t/**\r\n\t * Fast async transformation of data to base64 string\r\n\t * @method\r\n\t * @param {File|ArrayBuffer|String|Blob|Array} data\r\n\t * @returns {Promise<string>} resolved to data converted to base64 string\r\n\t */\n\tmodule.exports.base64FromAny = function (data) {\n\t  return new Promise(function (resolve, reject) {\n\t    var reader = new FileReader();\n\t    var blob = data instanceof Blob ? data : new Blob([data]);\n\t    reader.addEventListener('loadend', function () {\n\t      resolve(reader.result.split(',', 2)[1]); // remove data:....;base64, from the beginning of string //TODO -use indexOf\n\t    });\n\t    reader.addEventListener('error', function (event) {\n\t      reject(event);\n\t    });\n\t    reader.readAsDataURL(blob);\n\t  });\n\t};\n\t\n\tvar BASE64STRING = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\tvar BASE64ARR = [];\n\t(function () {\n\t  for (var i = 0, l = BASE64STRING.length - 1; i < l; i++) {\n\t    BASE64ARR.push(BASE64STRING[i]);\n\t  }\n\t})();\n\t\n\tvar BASE64DECODELOOKUP = new Uint8Array(256);\n\t(function () {\n\t  for (var i = 0, l = BASE64STRING.length; i < l; i++) {\n\t    BASE64DECODELOOKUP[BASE64STRING[i].charCodeAt(0)] = i;\n\t  }\n\t})();\n\t\n\t/**\r\n\t * Convert base54 encoded string to decoded array buffer\r\n\t * @param {String} base64\r\n\t * @returns {ArrayBuffer}\r\n\t */\n\tmodule.exports.base64toArrayBuffer = function (base64) {\n\t  var bufferLength = base64.length * 0.75;\n\t  var len = base64.length;\n\t  var p = 0;\n\t  var encoded1 = void 0,\n\t      encoded2 = void 0,\n\t      encoded3 = void 0,\n\t      encoded4 = void 0;\n\t\n\t  if (base64[base64.length - 1] === '=') {\n\t    bufferLength--;\n\t    if (base64[base64.length - 2] === '=') bufferLength--;\n\t  }\n\t\n\t  var arrayBuffer = new ArrayBuffer(bufferLength);\n\t  var bytes = new Uint8Array(arrayBuffer);\n\t\n\t  for (var i = 0; i < len; i += 4) {\n\t    encoded1 = BASE64DECODELOOKUP[base64.charCodeAt(i)];\n\t    encoded2 = BASE64DECODELOOKUP[base64.charCodeAt(i + 1)];\n\t    encoded3 = BASE64DECODELOOKUP[base64.charCodeAt(i + 2)];\n\t    encoded4 = BASE64DECODELOOKUP[base64.charCodeAt(i + 3)];\n\t\n\t    bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n\t    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n\t    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n\t  }\n\t\n\t  return arrayBuffer;\n\t};\n\t\n\t/**\r\n\t * UnityBase client-side exception.\r\n\t * Such exceptions are will not be showed as unknown error in {@link UB#showErrorWindow}\r\n\t *\r\n\t * message Can be either localized message or locale identifier - in this case UB#showErrorWindow translate message using {@link UB#i18n}\r\n\t *\r\n\t *      @example\r\n\t *      throw new UB.UBError('lockedBy'); // will show message box \"Record was locked by other user. It\\'s read-only for you now\"\r\n\t *\r\n\t * @param {String} message Message\r\n\t * @param {String} [detail] Error details\r\n\t * @param {Number} [code] Error code (for server-side errors)\r\n\t * @extends {Error}\r\n\t */\n\tfunction UBError(message, detail, code) {\n\t  this.name = 'UBError';\n\t  this.detail = detail;\n\t  this.code = code;\n\t  this.message = message || 'UBError';\n\t  if (Error.captureStackTrace) {\n\t    Error.captureStackTrace(this, UBError);\n\t  } else {\n\t    this.stack = new Error().stack;\n\t  }\n\t}\n\tUBError.prototype = new Error();\n\tUBError.prototype.constructor = UBError;\n\t\n\tmodule.exports.UBError = UBError;\n\t\n\t/**\r\n\t * UnityBase still error. Global error handler does not show this error for user. Use it for still reject promise.\r\n\t * @param {String} [message] Message\r\n\t * @param {String} [detail] Error details\r\n\t * @extends {Error}\r\n\t */\n\tfunction UBAbortError(message, detail) {\n\t  this.name = 'UBAbortError';\n\t  this.detail = detail;\n\t  this.code = 'UBAbortError';\n\t  this.message = message || 'UBAbortError';\n\t  if (Error.captureStackTrace) {\n\t    Error.captureStackTrace(this, UBAbortError);\n\t  } else {\n\t    this.stack = new Error().stack;\n\t  }\n\t}\n\tUBAbortError.prototype = new Error();\n\tUBAbortError.prototype.constructor = UBAbortError;\n\t\n\tmodule.exports.UBAbortError = UBAbortError;\n\t\n\t/**\r\n\t * Log message to console (if console available)\r\n\t * @method\r\n\t * @param {...*} msg\r\n\t */\n\tmodule.exports.log = function log(msg) {\n\t  if (console) console.log.apply(console, arguments);\n\t};\n\t\n\t/**\r\n\t * Log error message to console (if console available)\r\n\t * @method\r\n\t * @param {...*} msg\r\n\t */\n\tmodule.exports.logError = function logError(msg) {\n\t  if (console) {\n\t    console.error.apply(console, arguments);\n\t  }\n\t};\n\t\n\t/**\r\n\t * Log warning message to console (if console available)\r\n\t * @method\r\n\t * @param {...*} msg\r\n\t */\n\tmodule.exports.logWarn = function logWarn(msg) {\n\t  if (console) {\n\t    console.warn.apply(console, arguments);\n\t  }\n\t};\n\t\n\t/**\r\n\t * Log debug message to console.\r\n\t * Since it binded to console, can also be used to debug Promise resolving in this way:\r\n\t *\r\n\t *      UB.get('timeStamp').then(UB.logDebug);\r\n\t *\r\n\t * @method\r\n\t * @param {...*} msg\r\n\t */\n\tmodule.exports.logDebug = console.info.bind(console);\n\t\n\tvar userAgent = navigator && navigator.userAgent ? navigator.userAgent.toLowerCase() : '';\n\t/** @type {String} */\n\tmodule.exports.userAgent = navigator.userAgent.toLowerCase();\n\t/** @type {Boolean} */\n\tmodule.exports.isChrome = /\\bchrome\\b/.test(userAgent);\n\t/** @type {Boolean} */\n\tmodule.exports.isWebKit = /webkit/.test(userAgent);\n\t/** @type {Boolean} */\n\tmodule.exports.isGecko = !/webkit/.test(userAgent) && /gecko/.test(userAgent);\n\t/** @type {Boolean} */\n\tmodule.exports.isOpera = /opr|opera/.test(userAgent);\n\t/** @type {Boolean} */\n\tmodule.exports.isMac = /macintosh|mac os x/.test(userAgent);\n\t/** @type {Boolean} */\n\tmodule.exports.isSecureBrowser = /\\belectron\\b/.test(userAgent);\n\n/***/ },\n/* 2 */,\n/* 3 */,\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t;(function (root, factory) {\n\t\tif (true) {\n\t\t\t// CommonJS\n\t\t\tmodule.exports = exports = factory();\n\t\t}\n\t\telse if (typeof define === \"function\" && define.amd) {\n\t\t\t// AMD\n\t\t\tdefine([], factory);\n\t\t}\n\t\telse {\n\t\t\t// Global (browser)\n\t\t\troot.CryptoJS = factory();\n\t\t}\n\t}(this, function () {\n\t\n\t\t/**\n\t\t * CryptoJS core components.\n\t\t */\n\t\tvar CryptoJS = CryptoJS || (function (Math, undefined) {\n\t\t    /**\n\t\t     * CryptoJS namespace.\n\t\t     */\n\t\t    var C = {};\n\t\n\t\t    /**\n\t\t     * Library namespace.\n\t\t     */\n\t\t    var C_lib = C.lib = {};\n\t\n\t\t    /**\n\t\t     * Base object for prototypal inheritance.\n\t\t     */\n\t\t    var Base = C_lib.Base = (function () {\n\t\t        function F() {}\n\t\n\t\t        return {\n\t\t            /**\n\t\t             * Creates a new object that inherits from this object.\n\t\t             *\n\t\t             * @param {Object} overrides Properties to copy into the new object.\n\t\t             *\n\t\t             * @return {Object} The new object.\n\t\t             *\n\t\t             * @static\n\t\t             *\n\t\t             * @example\n\t\t             *\n\t\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t\t             *         field: 'value',\n\t\t             *\n\t\t             *         method: function () {\n\t\t             *         }\n\t\t             *     });\n\t\t             */\n\t\t            extend: function (overrides) {\n\t\t                // Spawn\n\t\t                F.prototype = this;\n\t\t                var subtype = new F();\n\t\n\t\t                // Augment\n\t\t                if (overrides) {\n\t\t                    subtype.mixIn(overrides);\n\t\t                }\n\t\n\t\t                // Create default initializer\n\t\t                if (!subtype.hasOwnProperty('init')) {\n\t\t                    subtype.init = function () {\n\t\t                        subtype.$super.init.apply(this, arguments);\n\t\t                    };\n\t\t                }\n\t\n\t\t                // Initializer's prototype is the subtype object\n\t\t                subtype.init.prototype = subtype;\n\t\n\t\t                // Reference supertype\n\t\t                subtype.$super = this;\n\t\n\t\t                return subtype;\n\t\t            },\n\t\n\t\t            /**\n\t\t             * Extends this object and runs the init method.\n\t\t             * Arguments to create() will be passed to init().\n\t\t             *\n\t\t             * @return {Object} The new object.\n\t\t             *\n\t\t             * @static\n\t\t             *\n\t\t             * @example\n\t\t             *\n\t\t             *     var instance = MyType.create();\n\t\t             */\n\t\t            create: function () {\n\t\t                var instance = this.extend();\n\t\t                instance.init.apply(instance, arguments);\n\t\n\t\t                return instance;\n\t\t            },\n\t\n\t\t            /**\n\t\t             * Initializes a newly created object.\n\t\t             * Override this method to add some logic when your objects are created.\n\t\t             *\n\t\t             * @example\n\t\t             *\n\t\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t\t             *         init: function () {\n\t\t             *             // ...\n\t\t             *         }\n\t\t             *     });\n\t\t             */\n\t\t            init: function () {\n\t\t            },\n\t\n\t\t            /**\n\t\t             * Copies properties into this object.\n\t\t             *\n\t\t             * @param {Object} properties The properties to mix in.\n\t\t             *\n\t\t             * @example\n\t\t             *\n\t\t             *     MyType.mixIn({\n\t\t             *         field: 'value'\n\t\t             *     });\n\t\t             */\n\t\t            mixIn: function (properties) {\n\t\t                for (var propertyName in properties) {\n\t\t                    if (properties.hasOwnProperty(propertyName)) {\n\t\t                        this[propertyName] = properties[propertyName];\n\t\t                    }\n\t\t                }\n\t\n\t\t                // IE won't copy toString using the loop above\n\t\t                if (properties.hasOwnProperty('toString')) {\n\t\t                    this.toString = properties.toString;\n\t\t                }\n\t\t            },\n\t\n\t\t            /**\n\t\t             * Creates a copy of this object.\n\t\t             *\n\t\t             * @return {Object} The clone.\n\t\t             *\n\t\t             * @example\n\t\t             *\n\t\t             *     var clone = instance.clone();\n\t\t             */\n\t\t            clone: function () {\n\t\t                return this.init.prototype.extend(this);\n\t\t            }\n\t\t        };\n\t\t    }());\n\t\n\t\t    /**\n\t\t     * An array of 32-bit words.\n\t\t     *\n\t\t     * @property {Array} words The array of 32-bit words.\n\t\t     * @property {number} sigBytes The number of significant bytes in this word array.\n\t\t     */\n\t\t    var WordArray = C_lib.WordArray = Base.extend({\n\t\t        /**\n\t\t         * Initializes a newly created word array.\n\t\t         *\n\t\t         * @param {Array} words (Optional) An array of 32-bit words.\n\t\t         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var wordArray = CryptoJS.lib.WordArray.create();\n\t\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n\t\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n\t\t         */\n\t\t        init: function (words, sigBytes) {\n\t\t            words = this.words = words || [];\n\t\n\t\t            if (sigBytes != undefined) {\n\t\t                this.sigBytes = sigBytes;\n\t\t            } else {\n\t\t                this.sigBytes = words.length * 4;\n\t\t            }\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Converts this word array to a string.\n\t\t         *\n\t\t         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n\t\t         *\n\t\t         * @return {string} The stringified word array.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var string = wordArray + '';\n\t\t         *     var string = wordArray.toString();\n\t\t         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n\t\t         */\n\t\t        toString: function (encoder) {\n\t\t            return (encoder || Hex).stringify(this);\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Concatenates a word array to this word array.\n\t\t         *\n\t\t         * @param {WordArray} wordArray The word array to append.\n\t\t         *\n\t\t         * @return {WordArray} This word array.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     wordArray1.concat(wordArray2);\n\t\t         */\n\t\t        concat: function (wordArray) {\n\t\t            // Shortcuts\n\t\t            var thisWords = this.words;\n\t\t            var thatWords = wordArray.words;\n\t\t            var thisSigBytes = this.sigBytes;\n\t\t            var thatSigBytes = wordArray.sigBytes;\n\t\n\t\t            // Clamp excess bits\n\t\t            this.clamp();\n\t\n\t\t            // Concat\n\t\t            if (thisSigBytes % 4) {\n\t\t                // Copy one byte at a time\n\t\t                for (var i = 0; i < thatSigBytes; i++) {\n\t\t                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t\t                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n\t\t                }\n\t\t            } else if (thatWords.length > 0xffff) {\n\t\t                // Copy one word at a time\n\t\t                for (var i = 0; i < thatSigBytes; i += 4) {\n\t\t                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n\t\t                }\n\t\t            } else {\n\t\t                // Copy all words at once\n\t\t                thisWords.push.apply(thisWords, thatWords);\n\t\t            }\n\t\t            this.sigBytes += thatSigBytes;\n\t\n\t\t            // Chainable\n\t\t            return this;\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Removes insignificant bits.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     wordArray.clamp();\n\t\t         */\n\t\t        clamp: function () {\n\t\t            // Shortcuts\n\t\t            var words = this.words;\n\t\t            var sigBytes = this.sigBytes;\n\t\n\t\t            // Clamp\n\t\t            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n\t\t            words.length = Math.ceil(sigBytes / 4);\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Creates a copy of this word array.\n\t\t         *\n\t\t         * @return {WordArray} The clone.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var clone = wordArray.clone();\n\t\t         */\n\t\t        clone: function () {\n\t\t            var clone = Base.clone.call(this);\n\t\t            clone.words = this.words.slice(0);\n\t\n\t\t            return clone;\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Creates a word array filled with random bytes.\n\t\t         *\n\t\t         * @param {number} nBytes The number of random bytes to generate.\n\t\t         *\n\t\t         * @return {WordArray} The random word array.\n\t\t         *\n\t\t         * @static\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n\t\t         */\n\t\t        random: function (nBytes) {\n\t\t            var words = [];\n\t\n\t\t            var r = (function (m_w) {\n\t\t                var m_w = m_w;\n\t\t                var m_z = 0x3ade68b1;\n\t\t                var mask = 0xffffffff;\n\t\n\t\t                return function () {\n\t\t                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;\n\t\t                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;\n\t\t                    var result = ((m_z << 0x10) + m_w) & mask;\n\t\t                    result /= 0x100000000;\n\t\t                    result += 0.5;\n\t\t                    return result * (Math.random() > .5 ? 1 : -1);\n\t\t                }\n\t\t            });\n\t\n\t\t            for (var i = 0, rcache; i < nBytes; i += 4) {\n\t\t                var _r = r((rcache || Math.random()) * 0x100000000);\n\t\n\t\t                rcache = _r() * 0x3ade67b7;\n\t\t                words.push((_r() * 0x100000000) | 0);\n\t\t            }\n\t\n\t\t            return new WordArray.init(words, nBytes);\n\t\t        }\n\t\t    });\n\t\n\t\t    /**\n\t\t     * Encoder namespace.\n\t\t     */\n\t\t    var C_enc = C.enc = {};\n\t\n\t\t    /**\n\t\t     * Hex encoding strategy.\n\t\t     */\n\t\t    var Hex = C_enc.Hex = {\n\t\t        /**\n\t\t         * Converts a word array to a hex string.\n\t\t         *\n\t\t         * @param {WordArray} wordArray The word array.\n\t\t         *\n\t\t         * @return {string} The hex string.\n\t\t         *\n\t\t         * @static\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n\t\t         */\n\t\t        stringify: function (wordArray) {\n\t\t            // Shortcuts\n\t\t            var words = wordArray.words;\n\t\t            var sigBytes = wordArray.sigBytes;\n\t\n\t\t            // Convert\n\t\t            var hexChars = [];\n\t\t            for (var i = 0; i < sigBytes; i++) {\n\t\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t\t                hexChars.push((bite >>> 4).toString(16));\n\t\t                hexChars.push((bite & 0x0f).toString(16));\n\t\t            }\n\t\n\t\t            return hexChars.join('');\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Converts a hex string to a word array.\n\t\t         *\n\t\t         * @param {string} hexStr The hex string.\n\t\t         *\n\t\t         * @return {WordArray} The word array.\n\t\t         *\n\t\t         * @static\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n\t\t         */\n\t\t        parse: function (hexStr) {\n\t\t            // Shortcut\n\t\t            var hexStrLength = hexStr.length;\n\t\n\t\t            // Convert\n\t\t            var words = [];\n\t\t            for (var i = 0; i < hexStrLength; i += 2) {\n\t\t                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n\t\t            }\n\t\n\t\t            return new WordArray.init(words, hexStrLength / 2);\n\t\t        }\n\t\t    };\n\t\n\t\t    /**\n\t\t     * Latin1 encoding strategy.\n\t\t     */\n\t\t    var Latin1 = C_enc.Latin1 = {\n\t\t        /**\n\t\t         * Converts a word array to a Latin1 string.\n\t\t         *\n\t\t         * @param {WordArray} wordArray The word array.\n\t\t         *\n\t\t         * @return {string} The Latin1 string.\n\t\t         *\n\t\t         * @static\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n\t\t         */\n\t\t        stringify: function (wordArray) {\n\t\t            // Shortcuts\n\t\t            var words = wordArray.words;\n\t\t            var sigBytes = wordArray.sigBytes;\n\t\n\t\t            // Convert\n\t\t            var latin1Chars = [];\n\t\t            for (var i = 0; i < sigBytes; i++) {\n\t\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t\t                latin1Chars.push(String.fromCharCode(bite));\n\t\t            }\n\t\n\t\t            return latin1Chars.join('');\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Converts a Latin1 string to a word array.\n\t\t         *\n\t\t         * @param {string} latin1Str The Latin1 string.\n\t\t         *\n\t\t         * @return {WordArray} The word array.\n\t\t         *\n\t\t         * @static\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n\t\t         */\n\t\t        parse: function (latin1Str) {\n\t\t            // Shortcut\n\t\t            var latin1StrLength = latin1Str.length;\n\t\n\t\t            // Convert\n\t\t            var words = [];\n\t\t            for (var i = 0; i < latin1StrLength; i++) {\n\t\t                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n\t\t            }\n\t\n\t\t            return new WordArray.init(words, latin1StrLength);\n\t\t        }\n\t\t    };\n\t\n\t\t    /**\n\t\t     * UTF-8 encoding strategy.\n\t\t     */\n\t\t    var Utf8 = C_enc.Utf8 = {\n\t\t        /**\n\t\t         * Converts a word array to a UTF-8 string.\n\t\t         *\n\t\t         * @param {WordArray} wordArray The word array.\n\t\t         *\n\t\t         * @return {string} The UTF-8 string.\n\t\t         *\n\t\t         * @static\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n\t\t         */\n\t\t        stringify: function (wordArray) {\n\t\t            try {\n\t\t                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n\t\t            } catch (e) {\n\t\t                throw new Error('Malformed UTF-8 data');\n\t\t            }\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Converts a UTF-8 string to a word array.\n\t\t         *\n\t\t         * @param {string} utf8Str The UTF-8 string.\n\t\t         *\n\t\t         * @return {WordArray} The word array.\n\t\t         *\n\t\t         * @static\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n\t\t         */\n\t\t        parse: function (utf8Str) {\n\t\t            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n\t\t        }\n\t\t    };\n\t\n\t\t    /**\n\t\t     * Abstract buffered block algorithm template.\n\t\t     *\n\t\t     * The property blockSize must be implemented in a concrete subtype.\n\t\t     *\n\t\t     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n\t\t     */\n\t\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n\t\t        /**\n\t\t         * Resets this block algorithm's data buffer to its initial state.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     bufferedBlockAlgorithm.reset();\n\t\t         */\n\t\t        reset: function () {\n\t\t            // Initial values\n\t\t            this._data = new WordArray.init();\n\t\t            this._nDataBytes = 0;\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Adds new data to this block algorithm's buffer.\n\t\t         *\n\t\t         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     bufferedBlockAlgorithm._append('data');\n\t\t         *     bufferedBlockAlgorithm._append(wordArray);\n\t\t         */\n\t\t        _append: function (data) {\n\t\t            // Convert string to WordArray, else assume WordArray already\n\t\t            if (typeof data == 'string') {\n\t\t                data = Utf8.parse(data);\n\t\t            }\n\t\n\t\t            // Append\n\t\t            this._data.concat(data);\n\t\t            this._nDataBytes += data.sigBytes;\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Processes available data blocks.\n\t\t         *\n\t\t         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n\t\t         *\n\t\t         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n\t\t         *\n\t\t         * @return {WordArray} The processed data.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var processedData = bufferedBlockAlgorithm._process();\n\t\t         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n\t\t         */\n\t\t        _process: function (doFlush) {\n\t\t            // Shortcuts\n\t\t            var data = this._data;\n\t\t            var dataWords = data.words;\n\t\t            var dataSigBytes = data.sigBytes;\n\t\t            var blockSize = this.blockSize;\n\t\t            var blockSizeBytes = blockSize * 4;\n\t\n\t\t            // Count blocks ready\n\t\t            var nBlocksReady = dataSigBytes / blockSizeBytes;\n\t\t            if (doFlush) {\n\t\t                // Round up to include partial blocks\n\t\t                nBlocksReady = Math.ceil(nBlocksReady);\n\t\t            } else {\n\t\t                // Round down to include only full blocks,\n\t\t                // less the number of blocks that must remain in the buffer\n\t\t                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n\t\t            }\n\t\n\t\t            // Count words ready\n\t\t            var nWordsReady = nBlocksReady * blockSize;\n\t\n\t\t            // Count bytes ready\n\t\t            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\t\n\t\t            // Process blocks\n\t\t            if (nWordsReady) {\n\t\t                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n\t\t                    // Perform concrete-algorithm logic\n\t\t                    this._doProcessBlock(dataWords, offset);\n\t\t                }\n\t\n\t\t                // Remove processed words\n\t\t                var processedWords = dataWords.splice(0, nWordsReady);\n\t\t                data.sigBytes -= nBytesReady;\n\t\t            }\n\t\n\t\t            // Return processed words\n\t\t            return new WordArray.init(processedWords, nBytesReady);\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Creates a copy of this object.\n\t\t         *\n\t\t         * @return {Object} The clone.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var clone = bufferedBlockAlgorithm.clone();\n\t\t         */\n\t\t        clone: function () {\n\t\t            var clone = Base.clone.call(this);\n\t\t            clone._data = this._data.clone();\n\t\n\t\t            return clone;\n\t\t        },\n\t\n\t\t        _minBufferSize: 0\n\t\t    });\n\t\n\t\t    /**\n\t\t     * Abstract hasher template.\n\t\t     *\n\t\t     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n\t\t     */\n\t\t    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n\t\t        /**\n\t\t         * Configuration options.\n\t\t         */\n\t\t        cfg: Base.extend(),\n\t\n\t\t        /**\n\t\t         * Initializes a newly created hasher.\n\t\t         *\n\t\t         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var hasher = CryptoJS.algo.SHA256.create();\n\t\t         */\n\t\t        init: function (cfg) {\n\t\t            // Apply config defaults\n\t\t            this.cfg = this.cfg.extend(cfg);\n\t\n\t\t            // Set initial values\n\t\t            this.reset();\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Resets this hasher to its initial state.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     hasher.reset();\n\t\t         */\n\t\t        reset: function () {\n\t\t            // Reset data buffer\n\t\t            BufferedBlockAlgorithm.reset.call(this);\n\t\n\t\t            // Perform concrete-hasher logic\n\t\t            this._doReset();\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Updates this hasher with a message.\n\t\t         *\n\t\t         * @param {WordArray|string} messageUpdate The message to append.\n\t\t         *\n\t\t         * @return {Hasher} This hasher.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     hasher.update('message');\n\t\t         *     hasher.update(wordArray);\n\t\t         */\n\t\t        update: function (messageUpdate) {\n\t\t            // Append\n\t\t            this._append(messageUpdate);\n\t\n\t\t            // Update the hash\n\t\t            this._process();\n\t\n\t\t            // Chainable\n\t\t            return this;\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Finalizes the hash computation.\n\t\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t\t         *\n\t\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n\t\t         *\n\t\t         * @return {WordArray} The hash.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var hash = hasher.finalize();\n\t\t         *     var hash = hasher.finalize('message');\n\t\t         *     var hash = hasher.finalize(wordArray);\n\t\t         */\n\t\t        finalize: function (messageUpdate) {\n\t\t            // Final message update\n\t\t            if (messageUpdate) {\n\t\t                this._append(messageUpdate);\n\t\t            }\n\t\n\t\t            // Perform concrete-hasher logic\n\t\t            var hash = this._doFinalize();\n\t\n\t\t            return hash;\n\t\t        },\n\t\n\t\t        blockSize: 512/32,\n\t\n\t\t        /**\n\t\t         * Creates a shortcut function to a hasher's object interface.\n\t\t         *\n\t\t         * @param {Hasher} hasher The hasher to create a helper for.\n\t\t         *\n\t\t         * @return {Function} The shortcut function.\n\t\t         *\n\t\t         * @static\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n\t\t         */\n\t\t        _createHelper: function (hasher) {\n\t\t            return function (message, cfg) {\n\t\t                return new hasher.init(cfg).finalize(message);\n\t\t            };\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Creates a shortcut function to the HMAC's object interface.\n\t\t         *\n\t\t         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n\t\t         *\n\t\t         * @return {Function} The shortcut function.\n\t\t         *\n\t\t         * @static\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n\t\t         */\n\t\t        _createHmacHelper: function (hasher) {\n\t\t            return function (message, key) {\n\t\t                return new C_algo.HMAC.init(hasher, key).finalize(message);\n\t\t            };\n\t\t        }\n\t\t    });\n\t\n\t\t    /**\n\t\t     * Algorithm namespace.\n\t\t     */\n\t\t    var C_algo = C.algo = {};\n\t\n\t\t    return C;\n\t\t}(Math));\n\t\n\t\n\t\treturn CryptoJS;\n\t\n\t}));\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/*\n\t @author pavel.mash\n\t */\n\t\n\t// ***********   !!!!WARNING!!!!! **********************\n\t// This module is a modified copy of server-side EventEmitter\n\t// to prevent conflicts in case on modification\n\t// modify both file - this and \\modules\\events.js\n\t\n\t/**\n\t * NodeJS like EventEmitter for Browser usage. See also <a href=\"http://nodejs.org/api/events.html\">NodeJS events documentation</a>\n\t *\n\t * To add event emitting ability to any object:\n\t *\n\t\n\t     var myObject = {},\n\t     var EventEmitter = UB.EventEmitter;\n\t     // add EventEmitter to myObject\n\t     EventEmitter.call(myObject);\n\t     _.assign(myObject, EventEmitter.prototype);\n\t\n\t * In case object created via constructor function\n\t\n\t     var EventEmitter = UB.EventEmitter;\n\t     function MyObject() {\n\t        EventEmitter.call(this);\n\t     }\n\t     MyObject.prototype = _.create(EventEmitter.prototype);\n\t     var myObject = new MyObject();\n\t     myObject instanceof UB.EventEmitter; //true\n\t\n\t * Usage:\n\t\n\t     myObject.on('myEvent', function(num, str){console.log(num, str) });\n\t\n\t     myObject.emit('myEvent', 1, 'two'); // output: 1 \"two\"\n\t\n\t *\n\t * @class EventEmitter\n\t * @mixin\n\t */\n\t\n\tfunction EventEmitter() {\n\t  EventEmitter.init.call(this);\n\t}\n\t\n\t/**\n\t * Private collection of events.\n\t * @private\n\t */\n\tEventEmitter.prototype._events = undefined;\n\t/**\n\t * Use set/get MaxListeners instead direct access\n\t * @private\n\t */\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\t/**\n\t * @private\n\t */\n\tEventEmitter.init = function () {\n\t  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {\n\t    this._events = {};\n\t    this._eventsCount = 0;\n\t  }\n\t\n\t  this._maxListeners = this._maxListeners || undefined;\n\t};\n\t\n\t/**\n\t * Obviously not all Emitters should be limited to 10. This function allows\n\t * that to be increased. Set to zero for unlimited.\n\t * @param {Number} n\n\t */\n\tEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n\t  if (typeof n !== 'number' || n < 0 || isNaN(n)) {\n\t    throw new TypeError('n must be a positive number');\n\t  }\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\t\n\tfunction $getMaxListeners(that) {\n\t  if (that._maxListeners === undefined) {\n\t    return EventEmitter.defaultMaxListeners;\n\t  }\n\t  return that._maxListeners;\n\t}\n\t\n\t/**\n\t *\n\t * @return {Number}\n\t */\n\tEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n\t  return $getMaxListeners(this);\n\t};\n\t\n\t// These standalone emit* functions are used to optimize calling of event\n\t// handlers for fast cases because emit() itself often has a variable number of\n\t// arguments and can be deoptimized because of that. These functions always have\n\t// the same number of arguments and thus do not get deoptimized, so the code\n\t// inside them can execute faster.\n\tfunction emitNone(handler, isFn, self) {\n\t  if (isFn) {\n\t    handler.call(self);\n\t  } else {\n\t    var len = handler.length;\n\t    var listeners = arrayClone(handler, len);\n\t    for (var i = 0; i < len; ++i) {\n\t      listeners[i].call(self);\n\t    }\n\t  }\n\t}\n\tfunction emitOne(handler, isFn, self, arg1) {\n\t  if (isFn) {\n\t    handler.call(self, arg1);\n\t  } else {\n\t    var len = handler.length;\n\t    var listeners = arrayClone(handler, len);\n\t    for (var i = 0; i < len; ++i) {\n\t      listeners[i].call(self, arg1);\n\t    }\n\t  }\n\t}\n\tfunction emitTwo(handler, isFn, self, arg1, arg2) {\n\t  if (isFn) {\n\t    handler.call(self, arg1, arg2);\n\t  } else {\n\t    var len = handler.length;\n\t    var listeners = arrayClone(handler, len);\n\t    for (var i = 0; i < len; ++i) {\n\t      listeners[i].call(self, arg1, arg2);\n\t    }\n\t  }\n\t}\n\tfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n\t  if (isFn) {\n\t    handler.call(self, arg1, arg2, arg3);\n\t  } else {\n\t    var len = handler.length;\n\t    var listeners = arrayClone(handler, len);\n\t    for (var i = 0; i < len; ++i) {\n\t      listeners[i].call(self, arg1, arg2, arg3);\n\t    }\n\t  }\n\t}\n\t\n\tfunction emitMany(handler, isFn, self, args) {\n\t  if (isFn) {\n\t    handler.apply(self, args);\n\t  } else {\n\t    var len = handler.length;\n\t    var listeners = arrayClone(handler, len);\n\t    for (var i = 0; i < len; ++i) {\n\t      listeners[i].apply(self, args);\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Execute each of the listeners in order with the supplied arguments.\n\t * Returns true if event had listeners, false otherwise.\n\t *\n\t * @param {String} type Event name\n\t * @param {...*} eventArgs Arguments, passed to listeners\n\t * @return {boolean}\n\t */\n\tEventEmitter.prototype.emit = function emit(type) {\n\t  var er, handler, len, args, i, events; /* UB domain */\n\t  // UB var needDomainExit = false;\n\t  var doError = type === 'error';\n\t\n\t  events = this._events;\n\t  if (events) {\n\t    doError = doError && events.error == null;\n\t  } else if (!doError) {\n\t    return false;\n\t  }\n\t\n\t  // UB domain = this.domain;\n\t\n\t  // If there is no 'error' event listener then throw.\n\t  if (doError) {\n\t    er = arguments[1];\n\t    if (er instanceof Error) {\n\t      throw er; // Unhandled 'error' event\n\t    } else {\n\t      // At least give some kind of context to the user\n\t      var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n\t      err.context = er;\n\t      throw err;\n\t    }\n\t  }\n\t\n\t  handler = events[type];\n\t\n\t  if (!handler) {\n\t    return false;\n\t  }\n\t\n\t  var isFn = typeof handler === 'function';\n\t  len = arguments.length;\n\t  switch (len) {\n\t    // fast cases\n\t    case 1:\n\t      emitNone(handler, isFn, this);\n\t      break;\n\t    case 2:\n\t      emitOne(handler, isFn, this, arguments[1]);\n\t      break;\n\t    case 3:\n\t      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n\t      break;\n\t    case 4:\n\t      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n\t      break;\n\t    // slower\n\t    default:\n\t      args = new Array(len - 1);\n\t      for (i = 1; i < len; i++) {\n\t        args[i - 1] = arguments[i];\n\t      }\n\t      emitMany(handler, isFn, this, args);\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\t/**\n\t * Adds a listener to the end of the listeners array for the specified event.\n\t * Will emit `newListener` event on success.\n\t *\n\t * Usage sample:\n\t *\n\t *      Session.on('login', function () {\n\t *          console.log('someone connected!');\n\t *      });\n\t *\n\t * Returns emitter, so calls can be chained.\n\t *\n\t * @param {String} type Event name\n\t * @param {Function} listener\n\t * @return {EventEmitter}\n\t */\n\tEventEmitter.prototype.addListener = function addListener(type, listener) {\n\t  var m;\n\t  var events;\n\t  var existing;\n\t\n\t  if (typeof listener !== 'function') {\n\t    throw new TypeError('listener must be a function');\n\t  }\n\t\n\t  events = this._events;\n\t  if (!events) {\n\t    events = this._events = {};\n\t    this._eventsCount = 0;\n\t  } else {\n\t    // To avoid recursion in the case that type === \"newListener\"! Before\n\t    // adding it to the listeners, first emit \"newListener\".\n\t    if (events.newListener) {\n\t      /** @event  newListener */\n\t      this.emit('newListener', type, listener.listener ? listener.listener : listener);\n\t\n\t      // Re-assign `events` because a newListener handler could have caused the\n\t      // this._events to be assigned to a new object\n\t      events = this._events;\n\t    }\n\t    existing = events[type];\n\t  }\n\t\n\t  if (!existing) {\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    existing = events[type] = listener;\n\t    ++this._eventsCount;\n\t  } else {\n\t    if (typeof existing === 'function') {\n\t      // Adding the second element, need to change to array.\n\t      existing = events[type] = [existing, listener];\n\t    } else {\n\t      // If we've already got an array, just append.\n\t      existing.push(listener);\n\t    }\n\t\n\t    // Check for listener leak\n\t    if (!existing.warned) {\n\t      m = $getMaxListeners(this);\n\t      if (m && m > 0 && existing.length > m) {\n\t        existing.warned = true;\n\t        console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d %s listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', existing.length, type);\n\t        console.trace();\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Alias for {@link EventEmitter#addListener addListener}\n\t * @param {String} type Event name\n\t * @param {Function} listener\n\t * @return {EventEmitter}\n\t */\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\t/**\n\t * Adds a one time listener for the event. This listener is invoked only the next time the event is fired, after which it is removed.\n\t * @param {String} type Event name\n\t * @param {Function} listener\n\t * @return {EventEmitter}\n\t */\n\tEventEmitter.prototype.once = function once(type, listener) {\n\t  if (typeof listener !== 'function') {\n\t    throw new TypeError('listener must be a function');\n\t  }\n\t\n\t  var fired = false;\n\t\n\t  function g() {\n\t    this.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  g.listener = listener;\n\t  this.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove a listener from the listener array for the specified event.\n\t * Caution: changes array indices in the listener array behind the listener.\n\t * Emits a 'removeListener' event if the listener was removed.\n\t *\n\t * @param {String} type Event name\n\t * @param {Function} listener\n\t */\n\tEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n\t  var list, events, position, i;\n\t\n\t  if (typeof listener !== 'function') {\n\t    throw new TypeError('listener must be a function');\n\t  }\n\t\n\t  events = this._events;\n\t  if (!events) {\n\t    return this;\n\t  }\n\t\n\t  list = events[type];\n\t  if (!list) {\n\t    return this;\n\t  }\n\t\n\t  if (list === listener || list.listener && list.listener === listener) {\n\t    if (--this._eventsCount === 0) {\n\t      this._events = {};\n\t    } else {\n\t      delete events[type];\n\t      if (events.removeListener)\n\t        /** @event removeListener */\n\t        {\n\t          this.emit('removeListener', type, listener);\n\t        }\n\t    }\n\t  } else if (typeof list !== 'function') {\n\t    position = -1;\n\t\n\t    for (i = list.length; i-- > 0;) {\n\t      if (list[i] === listener || list[i].listener && list[i].listener === listener) {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0) {\n\t      return this;\n\t    }\n\t\n\t    if (list.length === 1) {\n\t      list[0] = undefined;\n\t      if (--this._eventsCount === 0) {\n\t        this._events = {};\n\t        return this;\n\t      } else {\n\t        delete events[type];\n\t      }\n\t    } else {\n\t      spliceOne(list, position);\n\t    }\n\t\n\t    if (events.removeListener) {\n\t      this.emit('removeListener', type, listener);\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Removes all listeners, or those of the specified event.\n\t * It's not a good idea to remove listeners that were added elsewhere in the code,\n\t * especially when it's on an emitter that you didn't create (e.g. sockets or file streams).\n\t *\n\t * Returns emitter, so calls can be chained.\n\t * @param {String} type Event name\n\t * @return {EventEmitter}\n\t */\n\tEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n\t  var listeners, events;\n\t\n\t  events = this._events;\n\t  if (!events) {\n\t    return this;\n\t  }\n\t\n\t  // not listening for removeListener, no need to emit\n\t  if (!events.removeListener) {\n\t    if (arguments.length === 0) {\n\t      this._events = {};\n\t      this._eventsCount = 0;\n\t    } else if (events[type]) {\n\t      if (--this._eventsCount === 0) {\n\t        this._events = {};\n\t      } else {\n\t        delete events[type];\n\t      }\n\t    }\n\t    return this;\n\t  }\n\t\n\t  // emit removeListener for all listeners on all events\n\t  if (arguments.length === 0) {\n\t    var keys = Object.keys(events);\n\t    for (var i = 0, key; i < keys.length; ++i) {\n\t      key = keys[i];\n\t      if (key === 'removeListener') continue;\n\t      this.removeAllListeners(key);\n\t    }\n\t    this.removeAllListeners('removeListener');\n\t    this._events = {};\n\t    this._eventsCount = 0;\n\t    return this;\n\t  }\n\t\n\t  listeners = events[type];\n\t\n\t  if (typeof listeners === 'function') {\n\t    this.removeListener(type, listeners);\n\t  } else if (listeners) {\n\t    // LIFO order\n\t    do {\n\t      this.removeListener(type, listeners[listeners.length - 1]);\n\t    } while (listeners[0]);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Returns an array of listeners for the specified event.\n\t * @param {String} type Event name\n\t * @return {Array.<Function>}\n\t */\n\tEventEmitter.prototype.listeners = function listeners(type) {\n\t  var evlistener;\n\t  var ret;\n\t  var events = this._events;\n\t\n\t  if (!events) {\n\t    ret = [];\n\t  } else {\n\t    evlistener = events[type];\n\t    if (!evlistener) {\n\t      ret = [];\n\t    } else if (typeof evlistener === 'function') {\n\t      ret = [evlistener];\n\t    } else {\n\t      ret = arrayClone(evlistener, evlistener.length);\n\t    }\n\t  }\n\t\n\t  return ret;\n\t};\n\t\n\t/**\n\t * Return the number of listeners for a given event.\n\t * @param {EventEmitter} emitter\n\t * @param {String} type\n\t * @return {Number}\n\t */\n\tEventEmitter.listenerCount = function (emitter, type) {\n\t  if (typeof emitter.listenerCount === 'function') {\n\t    return emitter.listenerCount(type);\n\t  } else {\n\t    return listenerCount.call(emitter, type);\n\t  }\n\t};\n\t\n\tEventEmitter.prototype.listenerCount = listenerCount;\n\tfunction listenerCount(type) {\n\t  var events = this._events;\n\t\n\t  if (events) {\n\t    var evlistener = events[type];\n\t\n\t    if (typeof evlistener === 'function') {\n\t      return 1;\n\t    } else if (evlistener) {\n\t      return evlistener.length;\n\t    }\n\t  }\n\t\n\t  return 0;\n\t}\n\t\n\t// About 1.5x faster than the two-arg version of Array#splice().\n\tfunction spliceOne(list, index) {\n\t  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {\n\t    list[i] = list[k];\n\t  }\n\t  list.pop();\n\t}\n\t\n\tfunction arrayClone(arr, i) {\n\t  var copy = new Array(i);\n\t  while (i--) {\n\t    copy[i] = arr[i];\n\t  }\n\t  return copy;\n\t}\n\t\n\tmodule.exports = EventEmitter;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\r\n\t * Created by pavel.mash on 01.12.2016.\r\n\t */\n\t\n\tvar _ = __webpack_require__(2);\n\t\n\tvar __i18n = {\n\t  monkeyRequestsDetected: 'Your request has been processed, but we found that it is repeated several times. Maybe you key fuse?'\n\t};\n\t\n\t/**\r\n\t * Return locale-specific resource from it identifier.\r\n\t * localeString must be previously defined dy call to {i18nExtend}\r\n\t * @param {String} localeString\r\n\t * @returns {*}\r\n\t */\n\tfunction i18n(localeString) {\n\t  return __i18n[localeString] || localeString;\n\t}\n\t\n\t/**\r\n\t * Merge localizationObject to UB.i18n. Usually called form modelPublic/locale/lang-*.js scripts\r\n\t * @param {Object} localizationObject\r\n\t */\n\tfunction i18nExtend(localizationObject) {\n\t  _.merge(__i18n, localizationObject);\n\t}\n\t\n\tmodule.exports = {\n\t  i18n: i18n,\n\t  i18nExtend: i18nExtend\n\t};\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t;(function (root, factory) {\n\t\tif (true) {\n\t\t\t// CommonJS\n\t\t\tmodule.exports = exports = factory(__webpack_require__(4));\n\t\t}\n\t\telse if (typeof define === \"function\" && define.amd) {\n\t\t\t// AMD\n\t\t\tdefine([\"./core\"], factory);\n\t\t}\n\t\telse {\n\t\t\t// Global (browser)\n\t\t\tfactory(root.CryptoJS);\n\t\t}\n\t}(this, function (CryptoJS) {\n\t\n\t\t(function (Math) {\n\t\t    // Shortcuts\n\t\t    var C = CryptoJS;\n\t\t    var C_lib = C.lib;\n\t\t    var WordArray = C_lib.WordArray;\n\t\t    var Hasher = C_lib.Hasher;\n\t\t    var C_algo = C.algo;\n\t\n\t\t    // Constants table\n\t\t    var T = [];\n\t\n\t\t    // Compute constants\n\t\t    (function () {\n\t\t        for (var i = 0; i < 64; i++) {\n\t\t            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;\n\t\t        }\n\t\t    }());\n\t\n\t\t    /**\n\t\t     * MD5 hash algorithm.\n\t\t     */\n\t\t    var MD5 = C_algo.MD5 = Hasher.extend({\n\t\t        _doReset: function () {\n\t\t            this._hash = new WordArray.init([\n\t\t                0x67452301, 0xefcdab89,\n\t\t                0x98badcfe, 0x10325476\n\t\t            ]);\n\t\t        },\n\t\n\t\t        _doProcessBlock: function (M, offset) {\n\t\t            // Swap endian\n\t\t            for (var i = 0; i < 16; i++) {\n\t\t                // Shortcuts\n\t\t                var offset_i = offset + i;\n\t\t                var M_offset_i = M[offset_i];\n\t\n\t\t                M[offset_i] = (\n\t\t                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |\n\t\t                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)\n\t\t                );\n\t\t            }\n\t\n\t\t            // Shortcuts\n\t\t            var H = this._hash.words;\n\t\n\t\t            var M_offset_0  = M[offset + 0];\n\t\t            var M_offset_1  = M[offset + 1];\n\t\t            var M_offset_2  = M[offset + 2];\n\t\t            var M_offset_3  = M[offset + 3];\n\t\t            var M_offset_4  = M[offset + 4];\n\t\t            var M_offset_5  = M[offset + 5];\n\t\t            var M_offset_6  = M[offset + 6];\n\t\t            var M_offset_7  = M[offset + 7];\n\t\t            var M_offset_8  = M[offset + 8];\n\t\t            var M_offset_9  = M[offset + 9];\n\t\t            var M_offset_10 = M[offset + 10];\n\t\t            var M_offset_11 = M[offset + 11];\n\t\t            var M_offset_12 = M[offset + 12];\n\t\t            var M_offset_13 = M[offset + 13];\n\t\t            var M_offset_14 = M[offset + 14];\n\t\t            var M_offset_15 = M[offset + 15];\n\t\n\t\t            // Working varialbes\n\t\t            var a = H[0];\n\t\t            var b = H[1];\n\t\t            var c = H[2];\n\t\t            var d = H[3];\n\t\n\t\t            // Computation\n\t\t            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);\n\t\t            d = FF(d, a, b, c, M_offset_1,  12, T[1]);\n\t\t            c = FF(c, d, a, b, M_offset_2,  17, T[2]);\n\t\t            b = FF(b, c, d, a, M_offset_3,  22, T[3]);\n\t\t            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);\n\t\t            d = FF(d, a, b, c, M_offset_5,  12, T[5]);\n\t\t            c = FF(c, d, a, b, M_offset_6,  17, T[6]);\n\t\t            b = FF(b, c, d, a, M_offset_7,  22, T[7]);\n\t\t            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);\n\t\t            d = FF(d, a, b, c, M_offset_9,  12, T[9]);\n\t\t            c = FF(c, d, a, b, M_offset_10, 17, T[10]);\n\t\t            b = FF(b, c, d, a, M_offset_11, 22, T[11]);\n\t\t            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);\n\t\t            d = FF(d, a, b, c, M_offset_13, 12, T[13]);\n\t\t            c = FF(c, d, a, b, M_offset_14, 17, T[14]);\n\t\t            b = FF(b, c, d, a, M_offset_15, 22, T[15]);\n\t\n\t\t            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);\n\t\t            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);\n\t\t            c = GG(c, d, a, b, M_offset_11, 14, T[18]);\n\t\t            b = GG(b, c, d, a, M_offset_0,  20, T[19]);\n\t\t            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);\n\t\t            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);\n\t\t            c = GG(c, d, a, b, M_offset_15, 14, T[22]);\n\t\t            b = GG(b, c, d, a, M_offset_4,  20, T[23]);\n\t\t            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);\n\t\t            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);\n\t\t            c = GG(c, d, a, b, M_offset_3,  14, T[26]);\n\t\t            b = GG(b, c, d, a, M_offset_8,  20, T[27]);\n\t\t            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);\n\t\t            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);\n\t\t            c = GG(c, d, a, b, M_offset_7,  14, T[30]);\n\t\t            b = GG(b, c, d, a, M_offset_12, 20, T[31]);\n\t\n\t\t            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);\n\t\t            d = HH(d, a, b, c, M_offset_8,  11, T[33]);\n\t\t            c = HH(c, d, a, b, M_offset_11, 16, T[34]);\n\t\t            b = HH(b, c, d, a, M_offset_14, 23, T[35]);\n\t\t            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);\n\t\t            d = HH(d, a, b, c, M_offset_4,  11, T[37]);\n\t\t            c = HH(c, d, a, b, M_offset_7,  16, T[38]);\n\t\t            b = HH(b, c, d, a, M_offset_10, 23, T[39]);\n\t\t            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);\n\t\t            d = HH(d, a, b, c, M_offset_0,  11, T[41]);\n\t\t            c = HH(c, d, a, b, M_offset_3,  16, T[42]);\n\t\t            b = HH(b, c, d, a, M_offset_6,  23, T[43]);\n\t\t            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);\n\t\t            d = HH(d, a, b, c, M_offset_12, 11, T[45]);\n\t\t            c = HH(c, d, a, b, M_offset_15, 16, T[46]);\n\t\t            b = HH(b, c, d, a, M_offset_2,  23, T[47]);\n\t\n\t\t            a = II(a, b, c, d, M_offset_0,  6,  T[48]);\n\t\t            d = II(d, a, b, c, M_offset_7,  10, T[49]);\n\t\t            c = II(c, d, a, b, M_offset_14, 15, T[50]);\n\t\t            b = II(b, c, d, a, M_offset_5,  21, T[51]);\n\t\t            a = II(a, b, c, d, M_offset_12, 6,  T[52]);\n\t\t            d = II(d, a, b, c, M_offset_3,  10, T[53]);\n\t\t            c = II(c, d, a, b, M_offset_10, 15, T[54]);\n\t\t            b = II(b, c, d, a, M_offset_1,  21, T[55]);\n\t\t            a = II(a, b, c, d, M_offset_8,  6,  T[56]);\n\t\t            d = II(d, a, b, c, M_offset_15, 10, T[57]);\n\t\t            c = II(c, d, a, b, M_offset_6,  15, T[58]);\n\t\t            b = II(b, c, d, a, M_offset_13, 21, T[59]);\n\t\t            a = II(a, b, c, d, M_offset_4,  6,  T[60]);\n\t\t            d = II(d, a, b, c, M_offset_11, 10, T[61]);\n\t\t            c = II(c, d, a, b, M_offset_2,  15, T[62]);\n\t\t            b = II(b, c, d, a, M_offset_9,  21, T[63]);\n\t\n\t\t            // Intermediate hash value\n\t\t            H[0] = (H[0] + a) | 0;\n\t\t            H[1] = (H[1] + b) | 0;\n\t\t            H[2] = (H[2] + c) | 0;\n\t\t            H[3] = (H[3] + d) | 0;\n\t\t        },\n\t\n\t\t        _doFinalize: function () {\n\t\t            // Shortcuts\n\t\t            var data = this._data;\n\t\t            var dataWords = data.words;\n\t\n\t\t            var nBitsTotal = this._nDataBytes * 8;\n\t\t            var nBitsLeft = data.sigBytes * 8;\n\t\n\t\t            // Add padding\n\t\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t\n\t\t            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\n\t\t            var nBitsTotalL = nBitsTotal;\n\t\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (\n\t\t                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |\n\t\t                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)\n\t\t            );\n\t\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n\t\t                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |\n\t\t                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)\n\t\t            );\n\t\n\t\t            data.sigBytes = (dataWords.length + 1) * 4;\n\t\n\t\t            // Hash final blocks\n\t\t            this._process();\n\t\n\t\t            // Shortcuts\n\t\t            var hash = this._hash;\n\t\t            var H = hash.words;\n\t\n\t\t            // Swap endian\n\t\t            for (var i = 0; i < 4; i++) {\n\t\t                // Shortcut\n\t\t                var H_i = H[i];\n\t\n\t\t                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |\n\t\t                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);\n\t\t            }\n\t\n\t\t            // Return final computed hash\n\t\t            return hash;\n\t\t        },\n\t\n\t\t        clone: function () {\n\t\t            var clone = Hasher.clone.call(this);\n\t\t            clone._hash = this._hash.clone();\n\t\n\t\t            return clone;\n\t\t        }\n\t\t    });\n\t\n\t\t    function FF(a, b, c, d, x, s, t) {\n\t\t        var n = a + ((b & c) | (~b & d)) + x + t;\n\t\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t\t    }\n\t\n\t\t    function GG(a, b, c, d, x, s, t) {\n\t\t        var n = a + ((b & d) | (c & ~d)) + x + t;\n\t\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t\t    }\n\t\n\t\t    function HH(a, b, c, d, x, s, t) {\n\t\t        var n = a + (b ^ c ^ d) + x + t;\n\t\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t\t    }\n\t\n\t\t    function II(a, b, c, d, x, s, t) {\n\t\t        var n = a + (c ^ (b | ~d)) + x + t;\n\t\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t\t    }\n\t\n\t\t    /**\n\t\t     * Shortcut function to the hasher's object interface.\n\t\t     *\n\t\t     * @param {WordArray|string} message The message to hash.\n\t\t     *\n\t\t     * @return {WordArray} The hash.\n\t\t     *\n\t\t     * @static\n\t\t     *\n\t\t     * @example\n\t\t     *\n\t\t     *     var hash = CryptoJS.MD5('message');\n\t\t     *     var hash = CryptoJS.MD5(wordArray);\n\t\t     */\n\t\t    C.MD5 = Hasher._createHelper(MD5);\n\t\n\t\t    /**\n\t\t     * Shortcut function to the HMAC's object interface.\n\t\t     *\n\t\t     * @param {WordArray|string} message The message to hash.\n\t\t     * @param {WordArray|string} key The secret key.\n\t\t     *\n\t\t     * @return {WordArray} The HMAC.\n\t\t     *\n\t\t     * @static\n\t\t     *\n\t\t     * @example\n\t\t     *\n\t\t     *     var hmac = CryptoJS.HmacMD5(message, key);\n\t\t     */\n\t\t    C.HmacMD5 = Hasher._createHmacHelper(MD5);\n\t\t}(Math));\n\t\n\t\n\t\treturn CryptoJS.MD5;\n\t\n\t}));\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t;(function (root, factory) {\n\t\tif (true) {\n\t\t\t// CommonJS\n\t\t\tmodule.exports = exports = factory(__webpack_require__(4));\n\t\t}\n\t\telse if (typeof define === \"function\" && define.amd) {\n\t\t\t// AMD\n\t\t\tdefine([\"./core\"], factory);\n\t\t}\n\t\telse {\n\t\t\t// Global (browser)\n\t\t\tfactory(root.CryptoJS);\n\t\t}\n\t}(this, function (CryptoJS) {\n\t\n\t\t(function (Math) {\n\t\t    // Shortcuts\n\t\t    var C = CryptoJS;\n\t\t    var C_lib = C.lib;\n\t\t    var WordArray = C_lib.WordArray;\n\t\t    var Hasher = C_lib.Hasher;\n\t\t    var C_algo = C.algo;\n\t\n\t\t    // Initialization and round constants tables\n\t\t    var H = [];\n\t\t    var K = [];\n\t\n\t\t    // Compute constants\n\t\t    (function () {\n\t\t        function isPrime(n) {\n\t\t            var sqrtN = Math.sqrt(n);\n\t\t            for (var factor = 2; factor <= sqrtN; factor++) {\n\t\t                if (!(n % factor)) {\n\t\t                    return false;\n\t\t                }\n\t\t            }\n\t\n\t\t            return true;\n\t\t        }\n\t\n\t\t        function getFractionalBits(n) {\n\t\t            return ((n - (n | 0)) * 0x100000000) | 0;\n\t\t        }\n\t\n\t\t        var n = 2;\n\t\t        var nPrime = 0;\n\t\t        while (nPrime < 64) {\n\t\t            if (isPrime(n)) {\n\t\t                if (nPrime < 8) {\n\t\t                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n\t\t                }\n\t\t                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\t\n\t\t                nPrime++;\n\t\t            }\n\t\n\t\t            n++;\n\t\t        }\n\t\t    }());\n\t\n\t\t    // Reusable object\n\t\t    var W = [];\n\t\n\t\t    /**\n\t\t     * SHA-256 hash algorithm.\n\t\t     */\n\t\t    var SHA256 = C_algo.SHA256 = Hasher.extend({\n\t\t        _doReset: function () {\n\t\t            this._hash = new WordArray.init(H.slice(0));\n\t\t        },\n\t\n\t\t        _doProcessBlock: function (M, offset) {\n\t\t            // Shortcut\n\t\t            var H = this._hash.words;\n\t\n\t\t            // Working variables\n\t\t            var a = H[0];\n\t\t            var b = H[1];\n\t\t            var c = H[2];\n\t\t            var d = H[3];\n\t\t            var e = H[4];\n\t\t            var f = H[5];\n\t\t            var g = H[6];\n\t\t            var h = H[7];\n\t\n\t\t            // Computation\n\t\t            for (var i = 0; i < 64; i++) {\n\t\t                if (i < 16) {\n\t\t                    W[i] = M[offset + i] | 0;\n\t\t                } else {\n\t\t                    var gamma0x = W[i - 15];\n\t\t                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n\t\t                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n\t\t                                   (gamma0x >>> 3);\n\t\n\t\t                    var gamma1x = W[i - 2];\n\t\t                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n\t\t                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n\t\t                                   (gamma1x >>> 10);\n\t\n\t\t                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n\t\t                }\n\t\n\t\t                var ch  = (e & f) ^ (~e & g);\n\t\t                var maj = (a & b) ^ (a & c) ^ (b & c);\n\t\n\t\t                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n\t\t                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\t\n\t\t                var t1 = h + sigma1 + ch + K[i] + W[i];\n\t\t                var t2 = sigma0 + maj;\n\t\n\t\t                h = g;\n\t\t                g = f;\n\t\t                f = e;\n\t\t                e = (d + t1) | 0;\n\t\t                d = c;\n\t\t                c = b;\n\t\t                b = a;\n\t\t                a = (t1 + t2) | 0;\n\t\t            }\n\t\n\t\t            // Intermediate hash value\n\t\t            H[0] = (H[0] + a) | 0;\n\t\t            H[1] = (H[1] + b) | 0;\n\t\t            H[2] = (H[2] + c) | 0;\n\t\t            H[3] = (H[3] + d) | 0;\n\t\t            H[4] = (H[4] + e) | 0;\n\t\t            H[5] = (H[5] + f) | 0;\n\t\t            H[6] = (H[6] + g) | 0;\n\t\t            H[7] = (H[7] + h) | 0;\n\t\t        },\n\t\n\t\t        _doFinalize: function () {\n\t\t            // Shortcuts\n\t\t            var data = this._data;\n\t\t            var dataWords = data.words;\n\t\n\t\t            var nBitsTotal = this._nDataBytes * 8;\n\t\t            var nBitsLeft = data.sigBytes * 8;\n\t\n\t\t            // Add padding\n\t\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n\t\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n\t\t            data.sigBytes = dataWords.length * 4;\n\t\n\t\t            // Hash final blocks\n\t\t            this._process();\n\t\n\t\t            // Return final computed hash\n\t\t            return this._hash;\n\t\t        },\n\t\n\t\t        clone: function () {\n\t\t            var clone = Hasher.clone.call(this);\n\t\t            clone._hash = this._hash.clone();\n\t\n\t\t            return clone;\n\t\t        }\n\t\t    });\n\t\n\t\t    /**\n\t\t     * Shortcut function to the hasher's object interface.\n\t\t     *\n\t\t     * @param {WordArray|string} message The message to hash.\n\t\t     *\n\t\t     * @return {WordArray} The hash.\n\t\t     *\n\t\t     * @static\n\t\t     *\n\t\t     * @example\n\t\t     *\n\t\t     *     var hash = CryptoJS.SHA256('message');\n\t\t     *     var hash = CryptoJS.SHA256(wordArray);\n\t\t     */\n\t\t    C.SHA256 = Hasher._createHelper(SHA256);\n\t\n\t\t    /**\n\t\t     * Shortcut function to the HMAC's object interface.\n\t\t     *\n\t\t     * @param {WordArray|string} message The message to hash.\n\t\t     * @param {WordArray|string} key The secret key.\n\t\t     *\n\t\t     * @return {WordArray} The HMAC.\n\t\t     *\n\t\t     * @static\n\t\t     *\n\t\t     * @example\n\t\t     *\n\t\t     *     var hmac = CryptoJS.HmacSHA256(message, key);\n\t\t     */\n\t\t    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n\t\t}(Math));\n\t\n\t\n\t\treturn CryptoJS.SHA256;\n\t\n\t}));\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\r\n\t * Helper class for manipulation with data, stored locally in ({@link TubCachedData} format).\r\n\t *\r\n\t * This module shared between client & server. In case of server we use it together with {@link dataLoader},\r\n\t * in case of client - inside {@link UBConnection#select} to handle operations with entity data cached in IndexedDB.\r\n\t *\r\n\t * For server-side samples see ubm_forms.doSelect method implementation.\r\n\t *\r\n\t * Client-side sample:\r\n\t *\r\n\t *         $App.connection.run({\r\n\t                entity: 'tst_IDMapping',\r\n\t                method: 'addnew',\r\n\t                fieldList: ['ID', 'code']\r\n\t           }).done(function(result){\r\n\t                // here result in array-of-array format: [{\"entity\":\"tst_IDMapping\",\"method\":\"addnew\",\"fieldList\":[\"ID\",\"code\"],\"__fieldListExternal\":[\"ID\",\"code\"],\"resultData\":{\"fields\":[\"ID\",\"code\"],\"rowCount\": 1, \"data\":[[3500000016003,null]]}}]\r\n\t                var objArray = UB.LocalDataStore.selectResultToArrayOfObjects(result); // transform array-of-array result representation to array-of-object\r\n\t                console.log(objArray); // now result in more simple array-of-object format: [{ID: 12312312312, code: null}]\r\n\t           });\r\n\t\r\n\t * @module @unitybase/base/LocalDataStore\r\n\t */\n\t/*\r\n\t @author pavel.mash\r\n\t */\n\t\n\t// ***********   !!!!WARNING!!!!! **********************\n\t// Module shared between server and client code\n\t\n\tvar _ = __webpack_require__(3);\n\t/**\r\n\t * Format for UBQ select request\r\n\t * @typedef {Object} TubSelectRequest\r\n\t * @property {Array<String>} fieldList Array of entity attribute names\r\n\t * @property {Object} whereList Where clauses\r\n\t * @property {Object} orderList Order clauses\r\n\t * @property {Object} options Options\r\n\t * @property {Number} ID ID\r\n\t */\n\t\n\t/**\r\n\t * Format for data, stored in client-side cache\r\n\t * @typedef {Object} TubCachedData\r\n\t * @property {Array<Array>} data\r\n\t * @property {Array<String>} fields\r\n\t * @property {Number} rowCount\r\n\t */\n\t\n\t/**\r\n\t * Perform local filtration and sorting of data array according to ubRequest whereList & order list\r\n\t * @param {TubCachedData} cachedData Data, retrieved from cache\r\n\t * @param {TubSelectRequest} ubRequest Initial server request\r\n\t * @returns {*} new filtered & sorted array\r\n\t */\n\tmodule.exports.doFilterAndSort = function (cachedData, ubRequest) {\n\t  var rangeStart = void 0;\n\t\n\t  var filteredData = this.doFiltration(cachedData, ubRequest);\n\t  var totalLength = filteredData.length;\n\t  this.doSorting(filteredData, cachedData, ubRequest);\n\t  // apply options start & limit\n\t  if (ubRequest.options) {\n\t    rangeStart = ubRequest.options.start || 0;\n\t    if (ubRequest.options.limit) {\n\t      filteredData = filteredData.slice(rangeStart, rangeStart + ubRequest.options.limit);\n\t    } else {\n\t      filteredData = filteredData.slice(rangeStart);\n\t    }\n\t  }\n\t  return {\n\t    resultData: {\n\t      data: filteredData,\n\t      fields: cachedData.fields\n\t    },\n\t    total: totalLength\n\t  };\n\t};\n\t\n\t/**\r\n\t * Just a helper for search cached data by row ID\r\n\t * @param {TubCachedData} cachedData Data, retrieved from cache\r\n\t * @param {Number} IDValue row ID.\r\n\t */\n\tmodule.exports.byID = function (cachedData, IDValue) {\n\t  return this.doFilterAndSort(cachedData, { ID: IDValue });\n\t};\n\t\n\t/**\r\n\t * Apply ubRequest.whereList to data array and return new array contain filtered data\r\n\t * @protected\r\n\t * @param {TubCachedData} cachedData Data, retrieved from cache\r\n\t * @param {TubSelectRequest} ubRequest\r\n\t * @returns {Array.<Array>}\r\n\t */\n\tmodule.exports.doFiltration = function (cachedData, ubRequest) {\n\t  var f = void 0,\n\t      isAcceptable = void 0;\n\t  var rawDataArray = cachedData.data;\n\t  var byPrimaryKey = Boolean(ubRequest.ID);\n\t\n\t  var filterFabric = whereListToFunctions(ubRequest, cachedData.fields);\n\t  var filterCount = filterFabric.length;\n\t\n\t  if (filterCount === 0) {\n\t    return rawDataArray;\n\t  }\n\t\n\t  var result = [];\n\t  var l = rawDataArray.length;\n\t  var i = -1;\n\t  while (++i < l) {\n\t    // for each data\n\t    isAcceptable = true;f = -1;\n\t    while (++f < filterCount && isAcceptable === true) {\n\t      isAcceptable = filterFabric[f](rawDataArray[i]);\n\t    }\n\t    if (isAcceptable) {\n\t      result.push(rawDataArray[i]);\n\t      if (byPrimaryKey) {\n\t        return result;\n\t      }\n\t    }\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\r\n\t * Apply ubRequest.orderList to inputArray (inputArray is modified)\r\n\t * @protected\r\n\t * @param {Array.<Array>} filteredArray\r\n\t * @param {TubCachedData} cachedData\r\n\t * @param {Object} ubRequest\r\n\t */\n\tmodule.exports.doSorting = function (filteredArray, cachedData, ubRequest) {\n\t  var preparedOrder = [];\n\t  if (ubRequest.orderList) {\n\t    (function () {\n\t      _.each(ubRequest.orderList, function (orderItem) {\n\t        var attrIdx = cachedData.fields.indexOf(orderItem.expression);\n\t        if (attrIdx < 0) {\n\t          throw new Error('Ordering by ' + orderItem.expression + ' attribute that don\\'t present in fieldList not allowed');\n\t        }\n\t        preparedOrder.push({\n\t          idx: attrIdx,\n\t          modifier: orderItem.order === 'desc' ? -1 : 1\n\t        });\n\t      });\n\t      var orderLen = preparedOrder.length;\n\t      if (orderLen) {\n\t        var compareFn = function compareFn(v1, v2) {\n\t          var res = 0;\n\t          var idx = -1;\n\t          while (++idx < orderLen && res === 0) {\n\t            var colNum = preparedOrder[idx].idx;\n\t            if (v1[colNum] !== v2[colNum]) {\n\t              if (v1[colNum] === null && v2[colNum] !== null) {\n\t                res = 1;\n\t              } else if (v2[colNum] === null && v1[colNum] !== null) {\n\t                res = -1;\n\t              } else if (v2[colNum] === null && v1[colNum] === null) {\n\t                res = 0;\n\t              } else if (v1[colNum] > v2[colNum]) {\n\t                res = 1;\n\t              } else {\n\t                res = -1;\n\t              }\n\t              res = res * preparedOrder[idx].modifier;\n\t            }\n\t          }\n\t          return res;\n\t        };\n\t        filteredArray.sort(compareFn);\n\t      }\n\t    })();\n\t  }\n\t};\n\t\n\t/**\r\n\t * Transform whereList to array of function\r\n\t * @private\r\n\t * @param {TubSelectRequest} request\r\n\t * @param {Array.<String>} fieldList\r\n\t * @returns {Array}\r\n\t */\n\tfunction whereListToFunctions(request, fieldList) {\n\t  var propIdx = void 0,\n\t      fValue = void 0,\n\t      filterFabricFn = void 0;\n\t  var filters = [];\n\t  var escapeForRegexp = function escapeForRegexp(text) {\n\t    // TODO - do we need this?\n\t    return text && typeof text === 'string' ? text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&') : '';\n\t  };\n\t  var whereList = request.whereList;\n\t\n\t  filterFabricFn = function filterFabricFn(propertyIdx, condition, value) {\n\t    var regExpFilter = void 0;\n\t\n\t    switch (condition) {\n\t      case 'like':\n\t        regExpFilter = new RegExp(escapeForRegexp(value), 'i');\n\t        return function (record) {\n\t          var val = record[propertyIdx];\n\t          return val && regExpFilter.test(val);\n\t        };\n\t      case 'equal':\n\t        return function (record) {\n\t          return record[propertyIdx] === value;\n\t        };\n\t      case 'notEqual':\n\t        return function (record) {\n\t          return record[propertyIdx] !== value;\n\t        };\n\t      case 'more':\n\t        return function (record) {\n\t          return record[propertyIdx] > value;\n\t        };\n\t      case 'moreEqual':\n\t        return function (record) {\n\t          return record[propertyIdx] >= value;\n\t        };\n\t      case 'less':\n\t        return function (record) {\n\t          return record[propertyIdx] < value;\n\t        };\n\t      case 'lessEqual':\n\t        return function (record) {\n\t          return record[propertyIdx] <= value;\n\t        };\n\t      case 'isNull':\n\t        return function (record) {\n\t          return record[propertyIdx] === null;\n\t        };\n\t      case 'notIsNull':\n\t        return function (record) {\n\t          return record[propertyIdx] !== null;\n\t        };\n\t      case 'notLike':\n\t        regExpFilter = new RegExp(escapeForRegexp(value), 'i');\n\t        return function (record) {\n\t          var val = record[propertyIdx];\n\t          return val && !regExpFilter.test(val);\n\t        };\n\t      case 'startWith':\n\t        return function (record) {\n\t          var str = record[propertyIdx];\n\t          return str && str.indexOf(value) === 0;\n\t        };\n\t      case 'notStartWith':\n\t        return function (record) {\n\t          var str = record[propertyIdx];\n\t          return str && str.indexOf(value) !== 0;\n\t        };\n\t      case 'in':\n\t        return function (record) {\n\t          var str = record[propertyIdx];\n\t          return str && value.indexOf(str) >= 0;\n\t        };\n\t      case 'notIn':\n\t        return function (record) {\n\t          var str = record[propertyIdx];\n\t          return str && value.indexOf(str) < 0;\n\t        };\n\t      default:\n\t        throw new Error('Unknown whereList condition');\n\t    }\n\t  };\n\t\n\t  function transformClause(clause) {\n\t    var property = clause.expression || '';\n\t\n\t    if (clause.condition === 'custom') {\n\t      throw new Error('Condition \"custom\" is not supported for cached instances.');\n\t    }\n\t    property = (property.replace(/(\\[)|(])/ig, '') || '').trim();\n\t    propIdx = fieldList.indexOf(property);\n\t    if (propIdx === -1) {\n\t      throw new Error('Filtering by field ' + property + ' is not allowed, because it is not pressing in fieldList');\n\t    }\n\t\n\t    fValue = _.values(clause.values)[0];\n\t    filters.push(filterFabricFn(propIdx, clause.condition, fValue));\n\t  }\n\t  // check for top level ID  - in this case add condition for filter by ID\n\t  if (request.ID) {\n\t    transformClause({ expression: '[ID]', condition: 'equal', values: { ID: request.ID } });\n\t  }\n\t  _.forEach(whereList, transformClause);\n\t  return filters;\n\t}\n\t\n\t/**\r\n\t * Transform result of {@link UBConnection#select} response\r\n\t * from Array of Array representation to Array of Object.\r\n\t *\r\n\t *      LocalDataStore.selectResultToArrayOfObjects({resultData: {\r\n\t *          data: [['row1_attr1Val', 1], ['row2_attr2Val', 22]],\r\n\t *          fields: ['attrID.name', 'attr2']}\r\n\t *      });\r\n\t *      // result is:\r\n\t *      // [{\"attrID.name\": \"row1_attr1Val\", attr2: 1},\r\n\t *      //  {\"attrID.name\": \"row2_attr2Val\", attr2: 22}\r\n\t *      // ]\r\n\t *\r\n\t *      // object keys simplify by passing fieldAliases\r\n\t *      LocalDataStore.selectResultToArrayOfObjects({resultData: {\r\n\t *          data: [['row1_attr1Val', 1], ['row2_attr2Val', 22]],\r\n\t *          fields: ['attrID.name', 'attr2']}\r\n\t *      }, {'attrID.name': 'attr1Name'});\r\n\t *      // result is:\r\n\t *      // [{attr1Name: \"row1_attr1Val\", attr2: 1},\r\n\t *      //  {attr1Name: \"row2_attr2Val\", attr2: 22}\r\n\t *      // ]\r\n\t *\r\n\t * @param {{resultData: TubCachedData}} selectResult\r\n\t * @param {Object<string, string>} [fieldAlias] Optional object to change attribute names during transform array to object. Keys are original names, values - new names\r\n\t * @returns {Array.<*>}\r\n\t */\n\tmodule.exports.selectResultToArrayOfObjects = function (selectResult, fieldAlias) {\n\t  var inData = selectResult.resultData.data;\n\t  var inAttributes = selectResult.resultData.fields;\n\t  var inDataLength = inData.length;\n\t  var result = inDataLength ? new Array(inDataLength) : [];\n\t  if (fieldAlias) {\n\t    _.forEach(fieldAlias, function (alias, field) {\n\t      var idx = inAttributes.indexOf(field);\n\t      if (idx >= 0) {\n\t        inAttributes[idx] = alias;\n\t      }\n\t    });\n\t  }\n\t  for (var i = 0; i < inDataLength; i++) {\n\t    result[i] = _.zipObject(inAttributes, inData[i]);\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\r\n\t * Flatten cached data (or result of {@link LocalDataStore#doFilterAndSort}.resultData )\r\n\t * to Object expected by TubDataStore.initialize Flatten format (faster than [{}..] format).\r\n\t *\r\n\t        //consider we have cached data in variable filteredData.resultData\r\n\t        // to initialize dataStore with cached data:\r\n\t        mySelectMethod = function(ctxt){\r\n\t            var fieldList = ctxt.mParams.fieldList;\r\n\t            resp = LocalDataStore.flatten(fieldList, filteredData.resultData);\r\n\t            ctxt.dataStore.initFromJSON(resp);\r\n\t        }\r\n\t *\r\n\t * cachedData may contain more field or field in order not in requestedFieldList - in this case we use expectedFieldList\r\n\t * @param {Array.<string>} requestedFieldList Array of attributes to transform to. Can be ['*'] - in this case we return all cached attributes\r\n\t * @param {TubCachedData} cachedData\r\n\t * @result {{fieldCount: number, rowCount: number, values: array.<*>}}\r\n\t */\n\tmodule.exports.flatten = function (requestedFieldList, cachedData) {\n\t  var fldIdxArr = [];\n\t  var cachedFields = cachedData.fields;\n\t  var rowIdx = -1;\n\t  var col = -1;\n\t  var pos = 0;\n\t  var resultData = [];\n\t  var rowCount = cachedData.data.length;\n\t  var idx = void 0,\n\t      row = void 0,\n\t      fieldCount = void 0;\n\t\n\t  if (!requestedFieldList || !requestedFieldList.length) {\n\t    throw new Error('fieldList not exist or empty');\n\t  }\n\t\n\t  // client ask for all attributes\n\t  if (requestedFieldList.length === 1 && requestedFieldList[0] === '*') {\n\t    requestedFieldList = cachedData.fields;\n\t  }\n\t\n\t  requestedFieldList.forEach(function (field) {\n\t    idx = cachedFields.indexOf(field);\n\t    if (idx !== -1) {\n\t      fldIdxArr.push(idx);\n\t    } else {\n\t      throw new Error('Invalid field list. Attribute ' + field + ' not found in local data store');\n\t    }\n\t  });\n\t  fieldCount = requestedFieldList.length;\n\t  resultData.length = rowCount * (fieldCount + 1); // reserve fieldCount for field names\n\t  while (++col < fieldCount) {\n\t    resultData[pos] = requestedFieldList[pos];pos++;\n\t  }\n\t  while (++rowIdx < rowCount) {\n\t    col = -1;row = cachedData.data[rowIdx];\n\t    while (++col < fieldCount) {\n\t      resultData[pos++] = row[fldIdxArr[col]];\n\t    }\n\t  }\n\t  return { fieldCount: fieldCount, rowCount: rowCount, values: resultData };\n\t};\n\t\n\t/**\r\n\t * Reverse conversion to {@link LocalDataStore#selectResultToArrayOfObjects}\r\n\t * Transform array of object to array of array using passed attributes array\r\n\t *\r\n\t *      LocalDataStore.arrayOfObjectsToSelectResult([{a: 1, b: 'as'}, {b: 'other', a: 12}], ['a', 'b']);\r\n\t *      // result is: [[1,\"as\"],[12,\"other\"]]\r\n\t *\r\n\t * @param {Array.<Object>} arrayOfObject\r\n\t * @param {Array.<String>} attributeNames\r\n\t * @returns {Array.<Array>}\r\n\t */\n\tmodule.exports.arrayOfObjectsToSelectResult = function (arrayOfObject, attributeNames) {\n\t  var result = [];\n\t  arrayOfObject.forEach(function (obj) {\n\t    var row = [];\n\t    attributeNames.forEach(function (attribute) {\n\t      row.push(obj[attribute]);\n\t    });\n\t    result.push(row);\n\t  });\n\t  return result;\n\t};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar LocalDataStore = __webpack_require__(9);\n\tvar CustomRepository = __webpack_require__(14);\n\t\n\t/**\r\n\t * Repository for client-side data retrieve.\r\n\t * Implement:\r\n\t *\r\n\t *  - {@link ClientRepository#select} method able to return `array of object` representation of server entity\r\n\t *  - {@link ClientRepository#selectAsArray} method able to return `array of object` representation of server entity\r\n\t *  - {@link ClientRepository#selectAsStore} method able to return {UB.ux.data.UBStore} (applicable only for Ext-based client types)\r\n\t *\r\n\t * Usually created using {@link UB#Repository UB.Repository} fabric function. Example:\r\n\t *\r\n\t *      var store = UB.Repository('my_entity').attrs(['ID', 'code'])\r\n\t *       .where('code', 'includes', ['1', '2', '3'])  // code in ('1', '2', '3')\r\n\t *       .where('name', 'contains', 'Homer'). // name like '%homer%'\r\n\t *       .where('birtday', 'geq', new Date()).where('birtday', 'leq', new Date() + 10) //(birtday >= '2012-01-01') AND (birtday <= '2012-01-02')\r\n\t *       .where('[age] -10', '>=', {age: 15}, 'byAge') // (age + 10 >= 15)\r\n\t *       .where('', 'match', 'myvalue'). // for condition match expression not need\r\n\t *       .logic('(byStrfType OR bySrfKindID)AND(dasdsa)')\r\n\t *       .select().then(function(response){\r\n\t *          // here response is in [{ID: 10, code: 'value1'}, .... {}] format\r\n\t *       });;\r\n\t *\r\n\t *\r\n\t * @class ClientRepository\r\n\t * @extends CustomRepository\r\n\t * @author pavel.mash 23.09.2014\r\n\t */\n\t\n\t/**\r\n\t * Create a new CustomRepository\r\n\t * @constructor\r\n\t * @param {UBConnection} connection\r\n\t * @param {String} entityName name of Entity we create for\r\n\t */\n\tfunction ClientRepository(connection, entityName) {\n\t  // noinspection JSUnresolvedFunction\n\t  CustomRepository.call(this, entityName);\n\t  this.connection = connection;\n\t}\n\tClientRepository.prototype = Object.create(CustomRepository.prototype);\n\tClientRepository.prototype.constructor = ClientRepository;\n\t\n\t/**\r\n\t * Asynchronously run request, constructed by Repository. Return promise, resolved to `array of object` representation of response.\r\n\t *\r\n\t *      UB.Repository('ubm_navshortcut').attrs(['ID', 'code'])\r\n\t *      .where('code', 'in', ['uba_user', 'uba_auditTrail'])\r\n\t *      .selectAsObj().then(function(store){\r\n\t *          console.log(store); // output is [{\"ID\":3000000000004,\"code\":\"uba_user\"},{\"ID\":3000000000039,\"code\":\"ubs_audit\"}]\r\n\t *      });\r\n\t *\r\n\t *  Optionally can rename attributes in the resulting object:\r\n\t *\r\n\t *      UB.Repository('investment')\r\n\t *      .attrs(['ID', 'product', 'product.name', 'product.provider.name'])\r\n\t *      .selectAsObject({\r\n\t            'product.name': 'productName',\r\n\t            'product.provider.name': 'productProviderName'\r\n\t        }).then(function(result){\r\n\t            console.log(result); // output [{\"ID\": 1, \"productName\": \"My product\", \"productProviderName\": \"My provider\"}, ...]\r\n\t        });\r\n\t *\r\n\t * @param {Object<string, string>} [fieldAliases] Optional object to change attribute names during transform array to object\r\n\t * @return {Promise}\r\n\t */\n\tClientRepository.prototype.selectAsObject = function (fieldAliases) {\n\t  return this.connection.select(this.ubql()).then(function (res) {\n\t    return LocalDataStore.selectResultToArrayOfObjects(res, fieldAliases);\n\t  });\n\t};\n\t\n\t/**\r\n\t * Asynchronously run request, constructed by Repository. Return promise, resolved to `array of array` representation of response.\r\n\t * Actual data is placed to `resultData` response property.\r\n\t *\r\n\t *      UB.Repository('ubm_navshortcut').attrs(['ID', 'code'])\r\n\t *      .where('code', 'in', ['uba_user', 'ubs_audit'])\r\n\t *      .select().then(UB.logDebug);\r\n\t *      // output is {\"resultData\":{\"data\":[[3000000000004,\"uba_user\"],[3000000000039,\"ubs_audit\"]],\"fields\":[\"ID\",\"code\"]},\"total\":2}\r\n\t *\r\n\t * Response MAY (but may not even for the same request) contain other variables, returned by server in case data retrieved not from cache\r\n\t *\r\n\t *      UB.Repository('uba_user').attrs(['ID', 'name', 'ID.name']) // since uba_user have `unity` mixin it ID property point us to parent (`uba_subject` in this case)\r\n\t *      .selectAsArray().then(UB.logDebug);\r\n\t *      // {\"entity\":\"uba_user\",\"fieldList\":[\"ID\",\"name\",\"ID.name\"],\"method\":\"select\",\"resultData\":{\"fields\":[\"ID\",\"name\",\"ID.name\"],\"rowCount\":1,\"data\":[[10,\"admin\",\"admin\"]]},\"total\":1}\r\n\t *\r\n\t * But resultData is always present\r\n\t *\r\n\t * @return {Promise}\r\n\t */\n\tClientRepository.prototype.selectAsArray = function () {\n\t  return this.connection.select(this.ubql());\n\t};\n\t\n\t/**\r\n\t * For core module (without Ext) - do the same as {ClientRepository.selectAsObj}\r\n\t *\r\n\t * For EntJS based client (actual implementation in {UB.ux.data.UBStore}) - create store based on request, constructed by Repository.\r\n\t * Return promise resolved to loaded {UB.ux.data.UBStore} instance.\r\n\t *\r\n\t *      UB.Repository('ubm_navshortcut').attrs(['ID', 'code']).where('code', 'in', ['uba_user', 'ubs_audit'])\r\n\t *      .selectAsStore().then(function(store){\r\n\t *          console.log(store.getTotalCount()); // here store is UB.ux.data.UBStore instance\r\n\t *      });\r\n\t *\r\n\t * @param {Object} [storeConfig] optional config passed to store constructor\r\n\t * @return {Promise}\r\n\t */\n\tClientRepository.prototype.selectAsStore = ClientRepository.prototype.selectAsObject;\n\t\n\t/**\r\n\t * Alias to {ClientRepository.selectAsObject}\r\n\t */\n\tClientRepository.prototype.select = ClientRepository.prototype.selectAsObject;\n\t\n\t/**\r\n\t * Select a single row. If ubql result is empty - return {undefined}.\r\n\t *\r\n\t * WARNING method do not check repository contains the single row and always return a first row from result.\r\n\t * @param {{field: alias}} [fieldAliases] Optional object to change attribute names during transform array to object\r\n\t * @return {Promise} Promise, resolved to {Object|undefined}\r\n\t */\n\tClientRepository.prototype.selectSingle = function (fieldAliases) {\n\t  return this.selectAsObject(fieldAliases).then(function (row) {\n\t    return row[0];\n\t  });\n\t};\n\t\n\t/**\r\n\t * Perform select and return a value of the first attribute from the first row\r\n\t *\r\n\t * WARNING method do not check repository contains the single row\r\n\t * @return {Promise} Promise, resolved to {Object|undefined}\r\n\t */\n\tClientRepository.prototype.selectScalar = function () {\n\t  return this.selectAsArray().then(function (result) {\n\t    return result.resultData.rowCount > 0 ? result.resultData.data[0][0] : undefined;\n\t  });\n\t};\n\t\n\t/**\r\n\t * Select a single row by ID. If ubql result is empty - return {undefined}.\r\n\t *\r\n\t * @param {Number} ID Row identifier\r\n\t * @param {{field: alias}} [fieldAliases] Optional object to change attribute names during transform result to object\r\n\t * @return {Promise} Promise, resolved to {Object|undefined}\r\n\t */\n\tClientRepository.prototype.selectById = function (ID, fieldAliases) {\n\t  return this.where('[ID]', '=', ID).selectSingle();\n\t};\n\t\n\tmodule.exports = ClientRepository;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/*\r\n\t @author xmax, mpv\r\n\t */\n\t\n\tvar ubUtils = __webpack_require__(1);\n\tvar i18n = __webpack_require__(6).i18n;\n\tvar EventEmitter = __webpack_require__(5);\n\t/**\r\n\t * Registered features.\r\n\t * @type {Object}\r\n\t */\n\tUBNativeMessage.features = {\n\t  extension: {\n\t    host: 'none', UIName: 'NMUBExtension', minVersion: '1.0.0', installer: 'pgffhmifenmomiabibdpnceahangimdi' // downloads/UBBrowserNativeMessagesHostApp.exe\n\t  },\n\t  dstu: {\n\t    host: 'com.inbase.dstu', UIName: 'NMFeatureDSTU', minVersion: '1.0.0.5', installer: 'models/DSTU/ub-extension/UBHostDSTUIITSetup{0}.exe', libraryName: 'UBHostDSTU.dll'\n\t  },\n\t  iit: {\n\t    host: 'com.inbase.iit', UIName: 'NMFeatureIIT', minVersion: '1.0.0.5', installer: 'models/DSTU/ub-extension/UBHostDSTUIITSetup{0}.exe', libraryName: 'UBHostIIT.dll'\n\t  },\n\t  pdfsigner: {\n\t    host: 'com.inbase.pdfsigner', UIName: 'NMFeaturePDFSigner', minVersion: '1.0.0.3', installer: 'models/PDF/ub-extension/UBHostPdfSignSetup{0}.' + (ubUtils.isMac ? 'pkg' : 'exe'), libraryName: 'SET _LIB_NAME_IN_UBNATIVENMESSAGES.dll'\n\t  },\n\t  scanner: {\n\t    host: 'com.inbase.scanner', UIName: 'NMFeatureScanner', minVersion: '1.0.0.4', installer: 'models/PDF/ub-extension/UBHostScannerSetup{0}.exe', libraryName: 'UBHostScanner.dll'\n\t  },\n\t  docedit: {\n\t    host: 'com.inbase.docedit', UIName: 'NMFeatureDocEdit', minVersion: '1.0.0.1', installer: 'models/UB/ub-extension/UBHostDocEditSetup{0}.exe', libraryName: 'UBHostDocEdit.dll'\n\t  }\n\t};\n\t\n\tUBNativeMessage.features.iit.minVersion = UBNativeMessage.features.dstu.minVersion;\n\t\n\t/**\r\n\t * @classdesc\r\n\t * Class for communicate with native messages plugin `content script`.\r\n\t * DOM element with `id=\"ubExtensionPageMessageObj\"` must be present on the target page.\r\n\t *\r\n\t * If target page is loaded into iframe then parent (iframe owner) page must contains a DOM element with `id=\"ubExtensionPageMessageObj\"`.\r\n\t *\r\n\t * The preferred way to communicate with native messages plugin feature is a  UBNativeMessage descendants, for example {@link UBNativeScanner} for scanning etc.\r\n\t *\r\n\t * Usage:\r\n\t *\r\n\t *      var nm = new UBNativeMessage('scanner');\r\n\t *      nm.connect().then(UB.logDebug);\r\n\t *      nm.connect.then(function(nm){\r\n\t *          UB.logDebug('connected to feature version', nm.featureVersion);\r\n\t *          return nm.invoke('methodName', {a: 10, b: 20})\r\n\t *      }).then(UB.logDebug).then(nm.disconnect.bind(nm));\r\n\t *\r\n\t *\r\n\t *      var nm = new UBNativeMessage();\r\n\t *      nm.onMessage = function(message){\r\n\t *         console.log(message);\r\n\t *      };\r\n\t *      nm.onDisconnected = function(sender){\r\n\t *         console.log('disconnected');\r\n\t *      };\r\n\t *      nm.connect(5000).then( function(nm){\r\n\t *          nm.sendMessage({text: 'Message : Hello!'});\r\n\t *      });\r\n\t *\r\n\t * @constructor\r\n\t * @param {String} [feature] Feature we want from plugin. Feature<->application decoding is accessible via {@link UBNativeMessage#features} object\r\n\t */\n\tfunction UBNativeMessage(feature) {\n\t  var me = this,\n\t      __messageCounter = 0;\n\t\n\t  me.getMessageId = function () {\n\t    return 'm' + ++__messageCounter;\n\t  };\n\t\n\t  ++UBNativeMessage.prototype.idCounter;\n\t  me.id = 'UBPlugin' + UBNativeMessage.prototype.idCounter;\n\t\n\t  me.pendingMessages = {};\n\t  /**\r\n\t   * @readonly\r\n\t   * @property {String} Feature native messages registered for\r\n\t   */\n\t  me.feature = feature || 'extension';\n\t  /**\r\n\t   * Name of plugin interface in host application.\r\n\t   * @type {string}\r\n\t   */\n\t  me.pluginName = feature;\n\t  me.hostAppName = UBNativeMessage.features[feature].host;\n\t  if (!me.hostAppName) {\n\t    throw new Error('unknown feature ' + feature + ' for UBNativeMessage');\n\t  }\n\t\n\t  /**\r\n\t   * Feature version. Defined after success connect() call.\r\n\t   * @property {string} featureVersion\r\n\t   */\n\t  me.featureVersion = '';\n\t  /**\r\n\t   * Default operation timeout\r\n\t   * @property {number} callTimeOut\r\n\t   */\n\t  me.callTimeOut = 30000;\n\t  if (ubUtils.isSecureBrowser) {\n\t    me.eventElm = {};\n\t    EventEmitter.call(me.eventElm);\n\t    _.assign(me.eventElm, EventEmitter.prototype);\n\t    me.eventElm.addEventListener = me.eventElm.addListener;\n\t  } else {\n\t    me.eventElm = document.getElementById('ubExtensionPageMessageObj');\n\t\n\t    if (!me.eventElm && (!window.parent || window.parent === window)) {\n\t      throw new Error('Message exchange element with id=\"ubExtensionPageMessageObj\" not found');\n\t    }\n\t  }\n\t\n\t  // must be defined inside constructor for removeEventListener work properly\n\t  me.onContentMessage = function (event) {\n\t    var msg, pending, messageID, msgType, totalParts, currentPart, data;\n\t    msg = event.detail;\n\t    if (!msg || !msg.hasOwnProperty('msgType') || !msg.hasOwnProperty('messageID') || !msg.hasOwnProperty('clientID')) {\n\t      console.error('Empty or invalid content message');\n\t    }\n\t    if (msg.clientID !== me.id) {\n\t      // this is message to another UBNativeMessage instance\n\t      return;\n\t    }\n\t\n\t    messageID = msg['messageID'];\n\t    msgType = msg['msgType'];\n\t    data = msg['data'];\n\t    pending = me.pendingMessages[messageID];\n\t    if (pending) {\n\t      clearTimeout(pending.timerID);\n\t    }\n\t    if (msgType === 'disconnected') {\n\t      if (pending) {\n\t        // disconnect is sended from this\n\t        delete me.pendingMessages[messageID];\n\t        pending.deffer.resolve(data);\n\t      }\n\t      me.doOnDisconnect(data);\n\t    } else {\n\t      if (msgType === 'notify') {\n\t        if (!pending && me.onMessage) {\n\t          // notification from plugin without messageID\n\t          me.onMessage.call(me, data);\n\t        } else {\n\t          // notification to request. Increase timeout\n\t          pending.timerID = setTimeout(function () {\n\t            me.onMsgTimeOut(messageID);\n\t          }, pending.timeoutValue);\n\t          pending.deffer.notify(data);\n\t        }\n\t      } else if (!pending) {\n\t        console.error('UBNativeMessage. unknown messageID:' + messageID);\n\t      } else if (msgType === 'resolve') {\n\t        if (msg.hasOwnProperty('part') && msg.hasOwnProperty('totalParts')) {\n\t          // partial response\n\t          totalParts = msg['totalParts'];currentPart = msg['part'];\n\t          if (!pending.partials) {\n\t            if (totalParts > 100) {\n\t              // 100 Mb limit\n\t              pending.deffer.reject(new ubUtils.UBError('unknownError', 'UBNativeMessage. Result exceed 100Mb limit'));\n\t              delete me.pendingMessages[messageID];\n\t              throw new Error(new ubUtils.UBError('unknownError', 'UBNativeMessage. Result exceed 100Mb limit'));\n\t            }\n\t            pending.partials = new Array(totalParts);\n\t          } else {\n\t            if (totalParts !== pending.partials.length || currentPart >= totalParts) {\n\t              pending.deffer.reject('Invalid part count');\n\t              delete me.pendingMessages[messageID];\n\t              throw new Error('Invalid part count');\n\t            }\n\t          }\n\t          pending.partials[currentPart] = data;\n\t          if (_.indexOf(pending.partials, undefined) === -1) {\n\t            // all parts come - ready to resolve. lodash using is important here - Array.indexOf not wok with `undefined`\n\t            data = pending.partials.join('');\n\t            delete me.pendingMessages[messageID];\n\t            if (data.charAt(0) === '{' || data.charAt(0) === '[') {\n\t              // data is JSON\n\t              data = JSON.parse(data);\n\t            }\n\t            pending.deffer.resolve(data);\n\t          } else {\n\t            pending.timerID = setTimeout(function () {\n\t              me.onMsgTimeOut(messageID);\n\t            }, pending.timeoutValue);\n\t          }\n\t        } else {\n\t          delete me.pendingMessages[messageID];\n\t          pending.deffer.resolve(data);\n\t        }\n\t      } else if (msgType === 'reject') {\n\t        delete me.pendingMessages[messageID];\n\t        var isUserMessage = false,\n\t            err;\n\t        if (/<<<.*>>>/.test(data)) {\n\t          data = data.match(/<<<(.*)>>>/)[1];\n\t          isUserMessage = true;\n\t        }\n\t        if (isUserMessage) {\n\t          err = new ubUtils.UBError(data);\n\t        } else {\n\t          err = new ubUtils.UBError('unknownError', data);\n\t        }\n\t        //                pending.deffer.reject(new Error(data));\n\t        pending.deffer.reject(err);\n\t      } else {\n\t        throw new Error('UBNativeMessage. Invalid msgType type in: ' + msg);\n\t      }\n\t    }\n\t  };\n\t  me.eventElm.addEventListener('UBExtensionMsg', me.onContentMessage);\n\t  /**\r\n\t   * Called when disconnecting the plugin.\r\n\t   * @property {Function} onDisconnected\r\n\t   */\n\t  me.onDisconnected = null;\n\t  /**\r\n\t   * Called when receive new `notify` message from host application not to invoked method.\r\n\t   * @property {Function} onMessage\r\n\t   */\n\t  me.onMessage = null;\n\t}\n\t\n\tUBNativeMessage.versionToNumber = function (versionStr) {\n\t  var arr = versionStr.split('.'),\n\t      mutliplier = 1,\n\t      i,\n\t      l = arr.length,\n\t      res = 0;\n\t  if (arr.length > 4) {\n\t    throw new Error('Invalid version number ' + versionStr);\n\t  }\n\t  for (i = l - 1; i >= 0; i--) {\n\t    res += parseInt(arr[i], 10) * mutliplier;mutliplier *= i === l - 1 ? 10000 : 1000; // last number may be 4 digit 1.2.3.1234\n\t  }\n\t  return res;\n\t};\n\t\n\t/**\r\n\t * Invoke feature method with optional params\r\n\t * @param {String} methodName\r\n\t * @param {Object} [methodParams] Do not pass empty object {} here!\r\n\t * @param {Number} [timeout] operation timeout. Default to {@link UBNativeMessage#callTimeOut}\r\n\t * @return {Promise}\r\n\t */\n\tUBNativeMessage.prototype.invoke = function (methodName, methodParams, timeout) {\n\t  var me = this,\n\t      msgID = me.getMessageId(),\n\t      messageToSend;\n\t\n\t  if (!me.connected && methodName.substr(0, 2) !== '__') {\n\t    // allow pseudo methods\n\t    return Promise.reject(new ubUtils.UBError('unknownError', 'UBNativeMessage. Not connected. call connect() first'));\n\t  }\n\t\n\t  // methodParams = methodParams || null;\n\t  timeout = timeout || me.callTimeOut;\n\t\n\t  messageToSend = { clientID: me.id, messageID: msgID, method: methodName, params: methodParams };\n\t  return new Promise(function (resolve, reject) {\n\t    var pendingRequest = {\n\t      request: null, // MPV - do not store - we do not need it!  messageToSend,\n\t      deffer: { resolve: resolve, reject: reject },\n\t      timerID: setTimeout(function () {\n\t        me.onMsgTimeOut(msgID);\n\t      }, timeout),\n\t      partials: null,\n\t      timeoutValue: timeout || me.callTimeOut,\n\t      stTime: new Date().getTime()\n\t    };\n\t    me.pendingMessages[msgID] = pendingRequest;\n\t    // if (UB.isSecureBrowser) {\n\t    //     if (methodName === '__extensionVersion') {\n\t    //         me.eventElm.emit('UBExtensionMsg', {\n\t    //             detail: {\n\t    //                 clientID: me.id,\n\t    //                 messageID: msgID,\n\t    //                 msgType: 'resolve',\n\t    //                 data: UBNativeMessage.features.extension.minVersion\n\t    //             }\n\t    //         });\n\t    //     } else if (methodName === '__connect') {\n\t    //         var path = require('path'),\n\t    //             ffi =require(path.join(path.parse(process.execPath).dir, '..', 'ffi')),\n\t    //             Library = ffi.Library;\n\t    //\n\t    //         me.doInvoke = new Library(\n\t    //             path.join(path.parse(process.execPath).dir, UBNativeMessage.features[me.feature].libraryName),\n\t    //             {'invoke': ['void', ['string', 'pointer'], { async: true }]}\n\t    //         ).invoke;\n\t    //         me.funcPtr = ffi.Callback('void', [ 'string' ],\n\t    //             function(param) {\n\t    //                 var detail = JSON.parse(param);\n\t    //                 me.eventElm.emit('UBExtensionMsg', {\n\t    //                     detail: detail\n\t    //                 });\n\t    //             }\n\t    //         );\n\t    //         messageToSend.method = 'getVersion';\n\t    //         me.doInvoke(JSON.stringify(messageToSend), me.funcPtr, function(){});\n\t    //     } else {\n\t    //         me.doInvoke(JSON.stringify(messageToSend), me.funcPtr, function(){});\n\t    //     }\n\t    // } else\n\t    if (me.iFarmeMode) {\n\t      window.parent.postMessage({ detail: messageToSend, messageType: 'UBPageMsg' }, '*');\n\t    } else {\n\t      me.eventElm.dispatchEvent(new CustomEvent('UBPageMsg', { detail: messageToSend }));\n\t    }\n\t  });\n\t};\n\t\n\t/**\r\n\t * Return true if browser extension was installed\r\n\t * @returns {boolean}\r\n\t */\n\tUBNativeMessage.extensionExists = function () {\n\t  if (ubUtils.isSecureBrowser) return true;\n\t\n\t  var e;\n\t  e = document.getElementById('ubExtensionPageMessageObj');\n\t  if (window.parent && window.parent !== window) {\n\t    return true; // check in connect\n\t    // e = window.parent.document.getElementById('ubExtensionPageMessageObj');\n\t  }\n\t\n\t  return !!e && e.getAttribute('data-extensionAttached') === 'YES';\n\t};\n\t\n\tUBNativeMessage.prototype.doOnDisconnect = function (reason) {\n\t  var me = this,\n\t      rejections = me.pendingMessages;\n\t  me.pendingMessages = {}; // prevent several rejection\n\t  me.connected = false;\n\t  if (rejections) {\n\t    _.forEach(rejections, function (pendingRequest) {\n\t      if (pendingRequest && pendingRequest.deffer) {\n\t        pendingRequest.deffer.reject(reason);\n\t      }\n\t    });\n\t  }\n\t};\n\t\n\tUBNativeMessage.prototype.onParentWinMessage = function (event) {\n\t  if (!event.data || event.data.messageType !== 'UBExtensionMsg') {\n\t    return;\n\t  }\n\t  this.onContentMessage(event.data);\n\t};\n\t\n\t/**\r\n\t * Connect to native messages host. Check extension & host is installed and up to date (according to UBNativeMessage.features).\r\n\t * @param {Number} [timeOut] Connection timeOut in millisecond. Default to UBNativeMessage.callTimeOut\r\n\t * @returns {Promise<UBNativeMessage>} resolved to UBNativeMessage or rejected to installation/upgrade message\r\n\t */\n\tUBNativeMessage.prototype.connect = function (timeOut) {\n\t  var me = this;\n\t  var promise = void 0;\n\t  if (me.connected) {\n\t    return Promise.resolve(me);\n\t  } else {\n\t    if (!UBNativeMessage.extensionExists()) {\n\t      return Promise.reject(new ubUtils.UBError(UBNativeMessage.createFeatureUpdateMsg('extension', '-', false)));\n\t    } else {\n\t      if (window.parent && window.parent !== window) {\n\t        // in iframe\n\t        promise = new Promise(function (resolve, reject) {\n\t          var timeId = void 0;\n\t          var onMessage = function onMessage(event) {\n\t            if (!event.data || event.data.messageType !== 'initUbExtensionParent') {\n\t              return event;\n\t            }\n\t            clearTimeout(timeId);\n\t            if (event.data.detail !== 'initUbExtensionReady') {\n\t              reject(new ubUtils.UBError(UBNativeMessage.createFeatureUpdateMsg('extension', '-', false)));\n\t              return event;\n\t            }\n\t            me.iFarmeMode = true;\n\t            window.removeEventListener('message', onMessage);\n\t            window.addEventListener('message', me.onParentWinMessage.bind(me), false);\n\t            resolve(true);\n\t          };\n\t          window.addEventListener('message', onMessage, false);\n\t          window.parent.postMessage({ messageType: 'initUbExtension' }, '*');\n\t          timeId = setTimeout(function () {\n\t            reject(new ubUtils.UBError(UBNativeMessage.createFeatureUpdateMsg('extension', '-', false)));\n\t          }, 1500);\n\t        });\n\t      } else {\n\t        promise = Promise.resolve(true);\n\t      }\n\t      return promise.then(function () {\n\t        return me.invoke('__extensionVersion');\n\t      }).then(function (extensionVersion) {\n\t        var versionNum = UBNativeMessage.versionToNumber(extensionVersion);\n\t        if (versionNum < UBNativeMessage.versionToNumber(UBNativeMessage.features.extension.minVersion)) {\n\t          ubUtils.logDebug('browser extension version', extensionVersion, 'is smaller when required', UBNativeMessage.features.extension.minVersion);\n\t          throw new ubUtils.UBError(UBNativeMessage.createFeatureUpdateMsg('extension', extensionVersion, true));\n\t        } else {\n\t          if (versionNum !== UBNativeMessage.versionToNumber(UBNativeMessage.features.extension.minVersion)) {\n\t            ubUtils.logDebug('Current version of extension', extensionVersion, 'is more than required', UBNativeMessage.features.extension.minVersion);\n\t          }\n\t          return true;\n\t        }\n\t      }).then(function () {\n\t        return me.invoke('__connect', { hostAppName: me.hostAppName }, timeOut).then(function (featureVersion) {\n\t          var requiredVersion = UBNativeMessage.features[me.feature].minVersion;\n\t          me.connected = true;\n\t          me.featureVersion = featureVersion;\n\t          if (UBNativeMessage.versionToNumber(featureVersion) < UBNativeMessage.versionToNumber(requiredVersion)) {\n\t            throw new ubUtils.UBError(UBNativeMessage.createFeatureUpdateMsg(me.feature, featureVersion, true));\n\t          } else if (featureVersion !== requiredVersion) {\n\t            ubUtils.logDebug('Current version of feature', me.feature, featureVersion, 'is more than required', requiredVersion);\n\t          }\n\t          return me;\n\t        }, function (reason) {\n\t          ubUtils.logError(reason);\n\t          throw new ubUtils.UBError(UBNativeMessage.createFeatureUpdateMsg(me.feature, '-', false));\n\t        });\n\t      }).catch(function (reason) {\n\t        me.disconnect();\n\t        throw reason;\n\t      });\n\t    }\n\t  }\n\t};\n\t\n\t/**\r\n\t * Disconnect from native\r\n\t * @return {*}\r\n\t */\n\tUBNativeMessage.prototype.disconnect = function () {\n\t  var me = this;\n\t  if (!me.connected) {\n\t    return Promise.resolve(true);\n\t  }\n\t  return me.invoke('__disconnect').then(function (message) {\n\t    ubUtils.logDebug('UBNativeMessage. Disconnected with message', message);\n\t    me.connected = false;\n\t    if (me.eventElm) {\n\t      me.eventElm.removeEventListener('UBExtensionMsg', me.onContentMessage);\n\t    }\n\t    return true;\n\t  });\n\t};\n\t\n\tUBNativeMessage.prototype.onMsgTimeOut = function (msgID) {\n\t  var me = this,\n\t      pending;\n\t  pending = me.pendingMessages[msgID];\n\t  if (pending) {\n\t    pending.timerID = null;\n\t    delete me.pendingMessages[msgID];\n\t    pending.deffer.reject(new ubUtils.UBError('unknownError', 'pluginMethodCallTimedOut'));\n\t  }\n\t};\n\t\n\t/**\r\n\t * @private\r\n\t * @type {number}\r\n\t */\n\tUBNativeMessage.prototype.idCounter = 0;\n\t\n\tUBNativeMessage.createFeatureUpdateMsg = function (featureName, currentVersion, isUpdate) {\n\t  var featureInfo = UBNativeMessage.features[featureName],\n\t      res,\n\t      msg,\n\t      installer = ubUtils.format(featureInfo.installer, featureInfo.minVersion /* .replace(/\\./g, '_') */);\n\t\n\t  msg = 'NM' + (isUpdate ? 'Update' : 'Install') + (featureName === 'extension' ? 'Extension' + (ubUtils.isOpera ? 'Opera' : 'Chrome') : 'Feature');\n\t  res = ubUtils.format(i18n(msg), i18n(featureInfo.UIName), featureInfo.minVersion, currentVersion, installer);\n\t  return res;\n\t};\n\t\n\tmodule.exports = UBNativeMessage;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t/**\r\n\t * Created by pavel.mash on 01.12.2016.\r\n\t */\n\t\n\t/* global XMLHttpRequest */\n\t\n\tvar ubUtils = __webpack_require__(1);\n\t\n\tfunction lowercase(str) {\n\t  return (str || '').toLowerCase();\n\t}\n\t\n\tfunction parseHeaders(headers) {\n\t  var parsed = {};\n\t  var key = void 0,\n\t      val = void 0,\n\t      i = void 0;\n\t\n\t  if (!headers) {\n\t    return parsed;\n\t  }\n\t\n\t  headers.split('\\n').forEach(function (line) {\n\t    i = line.indexOf(':');\n\t    key = lowercase(line.substr(0, i).trim());\n\t    val = line.substr(i + 1).trim();\n\t\n\t    if (key) {\n\t      if (parsed[key]) {\n\t        parsed[key] += ', ' + val;\n\t      } else {\n\t        parsed[key] = val;\n\t      }\n\t    }\n\t  });\n\t\n\t  return parsed;\n\t}\n\t\n\tfunction headersGetter(headers) {\n\t  var headersObj = (typeof headers === 'undefined' ? 'undefined' : _typeof(headers)) === 'object' ? headers : undefined;\n\t  return function (name) {\n\t    if (!headersObj) {\n\t      headersObj = parseHeaders(headers);\n\t    }\n\t    if (name) {\n\t      return headersObj[lowercase(name)];\n\t    }\n\t    return headersObj;\n\t  };\n\t}\n\t\n\tfunction transformData(data, headers, fns) {\n\t  if (typeof fns === 'function') {\n\t    return fns(data, headers);\n\t  }\n\t  fns.forEach(function (fn) {\n\t    data = fn(data, headers);\n\t  });\n\t  return data;\n\t}\n\t\n\tfunction transformDataPromise(data, headers, fns) {\n\t  var rPromise = Promise.resolve(data);\n\t  if (typeof fns === 'function') {\n\t    return rPromise.then(function (data) {\n\t      return fns(data, headers);\n\t    });\n\t  }\n\t  fns.forEach(function (fn) {\n\t    rPromise = rPromise.then(function (data) {\n\t      return fn(data, headers);\n\t    });\n\t  });\n\t  return rPromise;\n\t}\n\t\n\tfunction isSuccess(status) {\n\t  return status >= 200 && status < 300;\n\t}\n\t\n\tfunction forEach(obj, iterator, context) {\n\t  var keys = Object.keys(obj);\n\t  keys.forEach(function (key) {\n\t    iterator.call(context, obj[key], key);\n\t  });\n\t  return keys;\n\t}\n\t\n\tfunction forEachSorted(obj, iterator, context) {\n\t  var keys = Object.keys(obj).sort();\n\t  keys.forEach(function (key) {\n\t    iterator.call(context, obj[key], key);\n\t  });\n\t  return keys;\n\t}\n\t\n\tfunction buildUrl(url, params) {\n\t  if (!params) return url;\n\t  var parts = [];\n\t  forEachSorted(params, function (value, key) {\n\t    if (value == null) {\n\t      // jshint ignore:line\n\t      return;\n\t    }\n\t    if (!Array.isArray(value)) {\n\t      value = [value];\n\t    }\n\t\n\t    value.forEach(function (v) {\n\t      if ((typeof v === 'undefined' ? 'undefined' : _typeof(v)) === 'object') {\n\t        v = JSON.stringify(v);\n\t      }\n\t      parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(v));\n\t    });\n\t  });\n\t  return url + (url.indexOf('?') === -1 ? '?' : '&') + parts.join('&');\n\t}\n\t\n\tvar __lastRequestData = void 0;\n\tvar __lastRequestTime = new Date().getTime();\n\tvar __lastRequestURL = void 0;\n\t\n\t/**\r\n\t * Promise of perform an asynchronous HTTP request\r\n\t * Returns a {Promise} object with the\r\n\t *   standard Promise methods (<a href=\"https://github.com/kriskowal/q/wiki/Coming-from-jQuery#reference\">reference</a>).\r\n\t *   The `then` method takes two arguments a success and an error callback which will be called with a\r\n\t *   response object. The arguments passed into these functions are destructured representation of the response object passed into the\r\n\t *   `then` method. The response object has these properties:\r\n\t *\r\n\t *   - **data** – `{string|Object}` – The response body transformed with the transform\r\n\t *     functions. Default transform check response content-type is application/json and if so - convert data to Object\r\n\t *   - **status** – `{number}` – HTTP status code of the response.\r\n\t *   - **headers** – `{function([headerName])}` – Header getter function.\r\n\t *   - **config** – `{Object}` – The configuration object that was used to generate the request.\r\n\t *\r\n\t *  @example\r\n\t *\r\n\t *      //Get some data from server:\r\n\t *      UB.xhr({url: 'getAppInfo'}).then(function(resp) {\r\n\t *          console.log('this is appInfo: %o', resp.data)\r\n\t *      });\r\n\t *\r\n\t *      //The same, but in more short form via {@link UB#get UB.get} shorthand:\r\n\t *      UB.get('getAppInfo').then(function(resp) {\r\n\t *          console.log('this is appInfo: %o', resp.data)\r\n\t *      });\r\n\t *\r\n\t *      //Run POST method:\r\n\t *      UB.post('ubql', [\r\n\t *          {entity: 'uba_user', method: 'select', fieldList: ['*']}\r\n\t *      ]).then(function(resp) {\r\n\t *          console.log('success!');\r\n\t *      }, function(resp) {\r\n\t *          console.log('request failed with status' + resp.status);\r\n\t *      });\r\n\t *\r\n\t *      //retrieve binary data as ArrayBuffer\r\n\t *      UB.get('downloads/cert/ACSK(old).cer', {responseType: 'arraybuffer'})\r\n\t *      .then(function(res){\r\n\t *          console.log('Got Arrray of %d length', res.data.byteLength);\r\n\t *      });\r\n\t *\r\n\t * @method\r\n\t * @param {Object} requestConfig Object describing the request to be made and how it should be\r\n\t *    processed. The object has following properties:\r\n\t * @param {String} requestConfig.url  Absolute or relative URL of the resource that is being requested\r\n\t * @param {String} [requestConfig.method] HTTP method (e.g. 'GET', 'POST', etc). Default is GET\r\n\t * @param {Object.<string|Object>} [requestConfig.params] Map of strings or objects which will be turned\r\n\t *      to `?key1=value1&key2=value2` after the url. If the value is not a string, it will be JSONified\r\n\t * @param {String|Object} [requestConfig.data] Data to be sent as the request message data\r\n\t * @param {Object} [requestConfig.headers]  Map of strings or functions which return strings representing\r\n\t *      HTTP headers to send to the server. If the return value of a function is null, the\r\n\t *      header will not be sent. Merged with {@link UB#xhrDefaults UB.xhrDefaults.headers}\r\n\t * @param {function(data, function)|Array.<function(data, function)>} [requestConfig.transformRequest]\r\n\t *      Transform function or an array of such functions. The transform function takes the http\r\n\t *      request body and headers and returns its transformed (typically serialized) version.\r\n\t * @param {function(data, function)|Array.<function(data, function)>} [requestConfig.transformResponse]\r\n\t *      Transform function or an array of such functions. The transform function takes the http\r\n\t *      response body and headers and returns its transformed (typically deserialized) version.\r\n\t * @param  {Number|Promise} [requestConfig.timeout] timeout in milliseconds, or {@link Q promise}\r\n\t *      that should abort the request when resolved. Default to {UB.xhrDefaults.timeout}\r\n\t * @param  {Boolean} [requestConfig.withCredentials] whether to to set the `withCredentials` flag on the\r\n\t *      XHR object. See <a href=\"https://developer.mozilla.org/en/http_access_control#section_5\">requests with credentials</a>\r\n\t *      for more information.\r\n\t * @param  {String} [requestConfig.responseType] see <a href=\"https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType\">responseType</a>.\r\n\t * @param {Function} [requestConfig.onProgress] XHR onProgress callback, see <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ProgressEvent\">ProgressEvent</url> for details.\r\n\t *      To be user instead obsolete Q Promise.progress()\r\n\t * @returns {Promise}\r\n\t */\n\tfunction xhr(requestConfig) {\n\t  var defaults = xhrDefaults;\n\t  var config = {\n\t    transformRequest: defaults.transformRequest,\n\t    transformResponse: defaults.transformResponse\n\t  };\n\t  var mergeHeaders = function mergeHeaders(config) {\n\t    var defHeaders = defaults.headers;\n\t    var reqHeaders = ubUtils.apply({}, config.headers);\n\t    var defHeaderName = void 0,\n\t        lowercaseDefHeaderName = void 0,\n\t        reqHeaderName = void 0;\n\t\n\t    var execHeaders = function execHeaders(headers) {\n\t      forEach(headers, function (headerFn, header) {\n\t        if (typeof headerFn === 'function') {\n\t          var headerContent = headerFn();\n\t          if (headerContent) {\n\t            headers[header] = headerContent;\n\t          } else {\n\t            delete headers[header];\n\t          }\n\t        }\n\t      });\n\t    };\n\t\n\t    defHeaders = ubUtils.apply({}, defHeaders.common, defHeaders[lowercase(config.method)]);\n\t\n\t    // execute if header value is function\n\t    execHeaders(defHeaders);\n\t    execHeaders(reqHeaders);\n\t\n\t    // using for-in instead of forEach to avoid unecessary iteration after header has been found\n\t    // noinspection Eslint\n\t    defaultHeadersIteration: for (defHeaderName in defHeaders) {\n\t      lowercaseDefHeaderName = lowercase(defHeaderName);\n\t      for (reqHeaderName in reqHeaders) {\n\t        if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {\n\t          // noinspection Eslint\n\t          continue defaultHeadersIteration;\n\t        }\n\t      }\n\t      reqHeaders[defHeaderName] = defHeaders[defHeaderName];\n\t    }\n\t    return reqHeaders;\n\t  };\n\t  var headers = mergeHeaders(requestConfig);\n\t\n\t  ubUtils.apply(config, requestConfig);\n\t  config.headers = headers;\n\t  config.method = config.method ? config.method.toUpperCase() : 'GET';\n\t\n\t  var transformResponse = void 0,\n\t      serverRequest = void 0,\n\t      promise = void 0;\n\t\n\t  transformResponse = function transformResponse(response) {\n\t    return transformDataPromise(response.data, response.headers, config.transformResponse).then(function (trdData) {\n\t      response.data = trdData;\n\t      return isSuccess(response.status) ? response : Promise.reject(response);\n\t    });\n\t  };\n\t\n\t  serverRequest = function serverRequest(config) {\n\t    headers = config.headers;\n\t    var reqData = transformData(config.data, headersGetter(headers), config.transformRequest);\n\t    var prevReqTime = __lastRequestTime;\n\t    __lastRequestTime = new Date().getTime();\n\t    // strip content-type if data is undefined\n\t    if (!config.data) {\n\t      forEach(headers, function (value, header) {\n\t        if (lowercase(header) === 'content-type') {\n\t          delete headers[header];\n\t        }\n\t      });\n\t    } else {\n\t      // prevent reiteration sending of the same request\n\t      // for example if HTML button on the form got a focus and `space` pressed\n\t      // in case button not disabled inside `onclick` handler we got a many-many same requests\n\t      if (__lastRequestURL === config.url && typeof reqData === 'string' && __lastRequestData === reqData && __lastRequestTime - prevReqTime < 100) {\n\t        throw new ubUtils.UBError('monkeyRequestsDetected');\n\t      } else {\n\t        __lastRequestData = reqData;\n\t        __lastRequestURL = config.url;\n\t      }\n\t    }\n\t\n\t    if (!config.withCredentials && defaults.withCredentials) {\n\t      config.withCredentials = defaults.withCredentials;\n\t    }\n\t    if (!config.timeout && defaults.timeout) {\n\t      config.timeout = defaults.timeout;\n\t    }\n\t\n\t    // send request\n\t    return sendReq(config, reqData, headers).then(transformResponse, transformResponse);\n\t  };\n\t\n\t  promise = Promise.resolve(config);\n\t\n\t  // build a promise chain with request interceptors first, then the request, and response interceptors\n\t  interceptors.filter(function (interceptor) {\n\t    return !!interceptor.request || !!interceptor.requestError;\n\t  }).map(function (interceptor) {\n\t    return { success: interceptor.request, failure: interceptor.requestError };\n\t  }).concat({ success: serverRequest }).concat(interceptors.filter(function (interceptor) {\n\t    return !!interceptor.response || !!interceptor.responseError;\n\t  }).map(function (interceptor) {\n\t    return { success: interceptor.response, failure: interceptor.responseError };\n\t  })).forEach(function (then) {\n\t    promise = promise.then(then.success, then.failure);\n\t  });\n\t\n\t  return promise;\n\t}\n\t\n\t/**\r\n\t * Allow Request reiteration, for example in case of request are repeated after re-auth\r\n\t */\n\txhr.allowRequestReiteration = function () {\n\t  __lastRequestData = null;\n\t};\n\t\n\tvar CONTENT_TYPE_APPLICATION_JSON = { 'Content-Type': 'application/json;charset=utf-8' };\n\t\n\t/**\r\n\t * The default HTTP parameters for {xhr}\r\n\t * @property {Object} xhrDefaults\r\n\t * @property {Array<Function>} xhrDefaults.transformRequest request transformations\r\n\t * @property {Array<Function>} xhrDefaults.transformResponse response transformations\r\n\t * @property {Object} xhrDefaults.headers Default headers to apply to request (depending of method)\r\n\t * @property {Number} xhrDefaults.timeout Default timeout to apply to request\r\n\t */\n\tvar xhrDefaults = {\n\t  transformRequest: [function (data) {\n\t    return !!data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && data.toString() !== '[object File]' && data.toString() !== '[object ArrayBuffer]' ? JSON.stringify(data) : data;\n\t  }],\n\t  transformResponse: [function (data, headers) {\n\t    if (typeof data === 'string' && (headers('content-type') || '').indexOf('json') >= 0) {\n\t      data = JSON.parse(data);\n\t    }\n\t    return data;\n\t  }],\n\t  headers: {\n\t    common: { 'Accept': 'application/json, text/plain, */*' },\n\t    post: CONTENT_TYPE_APPLICATION_JSON,\n\t    put: CONTENT_TYPE_APPLICATION_JSON,\n\t    patch: CONTENT_TYPE_APPLICATION_JSON\n\t  },\n\t  timeout: 120000\n\t};\n\t\n\t/**\r\n\t * Interceptors array\r\n\t * @type {Array.<Object>}\r\n\t * @protected\r\n\t */\n\tvar interceptors = [];\n\t\n\t/**\r\n\t * Array of config objects for currently pending requests. This is primarily meant to be used for debugging purposes.\r\n\t * @type {Array.<Object>}\r\n\t * @protected\r\n\t */\n\tvar pendingRequests = [];\n\t\n\tvar XHR = XMLHttpRequest;\n\tfunction sendReq(config, reqData, reqHeaders) {\n\t  var url = buildUrl(config.url, config.params);\n\t  var promise = new Promise(function (resolve, reject) {\n\t    var xhr = new XHR();\n\t    var aborted = -1;\n\t    var status = void 0,\n\t        timeoutId = void 0;\n\t\n\t    pendingRequests.push(config);\n\t\n\t    xhr.open(config.method, url, true);\n\t    forEach(reqHeaders /* MPV config.headers */, function (value, key) {\n\t      if (value) {\n\t        xhr.setRequestHeader(key, value);\n\t      }\n\t    });\n\t\n\t    xhr.onreadystatechange = function () {\n\t      if (xhr.readyState === 4) {\n\t        var response = void 0,\n\t            responseHeaders = void 0;\n\t        if (status !== aborted) {\n\t          responseHeaders = xhr.getAllResponseHeaders();\n\t          // responseText is the old-school way of retrieving response (supported by IE8 & 9)\n\t          // response/responseType properties were introduced in XHR Level2 spec (supported by IE10)\n\t          response = xhr.responseType ? xhr.response : xhr.responseText;\n\t        }\n\t\n\t        // cancel timeout and subsequent timeout promise resolution\n\t        if (timeoutId) {\n\t          clearTimeout(timeoutId);\n\t        }\n\t        status = status || xhr.status;\n\t        xhr = null;\n\t\n\t        // normalize status, including accounting for IE bug (http://bugs.jquery.com/ticket/1450)\n\t        status = Math.max(status === 1223 ? 204 : status, 0);\n\t\n\t        var idx = pendingRequests.indexOf(config);\n\t        if (idx !== -1) {\n\t          pendingRequests.splice(idx, 1);\n\t        }\n\t\n\t        (isSuccess(status) ? resolve : reject)({\n\t          data: response,\n\t          status: status,\n\t          headers: headersGetter(responseHeaders),\n\t          config: config\n\t        });\n\t      }\n\t    };\n\t\n\t    if (config.onProgress) {\n\t      if (xhr.upload) {\n\t        xhr.upload.onprogress = config.onProgress;\n\t      } else {\n\t        xhr.onprogress = config.onProgress;\n\t      }\n\t    }\n\t\n\t    if (config.withCredentials) {\n\t      xhr.withCredentials = true;\n\t    }\n\t\n\t    if (config.responseType) {\n\t      xhr.responseType = config.responseType;\n\t    }\n\t\n\t    xhr.send(reqData || null);\n\t\n\t    if (config.timeout > 0) {\n\t      timeoutId = setTimeout(function () {\n\t        status = aborted;\n\t        if (xhr) {\n\t          xhr.abort();\n\t        }\n\t      }, config.timeout);\n\t    }\n\t  });\n\t\n\t  return promise;\n\t}\n\t\n\t/**\r\n\t * Shortcut for {@link UB.xhr} to perform a `GET` request.\r\n\t * @method\r\n\t * @param {string} url Relative or absolute URL specifying the destination of the request\r\n\t * @param {Object=} [config] Optional configuration object as in {@link UB#xhr UB.xhr}\r\n\t * @returns {Promise} Future object\r\n\t */\n\tfunction get(url, config) {\n\t  return xhr(ubUtils.apply(config || {}, {\n\t    method: 'GET',\n\t    url: url\n\t  }));\n\t}\n\t\n\t/**\r\n\t * Shortcut for {@link UB.xhr} to perform a `POST` request.\r\n\t * @method\r\n\t * @param {string} url Relative or absolute URL specifying the destination of the request\r\n\t * @param {*} data Request content\r\n\t * @param {Object=} [config] Optional configuration object as in {@link UB#xhr UB.xhr}\r\n\t * @returns {Promise} Future object\r\n\t */\n\tfunction post(url, data, config) {\n\t  return xhr(ubUtils.apply(config || {}, {\n\t    method: 'POST',\n\t    url: url,\n\t    data: data\n\t  }));\n\t}\n\t\n\t// TODO - move to adminUI\n\t// var reLetters = /[A-Za-zА-Яа-яЁёіІїЇґҐ]/,\n\t//   reEn = /[A-Za-z]/,\n\t//   reCaps = /[A-ZА-ЯЁІЇҐ]/\n\t//\n\t// UB.passwordKeyUpHandler = function (textfield) {\n\t//   var t, n, s = textfield.getValue() || ''\n\t//   if (!s) {\n\t//     textfield.removeCls('ub-pwd-keyboard-caps')\n\t//     textfield.removeCls('ub-pwd-keyboard-en')\n\t//   } else {\n\t//     n = s.length\n\t//     t = s.substr(n - 1, 1)\n\t//     if (reLetters.test(t)) {\n\t//       if (reEn.test(t)) {\n\t//         textfield.addClass('ub-pwd-keyboard-en')\n\t//       } else {\n\t//         textfield.removeCls('ub-pwd-keyboard-en')\n\t//       }\n\t//       if (reCaps.test(t)) {\n\t//         textfield.addClass('ub-pwd-keyboard-caps')\n\t//       } else {\n\t//         textfield.removeCls('ub-pwd-keyboard-caps')\n\t//       }\n\t//     }\n\t//   }\n\t// }\n\t\n\tmodule.exports = {\n\t  interceptors: interceptors,\n\t  pendingRequests: pendingRequests,\n\t  xhrDefaults: xhrDefaults,\n\t  xhr: xhr,\n\t  get: get,\n\t  post: post\n\t};\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\r\n\t * Repository for server-side data retrieve\r\n\t *\r\n\t * @module @unitybase/base/CustomRepository\r\n\t * @author pavel.mash 23.09.2014\r\n\t */\n\t\n\t// ***********   !!!!WARNING!!!!! **********************\n\t// Module shared between server and client code\n\tvar _ = __webpack_require__(3);\n\tvar bracketsRe = /\\[.*]/;\n\t// in case values for where is null we transform condition to allowed null comparison with warning.\n\t// If condition not in conditionInCaseValueIsNull object keys we raise error\n\tvar conditionInCaseValueIsNull = { equal: 'isNull', notEqual: 'notIsNull', custom: 'custom' };\n\t\n\t/**\r\n\t * Base data access class for server-side, client(browser)-side and client(console) side Repositories.\r\n\t * Usually used via UB.Repository fabric function.\r\n\t *\r\n\t * Do not use it directly, use UB.Repository instead.\r\n\t */\n\t\n\tvar CustomRepository = function () {\n\t  /**\r\n\t   * @param {String} entityName name of Entity we create for\r\n\t   */\n\t  function CustomRepository(entityName) {\n\t    _classCallCheck(this, CustomRepository);\n\t\n\t    /**\r\n\t     * @private\r\n\t     * @type {Array}\r\n\t     */\n\t    this.fieldList = [];\n\t    /**\r\n\t     * @private\r\n\t     * @type {Array}\r\n\t     */\n\t    this.groupList = [];\n\t    /**\r\n\t     * @private\r\n\t     * @type {{}}\r\n\t     */\n\t    this.whereList = {};\n\t    /**\r\n\t     * @private\r\n\t     * @type {Array}\r\n\t     */\n\t    this.logicalPredicates = [];\n\t    /**\r\n\t     * @private\r\n\t     * @type {Array}\r\n\t     */\n\t    this.joinAs = [];\n\t    /**\r\n\t     * @private\r\n\t     * @type {Array}\r\n\t     */\n\t    this.orderList = [];\n\t    /**\r\n\t     * @type {{}}\r\n\t     */\n\t    this.options = {};\n\t\n\t    /**\r\n\t     * Name of entity method used for data retrieve. Default is 'select'. The correct way to set method is `.using('mySelect')`\r\n\t     * @type {string}\r\n\t     * @private\r\n\t     */\n\t    this.method = 'select';\n\t\n\t    /**\r\n\t     * Retrieved data description for server log in GUI mode. Default is ''.\r\n\t     * @property {string} __description\r\n\t     * @private\r\n\t     */\n\t    this.__description = '';\n\t\n\t    /**\r\n\t     * Miscellaneous options\r\n\t     * @property {Object} __misc\r\n\t     * @private\r\n\t     */\n\t    this.__misc = {};\n\t\n\t    this.entityName = entityName;\n\t  }\n\t  /**\r\n\t   * Retrieve a data from server using `methodName` entity method.\r\n\t   * By default `select` method will be used.\r\n\t   * @param {string} methodName\r\n\t   */\n\t\n\t\n\t  _createClass(CustomRepository, [{\n\t    key: 'using',\n\t    value: function using(methodName) {\n\t      this.method = methodName;\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Add fields to collection.\r\n\t     * Can take one attribute name as string or array of attributes.\r\n\t     * Duplicate is not checked and in case of duplicate attribute caller got server error.\r\n\t     *\r\n\t     *      UB.Repository('tri_srf_reg').attrs('ID').attrs(['code', 'name']).attrs('fullName', 'newCode');\r\n\t     *\r\n\t     * Can take expression as a field. In this case entity attribute name must be wrapped into [] brackets.\r\n\t     * In case of client-side execution the only valid expression is one of:\r\n\t     *\r\n\t     * - **'SUM', 'COUNT', 'AVG', 'MAX', 'MIN', 'CAST', 'COALESCE'**\r\n\t     *\r\n\t     * Example:\r\n\t     *\r\n\t     *      UB.Repository('tri_srf_reg').attrs('SUM([payment])').where('documentID', '=', value); //will calculate sum of document payments\r\n\t     *\r\n\t     * If case of server-side execution any valid SQL expression is accepted:\r\n\t     *\r\n\t     *      UB.Repository('uba_user').attrs('[ID] / 100 + 1').selectAsArray()\r\n\t     *\r\n\t     * @param {String|Array} attr\r\n\t     * @return {CustomRepository}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'attrs',\n\t    value: function attrs(attr) {\n\t      var fields = _.flatten(Array.prototype.slice.call(arguments));\n\t      this.fieldList = this.fieldList.concat(fields);\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Add where expression. Fix some known issues:\r\n\t     *\r\n\t     *  - if attribute name without brackets is passed to expression parameter then wrap attribute to brackets \"ID\" -> \"[ID]\"\r\n\t     *\r\n\t     *  - transform some dummy expressions to more simple form: `in ['one']` -> `equal 'one', `in []` -> `0=1`, `? null` -> `isNull` e.t.c.\r\n\t     *\r\n\t     *  - expression may contains this functions: 'SUM', 'COUNT', 'AVG', 'MAX', 'MIN', 'CAST', 'COALESCE',\r\n\t     *    'LENGTH', 'LOWER', 'UPPER', 'DAY', 'MONTH', 'YEAR', 'ROUND', 'FLOOR', 'CEILING'\r\n\t     *\r\n\t     *\r\n\t     * `In` and 'notIn` conditions can take a sub-repository as a values parameter value. See CustomRepository.exists for a conplex example\r\n\t     *\r\n\t     * @example\r\n\t     *        UB.Repository('my_entity').attrs('id')\r\n\t     *           .where('code', 'in', ['1', '2', '3'])  // code in ('1', '2', '3')\r\n\t     *           .where('code', 'in', UB.Repository('my_codes').attr('code').where('ID', '<', 10)  // code in (select code from my_codes where id = 10)\r\n\t     *           .where('[name]', 'contains', 'Homer'). // name like '%homer%'\r\n\t     *           .where('[birtday]', 'geq', new Date()).where('birtday', 'leq', new Date() + 10) //(birtday >= '2012-01-01') AND (birtday <= '2012-01-02')\r\n\t     *           .where('[age] -10', '>=', {age: 15}, 'byAge') // (age + 10 >= 15)\r\n\t     *           .where('LENGTH([code]), '<', 5)\r\n\t     *           .where('', 'match', 'myvalue') // for condition match expression not need\r\n\t     *\r\n\t     * @param {String} expression   Attribute name (with or without []) or valid expression with attributes in [].\r\n\t     * @param {WhereCondition|String} condition    Any value from WhereCondition list.\r\n\t     * @param {*} [values]          Condition value. In case expression is complex can take {Object} as value.\r\n\t     *                              In case values === undefined no values property passed to where list\r\n\t     * @param {String} [clauseName] Optional clause name to be used in {CustomRepository.logicalPredicates}. If not passed where will generate unique clause named 'c1', 'c2', ......\r\n\t     * @return {CustomRepository}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'where',\n\t    value: function where(expression, condition, values, clauseName) {\n\t      var subQueryType = void 0;\n\t      if (!clauseName) {\n\t        // generate unique clause name\n\t        clauseName = 'c' + Object.keys(this.whereList).length + 1;\n\t        while (this.whereList[clauseName]) {\n\t          clauseName += '_';\n\t        }\n\t      }\n\t      var originalCondition = condition;\n\t      var WhereCondition = CustomRepository.prototype.WhereCondition;\n\t      condition = WhereCondition[condition];\n\t      if (expression && condition !== 'custom' && !bracketsRe.test(expression)) {\n\t        expression = '[' + expression + ']';\n\t      }\n\t      if (!condition) {\n\t        throw new Error('Unknown conditions');\n\t      }\n\t      if ((condition === 'in' || condition === 'notIn') && values instanceof CustomRepository) {\n\t        // subquery\n\t        subQueryType = condition; // remember sub-query type\n\t        condition = 'subquery';\n\t        values = values.ubql(); // get a subquery definition from a sub-repository\n\t      } else if (condition === 'subquery') {\n\t        subQueryType = originalCondition;\n\t        if (values instanceof CustomRepository) {\n\t          values = values.ubql(); // get a subquery definition from a sub-repository\n\t        }\n\t      } else if (condition === 'in' && !Array.isArray(values)) {\n\t        console.debug('Condition \"in\" is passed to CustomRepository.where but values is not an array -> condition transformed to equal. Check your logic');\n\t        condition = WhereCondition.equal;\n\t      } else if (condition === 'in' && (!values || !values.length)) {\n\t        console.warn('Condition \"in\" is passed to CustomRepository.where but value is empty array -> condition transformed to \"0=1\". Check your logic');\n\t        expression = '0';\n\t        condition = WhereCondition.equal;\n\t        values = { a: 1 };\n\t      } else if (condition === 'notIn' && (!values || !values.length)) {\n\t        console.warn('Condition \"notIn\" is passed to CustomRepository.where but value is empty array -> condition transformed to \"1=1\". Check your logic');\n\t        expression = '1';\n\t        condition = WhereCondition.equal;\n\t        values = { a: 1 };\n\t      } else if (values === null && (condition !== 'isNull' || condition !== 'notIsNull')) {\n\t        var wrongCondition = condition;\n\t        values = undefined;\n\t        condition = conditionInCaseValueIsNull[wrongCondition];\n\t        if (condition) {\n\t          console.warn('Condition ' + wrongCondition + 'is passed to CustomRepository.where but value is null -> condition transformed to ' + condition + '. Check your logic');\n\t        } else {\n\t          throw new Error('Condition ' + wrongCondition + 'is passed to CustomRepository.where but value is null');\n\t        }\n\t      }\n\t      if (condition === 'in' && values.length === 1) {\n\t        // console.warn('Condition \"in\" is passed to CustomRepository.where but value is an array on ONE item -> condition transformed to \"equal\". Check your logic')\n\t        condition = WhereCondition.equal;\n\t        values = values[0];\n\t      }\n\t      if (values !== undefined && ((typeof values === 'undefined' ? 'undefined' : _typeof(values)) !== 'object' || Array.isArray(values) || _.isDate(values))) {\n\t        var obj = {};\n\t        obj[clauseName] = values;\n\t        values = obj;\n\t      }\n\t      var whereItem = {\n\t        expression: expression,\n\t        condition: condition\n\t      };\n\t      if (condition === 'subquery') {\n\t        whereItem.subQueryType = subQueryType;\n\t      }\n\t      if (values !== undefined) {\n\t        whereItem.values = values;\n\t      }\n\t      this.whereList[clauseName] = whereItem;\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     *  Add an expression with `EXISTS` sub-query. Inside a sub-query there is two macro:\r\n\t     *\r\n\t     *  - {master} will be replaced by master entity alias\r\n\t     *  - {self}  will be replaced by sub-query entity alias\r\n\t     *\r\n\t     *      //select users\r\n\t     *      UB.Repository('uba_user').attrs(['ID', 'name'])\r\n\t     *        // who are not disabled\r\n\t     *        .where('disabled', '=', 0)\r\n\t     *        // which allowed access from Kiev\r\n\t     *        .where('trustedIP', 'in',\r\n\t     *          UB.Repository('geo_ip').attrs('IPAddr')\r\n\t     *            .where('city', '=', 'Kiev')\r\n\t     *        )\r\n\t     *        // who do not login during this year\r\n\t     *        .notExists(\r\n\t     *          UB.Repository('uba_audit')\r\n\t     *            .correlation('actionUser', 'name')  // here we link to uba_user.name\r\n\t     *            .where('actionTime', '>', new Date(2016, 1, 1))\r\n\t     *            .where('actionType', '=', 'LOGIN')\r\n\t     *        )\r\n\t     *        // but modify some data\r\n\t     *        .exists(\r\n\t     *          UB.Repository('uba_auditTrail')\r\n\t     *            .correlation('actionUser', 'ID') // here we link to uba_user.ID\r\n\t     *            .where('actionTime', '>', new Date(2016, 1, 1))\r\n\t     *        )\r\n\t     *        .select()\r\n\t     *\r\n\t     * @param {CustomRepository} subRepository  Repository, what represent a sub-query to be execute inside EXISTS statement\r\n\t     * @param {String} [clauseName] Optional clause name\r\n\t     * @return {CustomRepository}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'exists',\n\t    value: function exists(subRepository, clauseName) {\n\t      return this.where('', 'exists', subRepository, clauseName);\n\t    }\n\t\n\t    /**\r\n\t     * Add an expression with `NOT EXISTS` sub-query. See CustomRepository.exists for sample\r\n\t     *\r\n\t     * @param {CustomRepository} subRepository  Repository, what represent a sub-query to be execute inside EXISTS statement\r\n\t     * @param {String} [clauseName] Optional clause name\r\n\t     * @return {CustomRepository}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'notExists',\n\t    value: function notExists(subRepository, clauseName) {\n\t      return this.where('', 'notExists', subRepository, clauseName);\n\t    }\n\t\n\t    /**\r\n\t     * If current repository are used as a sub-query for `exists`, `notExists`, `in` or `notIn` conditions\r\n\t     * will add a [correlation](https://en.wikipedia.org/wiki/Correlated_subquery) with a master repository\r\n\t     *\r\n\t     *\r\n\t     * @param {String} subQueryAttribute\r\n\t     * @param {String} masterAttribute\r\n\t     * @param {WhereCondition|String} [condition=eq] A subset from WhereCondition list applicable for correlation join\r\n\t     * @param {String} [clauseName] Optional clause name to be used in {CustomRepository.logicalPredicates}. If not passed where will generate unique clause named 'c1', 'c2', ......\r\n\t     * @return {CustomRepository}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'correlation',\n\t    value: function correlation(subQueryAttribute, masterAttribute, condition, clauseName) {\n\t      if (!bracketsRe.test(subQueryAttribute)) {\n\t        subQueryAttribute = '[' + subQueryAttribute + ']';\n\t      }\n\t      if (!condition) condition = '=';\n\t      return this.where(subQueryAttribute + condition + '[{master}.' + masterAttribute + ']', 'custom', undefined, clauseName);\n\t    }\n\t    /**\r\n\t     * Arrange where expressions in logical order. By default where expressions is joined by AND logical predicate. Here is possible to  join it in custom order.\r\n\t     *\r\n\t     *      UB.Repository('my_entity').attrs('id')\r\n\t     *          .where('code', 'in', ['1', '2', '3'], 'byCode')  // code in ('1', '2', '3')\r\n\t     *          .where('name', 'contains', 'Homer', 'byName') // name like '%homer%'\r\n\t     *          .where('birtday', 'geq', new Date()).where('birtday', 'leq', new Date() + 10) //(birtday >= '2012-01-01') AND (birtday <= '2012-01-02')\r\n\t     *          .where('[age] -10', '>=', {age: 15}, 'byAge') // (age + 10 >= 15)\r\n\t     *          .logic('(([byCode]) OR ([byName]))') // (byCode OR byName) AND (all where items, not included in logic)\r\n\t     *\r\n\t     * @param {String} predicate logical predicate.\r\n\t     * @return {CustomRepository}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'logic',\n\t    value: function logic(predicate) {\n\t      this.logicalPredicates.push(predicate);\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Force where expressions to be used in join SQL statement instead of where. Applicable only for not cached entities.\r\n\t     *\r\n\t     *      // will generate\r\n\t     *      // SELECT A.ID, B.code FROM tst_document A LEFT JOIN tst_category B ON (B.instanceID = A.ID and B.ubUser = 10)\r\n\t     *      // instead of\r\n\t     *      // SELECT A.ID, B.code FROM tst_document A LEFT JOIN tst_category B ON B.instanceID = A.ID WHERE B.ubUser = 10\r\n\t     *      UB.Repository('tst_document').attrs(['ID', '[caregory.code]'])\r\n\t     *          .where('[caregory.ubUser]', '=', 10, 'wantInJoin')\r\n\t     *          .join('wantInJoin')\r\n\t     *          .selectAsObject().done(UB.logDebug);\r\n\t     *\r\n\t     * @param {String} whereItemName name of where item to use in join.\r\n\t     * @return {CustomRepository}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'join',\n\t    value: function join(whereItemName) {\n\t      this.joinAs.push(whereItemName);\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Add join condition. Fix some known issues\r\n\t     *\r\n\t     * @param {String} expression   Attribute name (with or without []) or valid expression with attributes in [].\r\n\t     * @param {WhereCondition} condition    Any value from WhereCondition list.\r\n\t     * @param {*} [values]          Condition value. In case expression is complex can take {Object} as value.\r\n\t     *                              In case values === undefined no values property passed to where list\r\n\t     * @param {String} [clauseName] Optional clause name to be used in {CustomRepository.logicalPredicates}. If not passed where will generate unique clause named 'c1', 'c2', ......\r\n\t     * @return {CustomRepository}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'joinCondition',\n\t    value: function joinCondition(expression, condition, values, clauseName) {\n\t      if (!clauseName) {\n\t        // generate unique clause name\n\t        clauseName = 'c' + Object.keys(this.whereList).length + 1;\n\t        while (this.whereList[clauseName]) {\n\t          clauseName += '_';\n\t        }\n\t      }\n\t      this.where(expression, condition, values, clauseName);\n\t      this.joinAs.push(clauseName);\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Add sorting\r\n\t     *\r\n\t     *      UB.CustomRepository('my_entity').attrs('ID').orderBy('code')\r\n\t     *\r\n\t     * @param attr      Sorted attribute\r\n\t     * @param [direction='asc'] Sort direction ('asc'|'desc')\r\n\t     * @return {CustomRepository}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'orderBy',\n\t    value: function orderBy(attr, direction) {\n\t      direction = direction || 'asc';\n\t      this.orderList.push({\n\t        expression: attr,\n\t        order: direction\n\t      });\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Add desc sorting. The same as orderBy(attr, 'desc')\r\n\t     *\r\n\t     *      UB.Repository('my_entity').attrs('ID').orderBy('code').orderByDesc('date_create') // ORDER BY code, date_create DESC\r\n\t     *\r\n\t     * @param {String} attr\r\n\t     * @return {CustomRepository}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'orderByDesc',\n\t    value: function orderByDesc(attr) {\n\t      this.orderList.push({\n\t        expression: attr,\n\t        order: 'desc'\n\t      });\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Add grouping\r\n\t     * Can take one attribute name as string or array of attributes name\r\n\t     *\r\n\t     *      UB.Repository('my_entity').attrs('ID').groupBy('code')\r\n\t     *      UB.Repository('uba_user').attrs('disabled').groupBy('disabled').select()\r\n\t     *      UB.Repository('uba_user').attrs(['disabled','uPassword','COUNT([ID])']).groupBy(['disabled','uPassword']).select()\r\n\t     *\r\n\t     * @param attr  Grouped attribute\r\n\t     * @return {CustomRepository}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'groupBy',\n\t    value: function groupBy(attr) {\n\t      if (_.isArray(attr)) {\n\t        this.groupList = this.groupList.concat(attr);\n\t      } else if (_.isString(attr)) {\n\t        this.groupList.push(attr);\n\t      }\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Add options.start value to retrieve first `start` rows\r\n\t     *\r\n\t     *      var store = UB.Repository('my_entity').attrs('id').start(15).limit(10).select() //will return ID's from 15 to 25\r\n\t     *\r\n\t     * @param {Number} start\r\n\t     * @return {CustomRepository}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'start',\n\t    value: function start(_start) {\n\t      this.options.start = _start;\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t    * Add options.limit value. Can be combined with start.\r\n\t    *\r\n\t       // will return first two ID's from my_entity\r\n\t       var store = UB.Repository('my_entity').attrs('id').limit(2).select()\r\n\t    *\r\n\t    * @param {number} rowsLimit\r\n\t    * @return {CustomRepository}\r\n\t    */\n\t\n\t  }, {\n\t    key: 'limit',\n\t    value: function limit(rowsLimit) {\n\t      this.options.limit = rowsLimit;\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * For debug purpose only.\r\n\t     *\r\n\t     * If set, in GUI mode will put this description into log before query execution\r\n\t     *\r\n\t     *      var store = UB.Repository('my_entity').attrs('ID').describe('Select all record for \"my_entity\"').select()\r\n\t     *\r\n\t     * @param {String} value\r\n\t     * @return {CustomRepository}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'describe',\n\t    value: function describe(value) {\n\t      this.__description = value;\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Construct a UBQL JSON request. Used in {@link CustomRepository#select}\r\n\t     *\r\n\t     *       var repo = UB.Repository('my_entity').attrs('ID').where('code', '=', 'a')\r\n\t     *       var inst = new TubDataStore(my_entity);\r\n\t     *       inst.run('select', repo.ubql());\r\n\t     *\r\n\t     * @return {Object}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'ubql',\n\t    value: function ubql() {\n\t      var orderCnt = this.orderList.length;\n\t      var req = {\n\t        entity: this.entityName,\n\t        method: this.method,\n\t        fieldList: this.fieldList\n\t      };\n\t      if (this.groupList.length > 0) {\n\t        req.groupList = this.groupList;\n\t      }\n\t      if (Object.keys(this.whereList).length) {\n\t        req.whereList = this.whereList;\n\t      }\n\t      if (orderCnt > 0) {\n\t        req.orderList = {};\n\t        for (var i = 0; i < orderCnt; i++) {\n\t          req.orderList[i] = this.orderList[i];\n\t        }\n\t      }\n\t      if (Object.keys(this.options).length) {\n\t        // .limit || .start .totalRequired\n\t        req.options = this.options;\n\t      }\n\t      if (this.logicalPredicates.length) {\n\t        req.logicalPredicates = this.logicalPredicates;\n\t      }\n\t      if (this.joinAs.length) {\n\t        req.joinAs = this.joinAs;\n\t      }\n\t      _.defaults(req, this.__misc); // apply misc\n\t\n\t      return req;\n\t    }\n\t\n\t    /**\r\n\t     * Must be implemented in descendants and return (or resolved for async clients)\r\n\t     * to `array of object` representation of result, like this\r\n\t     *\r\n\t     *      [{\"ID\":3000000000004,\"code\":\"uba_user\"},{\"ID\":3000000000039,\"code\":\"uba_auditTrail\"}]\r\n\t     *\r\n\t     * @abstract\r\n\t     */\n\t\n\t  }, {\n\t    key: 'selectAsObject',\n\t    value: function selectAsObject() {\n\t      throw new Error('abstract');\n\t    }\n\t    /**\r\n\t     * Must be implemented in descendants and return (or resolved for async clients)\r\n\t     * to `array of array` representation of result, like this\r\n\t     *\r\n\t     *      {\"resultData\":{\"fields\":[\"ID\",\"name\",\"ID.name\"],\"rowCount\":1,\"data\":[[10,\"admin\",\"admin\"]]},\"total\":1,\"__totalRecCount\": totolRecCountIfWithTotalRequest}\r\n\t     *\r\n\t     * @abstract\r\n\t     */\n\t\n\t  }, {\n\t    key: 'selectAsArray',\n\t    value: function selectAsArray() {\n\t      throw new Error('abstract');\n\t    }\n\t\n\t    /**\r\n\t     * Must be implemented in descendants and return (or resolved for async clients)\r\n\t     * to `DataSet` class instance, implemented in caller level. It can be:\r\n\t     *\r\n\t     *  - {TubDataStore} for in-server context\r\n\t     *  - {UB.ux.data.UBStore} for UnityBase `adminUI` client\r\n\t     *  - `array of array` data representation for UnityBase remote connection\r\n\t     *  - etc.\r\n\t     *\r\n\t     * @abstract\r\n\t     * @param [storeConfig]\r\n\t     */\n\t\n\t  }, {\n\t    key: 'selectAsStore',\n\t    value: function selectAsStore(storeConfig) {\n\t      throw new Error('abstract');\n\t    }\n\t\n\t    /**\r\n\t     * Must be implemented in descendants as a alias to the most appropriate method\r\n\t     *\r\n\t     * @abstract\r\n\t     * @param [storeConfig]\r\n\t     */\n\t\n\t  }, {\n\t    key: 'select',\n\t    value: function select(storeConfig) {\n\t      throw new Error('abstract');\n\t    }\n\t\n\t    /**\r\n\t     * Select a single row. If ubql result is empty - return {undefined}.\r\n\t     *\r\n\t     * WARNING method do not check repository contains the single row and always return a first row from result.\r\n\t     * @abstract\r\n\t     * @return {Object|undefined}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'selectSingle',\n\t    value: function selectSingle() {\n\t      throw new Error('abstract');\n\t    }\n\t\n\t    /**\r\n\t     * Perform select and return a value of the first attribute from the first row\r\n\t     *\r\n\t     * WARNING method do not check repository contains the single row\r\n\t     * @abstract\r\n\t     * @return {Object|undefined}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'selectScalar',\n\t    value: function selectScalar() {\n\t      throw new Error('abstract');\n\t    }\n\t\n\t    /**\r\n\t     * Select a single row by ID. If ubql result is empty - return {undefined}.\r\n\t     *\r\n\t     * @abstract\r\n\t     * @param {Number} ID Row identifier\r\n\t     * @return {Object|undefined}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'selectById',\n\t    value: function selectById(ID) {\n\t      throw new Error('abstract');\n\t    }\n\t\n\t    /**\r\n\t     * Apply miscellaneous options to resulting ubRequest:\r\n\t     *\r\n\t     *          // this server-side call will select all currency, including deleted\r\n\t     *          UB.Repository('cdn_currency').attrs(['ID']).misc({__allowSelectSafeDeleted: true}).selectAsArray();\r\n\t     *\r\n\t     * @param {Object} flags\r\n\t     * @param {Date} [flags.__mip_ondate] Specify date on which to select data for entities with `dataHistory` mixin. Default to Now()\r\n\t     * @param {Boolean} [flags.__mip_recordhistory=false] Select only record history data for specified ID (for entities with `dataHistory` mixin)\r\n\t     * @param {Boolean} [flags.__mip_recordhistory_all=false] Ignore __mip_ondate and select all data (acts as select for entities without `dataHistory` mixin)\r\n\t     * @param {Boolean} [flags.__mip_disablecache=false] For entities with cacheType in [\"Session\", \"SessionEntity\"] not check is data modified and always return result\r\n\t     * @param {Boolean} [flags.__skipOptimisticLock=false] Skip optimistic lock for entities with `mStorage.simpleAudit = true`\r\n\t     * @param {Boolean} [flags.__allowSelectSafeDeleted=false] **Server-side only.**\r\n\t     * @param {Boolean} [flags.__skipSelectAfterUpdate=false] **Server-side only.**\r\n\t     * @param {Boolean} [flags.__skipSelectAfterInsert=false] **Server-side only.**\r\n\t     * @param {Boolean} [flags.__skipRls=false] **Server-side only.**\r\n\t     * @param {Boolean} [flags.__skipAclRls=false] **Server-side only.**\r\n\t     *\r\n\t     * @return {CustomRepository}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'misc',\n\t    value: function misc(flags) {\n\t      _.assign(this.__misc, flags);\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Calculate total row number. WARNING!! This is VERY slow operation on DB level in case of many record\r\n\t     *\r\n\t     * Result of calculation is returned in __totalRecCount parameter value in case `selectAsArray()` client call:\r\n\t     *\r\n\t     *          var result = UB.Repository('uba_user').attrs(['ID', 'description']).withTotal().selectAsArray();\r\n\t                console.log('Total count is:', result.__totalRecCount)\r\n\t     *\r\n\t     * Or into TubDataStore.totalRowCount in case of server side `selectAsStore()` call:\r\n\t     *\r\n\t     *          var store = UB.Repository('uba_user').attrs(['ID', 'description']).withTotal().selectAsStore();\r\n\t                console.log('Total count is:', store.totalRowCount);\r\n\t     *\r\n\t     * @return {CustomRepository}\r\n\t     */\n\t\n\t  }, {\n\t    key: 'withTotal',\n\t    value: function withTotal() {\n\t      this.options.totalRequired = true;\n\t      return this;\n\t    }\n\t  }]);\n\t\n\t  return CustomRepository;\n\t}();\n\t\n\t/**\r\n\t * Alias to {@link CustomRepository#ubql CustomRepository.ubql}\r\n\t * @memberOf CustomRepository\r\n\t * @private\r\n\t * @deprecated Will be removed in UB 2.0. Use .ubql() instead\r\n\t */\n\t\n\t\n\tCustomRepository.prototype.getRunListItem = CustomRepository.prototype.ubql;\n\t/**\r\n\t * Alias to {@link CustomRepository#ubql CustomRepository.ubRequest}\r\n\t * @memberOf CustomRepository\r\n\t * @protected\r\n\t * @deprecated Will be removed in UB 2.0. Use .ubql() instead\r\n\t */\n\tCustomRepository.prototype.ubRequest = CustomRepository.prototype.ubql;\n\t\n\t/**\r\n\t * Enumeration of all condition types. This enumeration defines a set of String values.\r\n\t * It exists primarily for documentation purposes - in code use the actual string values like '>', don't reference them through this class like WhereCondition.more.\r\n\t *\r\n\t * We define several aliases for the same condition. In case of direct HTTP request (without Repository) use only non-aliased values (i.e. `more` instead of '>' or 'gt')\r\n\t * @memberOf CustomRepository\r\n\t * @enum {string}\r\n\t */\n\tCustomRepository.prototype.WhereCondition = {\n\t  'gt': 'more', /** @property {string} gt Alias for `more` */\n\t  '>': 'more', /** @property {string} _greaterThan This is actually **>** sign - we can't pout it into documentation. Alias for `more` */\n\t  'more': 'more', /** @property {string} more Greater than */\n\t\n\t  'lt': 'less', /** @property {string} lt Alias for `less` */\n\t  '<': 'less', /** @property {string} _lessThan (actually **<** sign). Alias for `less` */\n\t  'less': 'less', /** @property {string} less Less than */\n\t\n\t  'eq': 'equal', /** @property {string} eq Alias for `equal` */\n\t  '=': 'equal', /** @property {string} _eq (actually **=** sign). Alias for `equal` */\n\t  'equal': 'equal', /** @property {string} equal Equal to */\n\t\n\t  'ge': 'moreEqual', /** @property {string} geq Alias for `moreEqual` */\n\t  'geq': 'moreEqual', /** @property {string} geq Alias for `moreEqual` */\n\t  '>=': 'moreEqual', /** @property {string} _geq (actually **>=** sign). Alias for `moreEqual` */\n\t  'moreEqual': 'moreEqual', /** @property {string} moreEqual Greater than or equal */\n\t\n\t  'le': 'lessEqual', /** @property {string} leq Alias for `lessEqual` */\n\t  'leq': 'lessEqual', /** @property {string} leq Alias for `lessEqual` */\n\t  '<=': 'lessEqual', /** @property {string} _leq (actually **<=** sign). Alias for `lessEqual` */\n\t  'lessEqual': 'lessEqual', /** @property {string} lessEqual Less than or equal */\n\t\n\t  'ne': 'notEqual', /** @property {string} neq Alias for `notEqual` */\n\t  'neq': 'notEqual', /** @property {string} neq Alias for `notEqual` */\n\t  '<>': 'notEqual', /** @property {string} _neq1 (actually **<>** sign). Alias for `notEqual` */\n\t  '!=': 'notEqual', /** @property {string} _neq2 (actually **!=** sign). Alias for `notEqual` */\n\t  '!==': 'notEqual', /** @property {string} _neq3 (actually **!==** sign). Alias for `notEqual` */\n\t  'notEqual': 'notEqual', /** @property {string} notEqual Not equal */\n\t\n\t  'contains': 'like', /** @property {string} contains Alias for `like` */\n\t  'like': 'like', /** @property {string} like Like condition. For `String` type attribute only */\n\t\n\t  'notContains': 'notLike', /** @property {string} notContains Alias for `notLike` */\n\t  'notLike': 'notLike', /** @property {string} notLike Not like condition. For `String` type attribute only */\n\t\n\t  'isNull': 'isNull', /** @property {string} isNull Is null */\n\t  'null': 'isNull', /** @property {string} null Alias for `isNull` */\n\t\n\t  'notNull': 'notIsNull', /** @property {string} notNull Alias for `notIsNull` */\n\t  'notIsNull': 'notIsNull', /** @property {string} notIsNull Not is null */\n\t  'isNotNull': 'notIsNull', /** @property {string} isNotNull Alias for `notIsNull` */\n\t\n\t  'beginWith': 'startWith', /** @property {string} beginWith Alias for `startWith` */\n\t  'startWith': 'startWith', /** @property {string} startWith Start with. For `String` type attribute only */\n\t  'startsWith': 'startWith', /** @property {string} startsWith Alias for `startWith` */\n\t  'startswith': 'startWith', /** @property {string} startwith Alias for `startWith` */\n\t\n\t  'notBeginWith': 'notStartWith', /** @property {string} notBeginWith Alias for `notStartWith` */\n\t  'notStartWith': 'notStartWith', /** @property {string} notStartWith Not start with. For `String` type attribute only */\n\t  'notStartsWith': 'notStartWith', /** @property {string} notStartWith Alias for `notStartWith` */\n\t\n\t  'includes': 'in', /** @property {string} includes Alias for `in` */\n\t  'in': 'in', /** @property {string} in One of. Can accept array of string on array of Int/Int64 as values depending on attribute type. */\n\t\n\t  'notIncludes': 'notIn', /** @property {string} notIncludes Alias for `notIn` */\n\t  'notIn': 'notIn', /** @property {string} notIn Not one of. See WhereCondition.in for details */\n\t\n\t  'match': 'match', /** @property {string} match For entities with FTS mixin enabled. TODO - expand */\n\t\n\t  'subquery': 'subquery', /** @property {string} subquery Execute a sub-query passed in values. Better to use 'in' condition with Repository as a values parameter or a CustomRepository.exists method */\n\t  'exists': 'subquery', /** @property {string} exists Execute a exists(sub-query) passed in values. Better to use CustomRepository.exists method */\n\t  'notExists': 'subquery', /** @property {string} exists Execute a not exists(sub-query) passed in values. Better to use CustomRepository.notExists method */\n\t\n\t  'custom': 'custom' /** @property {string} custom Custom condition. For Server-side call only. For this condition `expression` can be any SQL statement */\n\t};\n\t\n\t/**\r\n\t * Abstract Custom repository (extended by serverRepository & ClientRepository)\r\n\t * @type {CustomRepository}\r\n\t */\n\tmodule.exports = CustomRepository;\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\r\n\t * UnityBase domain object model.\r\n\t * The main class {@link UBDomain}:\r\n\t *\r\n\t *  - for the server & CLI it is a result of {@link UBConnection.getDomainInfo connection.getDomainInfo} call\r\n\t *  - for browser side instance of UBDomain is a `domain` property of connection object\r\n\t *\r\n\t * Information about domain is used in many aspects of UnityBase:\r\n\t *\r\n\t *  - database generation\r\n\t *  - documentation generation\r\n\t *  - forms genetarion\r\n\t *  - views generation etc.\r\n\t *\r\n\t * @module @unitybase/base/UBDomain\r\n\t */\n\t\n\tvar _ = __webpack_require__(3);\n\t\n\t/**\r\n\t * Database connection config (w/o credential)\r\n\t * @typedef {Object} DBConnectionConfig\r\n\t * @property {string} name\r\n\t * @property {string} dialect\r\n\t * @property {Array<string>} supportLang\r\n\t * @property {string} advSettings database specific settings\r\n\t */\n\t\n\t/**\r\n\t * @classdesc\r\n\t * UnityBase domain object model.\r\n\t * Construct new UBDomain instance based on getDomainInfo UB server method result\r\n\t *\r\n\t * Usage sample:\r\n\t *\r\n\t *     // retrieve a localized caption of uba_user.name attribute\r\n\t *     domain.get('uba_user').attr('name').caption\r\n\t *\r\n\t * @class\r\n\t * @param {Object} domainInfo getDomainInfo UB server method result\r\n\t * @param {Object} domainInfo.domain raw entities collection\r\n\t * @param {Object} domainInfo.entityMethods entities methods access rights for current user\r\n\t * @param {Object} domainInfo.models information about domain models\r\n\t * @param {Object} domainInfo.i18n entities localization to current user language\r\n\t * @param {Object} domainInfo.forceMIMEConvertors list of registered server-side MIME converters for document type attribute content\r\n\t */\n\tfunction UBDomain(domainInfo) {\n\t  var me = this;\n\t  var entityCodes = Object.keys(domainInfo.domain);\n\t  var isV4API = typeof domainInfo.entityMethods === 'undefined';\n\t  /**\r\n\t   * Hash of entities. Keys is entity name, value is UBEntity\r\n\t   * @type {Object<String, UBEntity>}\r\n\t   */\n\t  this.entities = {};\n\t  /**\r\n\t   * Connection collection (for extended domain info only).\r\n\t   * @type {Array<DBConnectionConfig>}\r\n\t   */\n\t  this.connections = domainInfo['connections'];\n\t  entityCodes.forEach(function (entityCode) {\n\t    if (isV4API) {\n\t      var entity = domainInfo.domain[entityCode];\n\t      me.entities[entityCode] = new UBEntity(entity, entity.entityMethods || {}, entity.i18n, entityCode, me);\n\t    } else {\n\t      me.entities[entityCode] = new UBEntity(domainInfo.domain[entityCode], domainInfo.entityMethods[entityCode] || {}, domainInfo.i18n[entityCode], entityCode, me);\n\t    }\n\t  });\n\t\n\t  /**\r\n\t   * Models collection\r\n\t   * @type {Object<String, UBModel>}\r\n\t   */\n\t  this.models = {};\n\t  var modelCodes = Object.keys(domainInfo.models);\n\t  modelCodes.forEach(function (modelCode) {\n\t    var m = domainInfo.models[modelCode];\n\t    me.models[modelCode] = new UBModel(m.path, m.needInit, m.needLocalize, m.order);\n\t  });\n\t\n\t  /**\r\n\t   *\r\n\t   * @type {Object}\r\n\t   * @readonly\r\n\t   */\n\t  this.forceMIMEConvertors = domainInfo.forceMIMEConvertors;\n\t}\n\t\n\t/**\r\n\t * Check all provided entity methods are accessible via RLS.\r\n\t *\r\n\t * If entity does not exist in domain or at last one of provided methods is not accessible - return false\r\n\t *\r\n\t * @param {String} entityCode\r\n\t * @param {String|Array} methodNames\r\n\t */\n\tUBDomain.prototype.isEntityMethodsAccessible = function (entityCode, methodNames) {\n\t  var entity = this.entities[entityCode];\n\t  if (!entity) return false;\n\t  return Array.isArray(methodNames) ? entity.haveAccessToMethods(methodNames) : entity.haveAccessToMethod(methodNames);\n\t};\n\t/**\r\n\t * Get entity by code\r\n\t * @param {String} entityCode\r\n\t * @param {Boolean} [raiseErrorIfNotExists=true] If `true`(default) and entity does not exists throw error\r\n\t * @returns {UBEntity}\r\n\t */\n\tUBDomain.prototype.get = function (entityCode, raiseErrorIfNotExists) {\n\t  var result = this.entities[entityCode];\n\t  if (raiseErrorIfNotExists !== false && !result) {\n\t    throw new Error('Entity with code \"' + entityCode + '\" does not exists or not accessible');\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\r\n\t * Check entity present in domain & user has access right for at least one entity method\r\n\t * @param {String} entityCode\r\n\t * @returns {Boolean}\r\n\t */\n\tUBDomain.prototype.has = function (entityCode) {\n\t  return !!this.entities[entityCode];\n\t};\n\t\n\t/**\r\n\t * Iterates over domain entities and invokes `callBack` for each entity.\r\n\t * The iteratee is invoked with three arguments: (UBEntity, entityName, UBDomain.entities)\r\n\t * @param {Function} callBack\r\n\t */\n\tUBDomain.prototype.eachEntity = function (callBack) {\n\t  return _.forEach(this.entities, callBack);\n\t};\n\t\n\t/**\r\n\t * Filter entities by properties\r\n\t * @example\r\n\t *\r\n\t *      // sessionCachedEntites contains all entities with property cacheType equal Session\r\n\t *      var sessionCachedEntites = domain.filterEntities({cacheType: 'Session'});\r\n\t *\r\n\t * @param {Object|Function} config\r\n\t * @returns {Array}\r\n\t */\n\tUBDomain.prototype.filterEntities = function (config) {\n\t  if (_.isFunction(config)) {\n\t    return _.filter(this.entities, config);\n\t  } else {\n\t    return _.filter(this.entities, function (item) {\n\t      var res = true;\n\t      for (var prop in config) {\n\t        if (config.hasOwnProperty(prop)) {\n\t          res = res && item[prop] === config[prop];\n\t        }\n\t      }\n\t      return res;\n\t    });\n\t  }\n\t};\n\t\n\t/**\r\n\t * UnityBase base attribute data types\r\n\t * @readonly\r\n\t * @enum\r\n\t */\n\tUBDomain.ubDataTypes = {\n\t  /** Small string. MSSQL: NVARCHAR, ORACLE: NVARCHAR2, POSTGRE: VARCHAR */\n\t  String: 'String',\n\t  /** 32-bite Integer. MSSQL: INT, ORACLE: INTEGER, POSTGRE: INTEGER */\n\t  Int: 'Int',\n\t  /** 64-bite Integer. MSSQL: BIGINT, ORACLE: NUMBER(19), POSTGRE: BIGINT */\n\t  BigInt: 'BigInt',\n\t  /** Double. MSSQL: FLOAT, ORACLE: NUMBER(19, 4), POSTGRE: NUMERIC(19, 4) */\n\t  Float: 'Float',\n\t  /** Currency. MSSQL: FLOAT, ORACLE: NUMBER(19, 2), POSTGRE: NUMERIC(19, 2) */\n\t  Currency: 'Currency',\n\t  /** Boolean. MSSQL: TINYINT, ORACLE: NUMBER(1), POSTGRE: SMALLINT */\n\t  Boolean: 'Boolean',\n\t  /** Date + Time in UTC (GMT+0) timezone. MSSQL: DATETIME, OARCLE: DATE, POSTGRE: TIMESTAMP WITH TIME ZONE */\n\t  DateTime: 'DateTime',\n\t  /** Long strint. MSSQL: NVARCHAR(MAX), ORACLE: CLOB, POSTGRE: TEXT */\n\t  Text: 'Text',\n\t  /** Alias for BigInt */\n\t  ID: 'ID',\n\t  /** Reference to enother entity. BigInt */\n\t  Entity: 'Entity',\n\t  /** Store a JSON with information about Document place in blob store */\n\t  Document: 'Document',\n\t  Many: 'Many',\n\t  /**  Seconds since UNIX epoch, Int64. MSSQL: BIGINT, ORACLE: NUMBER(19), POSTGRE: BIGINT */\n\t  TimeLog: 'TimeLog',\n\t  /** Enumertion (see ubm_enum) */\n\t  Enum: 'Enum',\n\t  /** Bynary data. MSSQL: VARBINARY(MAX), ORACLE: BLOB, POSTGRE: BYTEA */\n\t  BLOB: 'BLOB',\n\t  /** Date (without time) in UTC (GMT+0) */\n\t  Date: 'Date'\n\t};\n\t\n\tUBDomain.prototype.ubDataTypes = UBDomain.ubDataTypes;\n\t\n\t/**\r\n\t * Types of expressions in attribute mapping\r\n\t * @readonly\r\n\t * @enum\r\n\t */\n\tUBDomain.ExpressionType = {\n\t  Field: 'Field',\n\t  Expression: 'Expresion'\n\t};\n\t\n\t/**\r\n\t * UnityBase base mixins\r\n\t * @readonly\r\n\t * @enum\r\n\t */\n\tUBDomain.ubMixins = {\n\t  dataHistory: 'dataHistory',\n\t  mStorage: 'mStorage',\n\t  unity: 'unity',\n\t  treePath: 'treePath'\n\t};\n\t\n\t/**\r\n\t * Service attribute names\r\n\t * @readonly\r\n\t * @enum\r\n\t */\n\tUBDomain.ubServiceFields = {\n\t  dateFrom: 'mi_datefrom',\n\t  dateTo: 'mi_dateto'\n\t};\n\t\n\t/**\r\n\t * Entity dataSource types\r\n\t * @enum {String}\r\n\t * @readonly\r\n\t */\n\tUBDomain.EntityDataSourceType = {\n\t  Normal: 'Normal',\n\t  External: 'External',\n\t  System: 'System',\n\t  Virtual: 'Virtual'\n\t};\n\t\n\t/**\r\n\t * @enum\r\n\t */\n\tUBDomain.EntityCacheTypes = {\n\t  None: 'None',\n\t  Entity: 'Entity',\n\t  Session: 'Session',\n\t  SessionEntity: 'SessionEntity'\n\t};\n\t\n\t/**\r\n\t * Priority to apply a mapping of a attributes/entities to the physical tables depending of connection dialect\r\n\t */\n\tUBDomain.dialectsPriority = {\n\t  MSSQL2012: ['MSSQL2012', 'MSSQL', 'AnsiSQL'],\n\t  MSSQL2008: ['MSSQL2008', 'MSSQL', 'AnsiSQL'],\n\t  MSSQL: ['MSSQL', 'AnsiSQL'],\n\t  Oracle11: ['Oracle11', 'Oracle', 'AnsiSQL'],\n\t  Oracle10: ['Oracle10', 'Oracle', 'AnsiSQL'],\n\t  Oracle9: ['Oracle9', 'Oracle', 'AnsiSQL'],\n\t  Oracle: ['Oracle', 'AnsiSQL'],\n\t  PostgreSQL: ['PostgreSQL', 'AnsiSQL'],\n\t  AnsiSQL: ['AnsiSQL'],\n\t  Firebird: ['Firebird', 'AnsiSQL'],\n\t  SQLite3: ['SQLite3', 'AnsiSQL']\n\t};\n\t\n\t/**\r\n\t * Return physical type by UBDataType\r\n\t * @param {String} dataType\r\n\t * @return {String}\r\n\t */\n\tUBDomain.getPhysicalDataType = function (dataType) {\n\t  var ubDataTypes = UBDomain.ubDataTypes;\n\t  var typeMap = {};\n\t\n\t  if (!this.physicalTypeMap) {\n\t    typeMap[ubDataTypes.Int] = 'int';\n\t    typeMap[ubDataTypes.Entity] = 'int';\n\t    typeMap[ubDataTypes.ID] = 'int';\n\t    typeMap[ubDataTypes.BigInt] = 'int';\n\t\n\t    typeMap[ubDataTypes.String] = 'string';\n\t    typeMap[ubDataTypes.Text] = 'string';\n\t    typeMap[ubDataTypes.Enum] = 'string';\n\t\n\t    typeMap[ubDataTypes.Float] = 'float';\n\t    typeMap[ubDataTypes.Currency] = 'float';\n\t\n\t    typeMap[ubDataTypes.Boolean] = 'boolean';\n\t\n\t    typeMap[ubDataTypes.Date] = 'date';\n\t    typeMap[ubDataTypes.DateTime] = 'date';\n\t\n\t    this.physicalTypeMap = typeMap;\n\t  }\n\t  return this.physicalTypeMap[dataType] || 'auto';\n\t};\n\t\n\t/**\r\n\t * Model (logical group of entities)\r\n\t * @class\r\n\t * @param path\r\n\t * @param needInit\r\n\t * @param needLocalize\r\n\t * @param order\r\n\t */\n\tfunction UBModel(path, needInit, needLocalize, order) {\n\t  this.path = path;\n\t  if (needInit) {\n\t    /**\r\n\t     * `initModel.js` script is available in the public folder (should be injected by client)\r\n\t     * @type {boolean}\r\n\t     */\n\t    this.needInit = needInit;\n\t  }\n\t  if (needLocalize) {\n\t    /**\r\n\t     * `locale-Lang.js` script is available in the public folder (should be injected by client)\r\n\t     * @type {boolean}\r\n\t     */\n\t    this.needLocalize = needLocalize;\n\t  }\n\t  /**\r\n\t   * An odred of model initialization (as it is provided in server domain config)\r\n\t   * @type {number}\r\n\t   */\n\t  this.order = order;\n\t}\n\tUBModel.prototype.needInit = false;\n\tUBModel.prototype.needLocalize = false;\n\t\n\t/**\r\n\t * Collection of attributes\r\n\t * @class\r\n\t */\n\tfunction UBEntityAttributes() {}\n\t/**\r\n\t * Return a JSON representation of all entity attributes\r\n\t * @returns {{}}\r\n\t */\n\tUBEntityAttributes.prototype.asJSON = function () {\n\t  var result = {};\n\t  _.forEach(this, function (prop, propName) {\n\t    if (prop.asJSON) {\n\t      result[propName] = prop.asJSON();\n\t    } else {\n\t      result[propName] = prop;\n\t    }\n\t  });\n\t  return result;\n\t};\n\t\n\t/** @class */\n\tfunction UBEntityMapping(maping) {\n\t  /**\r\n\t   * @type {string}\r\n\t   */\n\t  this.selectName = maping.selectName || '';\n\t  /** @type {string} */\n\t  this.execName = maping.execName || this.selectName;\n\t  /** @type {string} */\n\t  this.pkGenerator = maping.pkGenerator;\n\t}\n\t\n\t/**\r\n\t * @class\r\n\t * @param {Object} entityInfo\r\n\t * @param {Object} entityMethods\r\n\t * @param {Object} i18n\r\n\t * @param {String} entityCode\r\n\t * @param {UBDomain} domain\r\n\t */\n\tfunction UBEntity(entityInfo, entityMethods, i18n, entityCode, domain) {\n\t  var me = this;\n\t  var mixinNames = void 0,\n\t      mixinInfo = void 0,\n\t      i18nMixin = void 0,\n\t      dialectProiority = void 0;\n\t\n\t  if (i18n) {\n\t    _.merge(entityInfo, i18n);\n\t  }\n\t  /**\r\n\t   * @type {UBDomain}\r\n\t   * @readonly\r\n\t   */\n\t  this.domain = domain;\n\t\n\t  /**\r\n\t   * @type {String}\r\n\t   * @readonly\r\n\t   */\n\t  this.code = entityCode;\n\t  /**\r\n\t   * Entity model name\r\n\t   * @type{String}\r\n\t   * @readonly\r\n\t   */\n\t  this.modelName = entityInfo.modelName;\n\t  /**\r\n\t   * Entity name\r\n\t   * @type {String}\r\n\t   * @readonly\r\n\t   */\n\t  this.name = entityInfo.name;\n\t\n\t  if (entityInfo.caption) this.caption = entityInfo.caption;\n\t  if (entityInfo.description) this.description = entityInfo.description;\n\t  if (entityInfo.documentation) this.documentation = entityInfo.documentation;\n\t  if (entityInfo.descriptionAttribute) this.descriptionAttribute = entityInfo.descriptionAttribute;\n\t  if (entityInfo.cacheType) this.cacheType = entityInfo.cacheType;\n\t  if (entityInfo.dsType) this.dsType = entityInfo.dsType;\n\t\n\t  /**\r\n\t   * Internal short alias\r\n\t   * @type {String}\r\n\t   * @readonly\r\n\t   */\n\t  this.sqlAlias = entityInfo.sqlAlias;\n\t  /**\r\n\t   * Data source connection name\r\n\t   * @type {String}\r\n\t   * @readonly\r\n\t   */\n\t  this.connectionName = entityInfo.connectionName;\n\t  /**\r\n\t   * This is a Full Text Search entity\r\n\t   * @type {boolean}\r\n\t   */\n\t  this.isFTSDataTable = entityInfo.isFTSDataTable === true;\n\t\n\t  /**\r\n\t   * Reference to connection definition (for extended domain only)\r\n\t   * @type {DBConnectionConfig}\r\n\t   * @readonly\r\n\t   */\n\t  this.connectionConfig = this.connectionName && this.domain.connections ? _.find(this.domain.connections, { name: this.connectionName }) : undefined;\n\t  /**\r\n\t   * Optional mapping of entity to physical data (for extended domain info only).\r\n\t   * Calculated from a entity mapping collection in accordance with application connection configuration\r\n\t   * @type {UBEntityMapping}\r\n\t   * @readonly\r\n\t   */\n\t  this.mapping = undefined;\n\t\n\t  if (entityInfo.mapping && Object.keys(entityInfo.mapping).length) {\n\t    dialectProiority = UBDomain.dialectsPriority[this.connectionConfig.dialect];\n\t    _.forEach(dialectProiority, function (dialect) {\n\t      if (entityInfo.mapping[dialect]) {\n\t        me.mapping = new UBEntityMapping(entityInfo.mapping[dialect]);\n\t        return false;\n\t      }\n\t    });\n\t  }\n\t\n\t  /**\r\n\t   * Optional dbKeys (for extended domain info)\r\n\t   * @type {Object}\r\n\t   */\n\t  this.dbKeys = entityInfo.dbKeys && Object.keys(entityInfo.dbKeys).length ? entityInfo.dbKeys : undefined;\n\t  /**\r\n\t   * Optional dbExtensions (for extended domain info)\r\n\t   * @type {Object}\r\n\t   */\n\t  this.dbExtensions = entityInfo.dbExtensions && Object.keys(entityInfo.dbExtensions).length ? entityInfo.dbExtensions : undefined;\n\t\n\t  /**\r\n\t   * Entity attributes collection\r\n\t   * @type {Object<string, UBEntityAttribute>}\r\n\t   */\n\t  this.attributes = new UBEntityAttributes();\n\t  _.forEach(entityInfo.attributes, function (attributeInfo, attributeCode) {\n\t    me.attributes[attributeCode] = new UBEntityAttribute(attributeInfo, attributeCode, me);\n\t  });\n\t\n\t  mixinNames = Object.keys(entityInfo.mixins || {});\n\t  /**\r\n\t   * Collection of entity mixins\r\n\t   * @type {Object<String, UBEntityMixin>}\r\n\t   */\n\t  this.mixins = {};\n\t  mixinNames.forEach(function (mixinCode) {\n\t    mixinInfo = entityInfo.mixins[mixinCode];\n\t    i18nMixin = i18n && i18n.mixins ? i18n.mixins[mixinCode] : null;\n\t    switch (mixinCode) {\n\t      case 'mStorage':\n\t        me.mixins[mixinCode] = new UBEntityStoreMixin(mixinInfo, i18nMixin, mixinCode);\n\t        break;\n\t      case 'dataHistory':\n\t        me.mixins[mixinCode] = new UBEntityHistoryMixin(mixinInfo, i18nMixin, mixinCode);\n\t        break;\n\t      case 'aclRls':\n\t        me.mixins[mixinCode] = new UBEntityAclRlsMixin(mixinInfo, i18nMixin, mixinCode);\n\t        break;\n\t      case 'fts':\n\t        me.mixins[mixinCode] = new UBEntityFtsMixin(mixinInfo, i18nMixin, mixinCode);\n\t        break;\n\t      case 'als':\n\t        me.mixins[mixinCode] = new UBEntityAlsMixin(mixinInfo, i18nMixin, mixinCode);\n\t        break;\n\t      default:\n\t        me.mixins[mixinCode] = new UBEntityMixin(mixinInfo, i18nMixin, mixinCode);\n\t    }\n\t  });\n\t  /**\r\n\t   * Entity methods, allowed for current logged-in user in format {method1: 1, method2: 1}. 1 mean method is allowed\r\n\t   * @type {Object<String, Number>}\r\n\t   * @readOnly\r\n\t   */\n\t  this.entityMethods = entityMethods || {};\n\t}\n\t\n\t/**\r\n\t * Entity caption\r\n\t * @type {string}\r\n\t */\n\tUBEntity.prototype.caption = '';\n\t/**\r\n\t * Entity description\r\n\t * @type {string}\r\n\t */\n\tUBEntity.prototype.description = '';\n\t/**\r\n\t * Documentation\r\n\t * @type {string}\r\n\t */\n\tUBEntity.prototype.documentation = '';\n\t/**\r\n\t * Name of attribute witch used as a display value in lookup\r\n\t * @type {string}\r\n\t */\n\tUBEntity.prototype.descriptionAttribute = '';\n\t\n\t/**\r\n\t * Indicate how entity content is cached on the client side.\r\n\t *\r\n\t * @type {UBDomain.EntityCacheTypes}\r\n\t * @readonly\r\n\t */\n\tUBEntity.prototype.cacheType = 'None';\n\t\n\t/**\r\n\t *\r\n\t * @type {UBDomain.EntityDataSourceType}\r\n\t */\n\tUBEntity.prototype.dsType = 'Normal';\n\t\n\t/**\r\n\t * Return an entity caption to display on UI\r\n\t * @returns {string}\r\n\t */\n\tUBEntity.prototype.getEntityCaption = function () {\n\t  return this.caption || this.description;\n\t};\n\t\n\t/**\r\n\t * Get entity attribute by code. Return undefined if attribute does not found\r\n\t * @param {String} attributeCode\r\n\t * @param {Boolean} [simple] Is do not complex attribute name. By default false.\r\n\t * @returns {UBEntityAttribute}\r\n\t */\n\tUBEntity.prototype.attr = function (attributeCode, simple) {\n\t  var res = this.attributes[attributeCode];\n\t  if (!res && !simple) {\n\t    res = this.getEntityAttribute(attributeCode);\n\t  }\n\t  return res;\n\t};\n\t\n\t/**\r\n\t * Get entity attribute by code. Throw error if attribute does not found.\r\n\t * @param attributeCode\r\n\t * @returns {UBEntityAttribute}\r\n\t */\n\tUBEntity.prototype.getAttribute = function (attributeCode) {\n\t  var attr = this.attributes[attributeCode];\n\t  if (!attr) {\n\t    throw new Error('Attribute ' + this.code + '.' + attributeCode + ' doesn\\'t exist');\n\t  }\n\t  return attr;\n\t};\n\t\n\t/**\r\n\t * Call callBack function for each attribute.\r\n\t * @param {Function} callBack\r\n\t */\n\tUBEntity.prototype.eachAttribute = function (callBack) {\n\t  return _.forEach(this.attributes, callBack);\n\t};\n\t\n\t/**\r\n\t * Get entity mixin by code. Returns \"undefined\" if the mixin is not found\r\n\t * @param {String} mixinCode\r\n\t * @returns {UBEntityMixin}\r\n\t */\n\tUBEntity.prototype.mixin = function (mixinCode) {\n\t  return this.mixins[mixinCode];\n\t};\n\t\n\t/**\r\n\t * Check the entity has mixin. Returns `true` if the mixin is exist and enabled\r\n\t * @param {String} mixinCode\r\n\t * @returns {Boolean}\r\n\t */\n\tUBEntity.prototype.hasMixin = function (mixinCode) {\n\t  var mixin = this.mixins[mixinCode];\n\t  if (mixinCode === 'audit') {\n\t    return !mixin || !!mixin && mixin.enabled;\n\t  }\n\t  return !!mixin && mixin.enabled;\n\t};\n\t\n\t/**\r\n\t * Check the entity has mixin. Throw error if mixin dose not exist or not enabled\r\n\t * @param {String} mixinCode\r\n\t */\n\tUBEntity.prototype.checkMixin = function (mixinCode) {\n\t  if (!this.hasMixin(mixinCode)) {\n\t    throw new Error('Entity ' + this.code + ' does not have mixin ' + mixinCode);\n\t  }\n\t};\n\t\n\tUBEntity.prototype.asJSON = function () {\n\t  var result = { code: this.code };\n\t  _.forEach(this, function (prop, propName) {\n\t    if (propName === 'domain') {\n\t      return;\n\t    }\n\t    if (prop.asJSON) {\n\t      result[propName] = prop.asJSON();\n\t    } else {\n\t      result[propName] = prop;\n\t    }\n\t  });\n\t  return result;\n\t};\n\t\n\t/**\r\n\t * Check current user have access to specified entity method\r\n\t * @param {String} methodCode\r\n\t * @returns {Boolean}\r\n\t */\n\tUBEntity.prototype.haveAccessToMethod = function (methodCode) {\n\t  return this.entityMethods[methodCode] === 1;\n\t};\n\t\n\t/**\r\n\t * Filter attributes by properties\r\n\t * @param {Object|Function} config\r\n\t * @returns {Array}\r\n\t * example\r\n\t *\r\n\t *      domain.get('uba_user').filterAttribute({dataType: 'Document'});\r\n\t *\r\n\t *   return all attributes where property dataType equal Document\r\n\t */\n\tUBEntity.prototype.filterAttribute = function (config) {\n\t  if (_.isFunction(config)) {\n\t    return _.filter(this.attributes, config);\n\t  } else {\n\t    return _.filter(this.attributes, function (item) {\n\t      var res = true;\n\t      for (var prop in config) {\n\t        if (config.hasOwnProperty(prop)) {\n\t          res = res && item[prop] === config[prop];\n\t        }\n\t      }\n\t      return res;\n\t    });\n\t  }\n\t};\n\t\n\t/**\r\n\t * Check current user have access to AT LAST one of specified methods\r\n\t * @param {Array} methods\r\n\t * @returns {boolean}\r\n\t */\n\tUBEntity.prototype.haveAccessToAnyMethods = function (methods) {\n\t  var me = this;\n\t  var fMethods = methods || [];\n\t  var result = false;\n\t\n\t  fMethods.forEach(function (methodCode) {\n\t    result = result || me.entityMethods[methodCode] === 1;\n\t  });\n\t  return result;\n\t};\n\t\n\t/**\r\n\t * Check current user have access to ALL of specified methods\r\n\t * @param {Array<String>} methods Method names\r\n\t * @returns {Boolean}\r\n\t */\n\tUBEntity.prototype.haveAccessToMethods = function (methods) {\n\t  var me = this;\n\t  var result = true;\n\t  var fMethods = methods || [];\n\t\n\t  fMethods.forEach(function (methodCode) {\n\t    result = result && me.entityMethods[methodCode] === 1;\n\t  });\n\t  return result;\n\t};\n\t\n\t/**\r\n\t * Convert UnityBase server dateTime response to Date object\r\n\t * @private\r\n\t * @param value\r\n\t * @returns {Date}\r\n\t */\n\tfunction iso8601Parse(value) {\n\t  return value ? new Date(value) : null;\n\t}\n\t\n\t/**\r\n\t * Convert UnityBase server date response to Date object.\r\n\t * date response is a day with 00 time (2015-07-17T00:00Z), to get a real date we must add current timezone shift\r\n\t * @private\r\n\t * @param value\r\n\t * @returns {Date}\r\n\t */\n\tfunction iso8601ParseAsDate(value) {\n\t  var res = value ? new Date(value) : null;\n\t  if (res) {\n\t    res.setTime(res.getTime() + res.getTimezoneOffset() * 60 * 1000);\n\t  }\n\t  return res;\n\t}\n\t\n\t/**\r\n\t * Convert UnityBase server Boolean response to Boolean (0 = false & 1 = trhe)\r\n\t * @private\r\n\t * @param v Value to convert\r\n\t * @returns {Boolean|null}\r\n\t */\n\tfunction booleanParse(v) {\n\t  if (typeof v === 'boolean') {\n\t    return v;\n\t  }\n\t  if (v === undefined || v === null || v === '') {\n\t    return null;\n\t  }\n\t  return v === 1;\n\t}\n\t\n\t/**\r\n\t * return array of conversion rules for raw server response data\r\n\t * @param {Array<String>} fieldList\r\n\t * @returns {Array<{index: number, convertFn: function}>}\r\n\t */\n\tUBEntity.prototype.getConvertRules = function (fieldList) {\n\t  var me = this;\n\t  var rules = [];\n\t  var types = UBDomain.ubDataTypes;\n\t\n\t  fieldList.forEach(function (fieldName, index) {\n\t    var attribute = me.attr(fieldName);\n\t    if (attribute) {\n\t      if (attribute.dataType === types.DateTime) {\n\t        rules.push({\n\t          index: index,\n\t          convertFn: iso8601Parse\n\t        });\n\t      } else if (attribute.dataType === types.Date) {\n\t        rules.push({\n\t          index: index,\n\t          convertFn: iso8601ParseAsDate\n\t        });\n\t      } else if (attribute.dataType === types.Boolean) {\n\t        rules.push({\n\t          index: index,\n\t          convertFn: booleanParse\n\t        });\n\t      }\n\t    }\n\t  });\n\t  return rules;\n\t};\n\t\n\t/**\r\n\t * Return description attribute name (`descriptionAttribute` metadata property)\r\n\t * This property may be empty or valid(validation performed by server)\r\n\t * If case property is empty - try to get attribute with code `caption`\r\n\t *\r\n\t * @return {String}\r\n\t */\n\tUBEntity.prototype.getDescriptionAttribute = function () {\n\t  var result = this.descriptionAttribute || 'caption';\n\t  if (!this.attr(result)) {\n\t    throw new Error('Missing description attribute for entity ' + this.code);\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\r\n\t * Return information about attribute and attribute entity. Understand complex attributes like firmID.firmType.code\r\n\t * @param {String} attributeName\r\n\t * @param {Number} [deep] If 0 - last, -1 - before last, > 0 - root. Default 0.\r\n\t * @return {{ entity: String, attribute: Object, attributeCode: String }}\r\n\t */\n\tUBEntity.prototype.getEntityAttributeInfo = function (attributeName, deep) {\n\t  var domainEntity = this;\n\t  var attributeNameParts = attributeName.split('.');\n\t  var currentLevel = -(attributeNameParts.length - 1);\n\t  var complexAttr = [];\n\t  var currentEntity = this.code;\n\t  /** @type UBEntityAttribute */\n\t  var attribute = void 0;\n\t  var key = void 0;\n\t\n\t  if (deep && deep > 0) {\n\t    return { entity: currentEntity, attribute: domainEntity.attr(attributeNameParts[0]), attributeCode: attributeNameParts[0] };\n\t  }\n\t\n\t  while (domainEntity && attributeNameParts.length) {\n\t    if (domainEntity && attributeNameParts.length === 1) {\n\t      complexAttr = attributeNameParts[0].split('@');\n\t      if (complexAttr.length > 1) {\n\t        domainEntity = this.domain.get(complexAttr[1]); // real entity is text after @\n\t        attributeName = complexAttr[0];\n\t      }\n\t      return { entity: currentEntity, attribute: domainEntity.attr(attributeName), attributeCode: attributeName };\n\t    }\n\t    key = attributeNameParts.shift();\n\t    complexAttr = key.split('@');\n\t    if (complexAttr.length > 1) {\n\t      currentEntity = complexAttr[1];\n\t      domainEntity = this.domain.get(currentEntity); // real entity is text after @\n\t      key = complexAttr[0];\n\t    }\n\t    attribute = domainEntity.attr(key);\n\t    if (attribute) {\n\t      // check that attribute exists in domainEntity\n\t      if (currentLevel === (deep || 0)) {\n\t        return { entity: currentEntity, attribute: attribute, attributeCode: key };\n\t      }\n\t      attributeName = attributeNameParts[0];\n\t      if (attribute.dataType === 'Enum' && attributeName === 'name') {\n\t        return { entity: currentEntity, attribute: attribute, attributeCode: key };\n\t      } else {\n\t        currentEntity = attribute.associatedEntity;\n\t        domainEntity = attribute.getAssociatedEntity();\n\t      }\n\t    } else {\n\t      return undefined;\n\t    }\n\t    currentLevel += 1;\n\t  }\n\t  return undefined;\n\t};\n\t\n\t/**\r\n\t * Return Entity attribute. Understand complex attributes like firmID.firmType.code\r\n\t * @param {String} attributeName\r\n\t * @param {Number} [deep] If 0 - last, -1 - before last, > 0 - root. Default 0.\r\n\t * @return {UBEntityAttribute}\r\n\t */\n\tUBEntity.prototype.getEntityAttribute = function (attributeName, deep) {\n\t  var domainEntity = this;\n\t  var attributeNameParts = attributeName.split('.');\n\t  var currentLevel = -(attributeNameParts.length - 1);\n\t  var complexAttr = [];\n\t  var attribute = void 0;\n\t  var key = void 0;\n\t\n\t  if (deep && deep > 0) {\n\t    return domainEntity.attributes[attributeNameParts[0]];\n\t  }\n\t\n\t  // TODO: Сделать так же для других спец.символов, кроме @\n\t  while (domainEntity && attributeNameParts.length) {\n\t    if (domainEntity && attributeNameParts.length === 1) {\n\t      complexAttr = attributeNameParts[0].split('@');\n\t      if (complexAttr.length > 1) {\n\t        domainEntity = this.domain.get(complexAttr[1]); // real entity is text after @\n\t        attributeName = complexAttr[0];\n\t      }\n\t      return domainEntity.attributes[attributeName];\n\t    }\n\t    key = attributeNameParts.shift();\n\t    complexAttr = key.split('@');\n\t    if (complexAttr.length > 1) {\n\t      domainEntity = this.domain.get(complexAttr[1]); // real entity is text after @\n\t      key = complexAttr[0];\n\t    }\n\t    attribute = domainEntity.attributes[key];\n\t    if (attribute) {\n\t      // check that attribute exists in domainEntity\n\t      if (currentLevel === (deep || 0)) {\n\t        return attribute;\n\t      }\n\t      attributeName = attributeNameParts[0];\n\t      if (attribute.dataType === 'Enum') {\n\t        if (attributeName === 'name') {\n\t          // WTF?\n\t          return attribute;\n\t        } else {\n\t          domainEntity = this.domain.get('ubm_enum');\n\t        }\n\t      } else {\n\t        domainEntity = this.domain.get(attribute.associatedEntity);\n\t      }\n\t    } else {\n\t      return undefined;\n\t    }\n\t    currentLevel += 1;\n\t  }\n\t  return undefined;\n\t};\n\t\n\t/**\r\n\t * return attributes code list\r\n\t * @param {Object|Function} [filter]\r\n\t * @returns String[]\r\n\t */\n\tUBEntity.prototype.getAttributeNames = function (filter) {\n\t  var attributes = [];\n\t  if (filter) {\n\t    _.forEach(this.filterAttribute(filter), function (attr) {\n\t      attributes.push(attr.code);\n\t    });\n\t    return attributes;\n\t  } else {\n\t    return Object.keys(this.attributes);\n\t  }\n\t};\n\t\n\t/**\r\n\t * Return requirements entity code list for field list\r\n\t * @param {String[]} [fieldList] (optional)\r\n\t * @return {String[]}\r\n\t */\n\tUBEntity.prototype.getEntityRequirements = function (fieldList) {\n\t  var result = [];\n\t\n\t  fieldList = fieldList || this.getAttributeNames();\n\t\n\t  for (var i = 0, len = fieldList.length; i < len; ++i) {\n\t    var fieldNameParts = fieldList[i].split('.');\n\t\n\t    var attr = this.getEntityAttribute(fieldNameParts[0]);\n\t    if (attr.dataType === 'Entity') {\n\t      if (fieldNameParts.length > 1) {\n\t        var tail = [fieldNameParts.slice(1).join('.')];\n\t        result = _.union(result, attr.getAssociatedEntity().getEntityRequirements(tail));\n\t      } else {\n\t        result = _.union(result, [attr.associatedEntity]);\n\t      }\n\t    }\n\t  }\n\t\n\t  return result;\n\t};\n\t\n\t/**\r\n\t * Check the entity contains attribute(s) and throw error if not contains\r\n\t * @param {String|Array<String>} attributeName\r\n\t * @param {String} contextMessage\r\n\t */\n\tUBEntity.prototype.checkAttributeExist = function (attributeName, contextMessage) {\n\t  var me = this;\n\t  attributeName = !_.isArray(attributeName) ? [attributeName] : attributeName;\n\t  _.forEach(attributeName, function (fieldName) {\n\t    if (!me.getEntityAttributeInfo(fieldName)) {\n\t      throw new Error(contextMessage + (contextMessage ? ' ' : '') + 'The entity \"' + me.code + '\" does not have attribute \"' + fieldName + '\"');\n\t    }\n\t  });\n\t};\n\t\n\t/**\r\n\t * Return entity description.\r\n\t * @returns {string}\r\n\t */\n\tUBEntity.prototype.getEntityDescription = function () {\n\t  return this.description || this.caption;\n\t};\n\t\n\t/** @class */\n\tfunction UBEntityAttributeMapping(maping) {\n\t  /**\r\n\t   * @type {UBDomain.ExpressionType}\r\n\t   */\n\t  this.expressionType = maping.expressionType;\n\t  /** @type {string} */\n\t  this.expression = maping.expression;\n\t}\n\t\n\t/**\r\n\t * @param {Object} attributeInfo\r\n\t * @param {String} attributeCode\r\n\t * @param {UBEntity} entity\r\n\t * @constructor\r\n\t */\n\tfunction UBEntityAttribute(attributeInfo, attributeCode, entity) {\n\t  // i18n already merged by entity constructor\n\t  /**\r\n\t   * @type {String}\r\n\t   * @readonly\r\n\t   */\n\t  this.code = attributeCode;\n\t  /** @type {String}\r\n\t  * @readonly\r\n\t  */\n\t  this.name = attributeInfo.name;\n\t  /**\r\n\t   * @type {UBEntity}\r\n\t   * @readonly\r\n\t   */\n\t  this.entity = entity;\n\t  /**\r\n\t   * Data type\r\n\t   * @type {UBDomain.ubDataTypes}\r\n\t   * @readonly\r\n\t   */\n\t  this.dataType = attributeInfo.dataType || 'String';\n\t  /**\r\n\t   * Название сущности, на которую ссылаемся (для adtMany сущность, на которую ссылаемся из AssociationManyData)\r\n\t   * @type {String}\r\n\t   * @readonly\r\n\t   */\n\t  this.associatedEntity = attributeInfo.associatedEntity;\n\t  /**\r\n\t   * @type {String}\r\n\t   * @readonly\r\n\t   */\n\t  this.associationAttr = attributeInfo.associationAttr;\n\t  /**\r\n\t   * @type {String}\r\n\t   * @readonly\r\n\t   */\n\t  this.caption = attributeInfo.caption || '';\n\t  /**\r\n\t   * @type {String}\r\n\t   * @readonly\r\n\t   */\n\t  this.description = attributeInfo.description || '';\n\t  /**\r\n\t   * @type {String}\r\n\t   * @readonly\r\n\t   */\n\t  this.documentation = attributeInfo.documentation || '';\n\t  /**\r\n\t   * @property {Number} size\r\n\t   * size\r\n\t   * @readonly\r\n\t   */\n\t  this.size = attributeInfo.size || 0;\n\t  /**\r\n\t   * Attribute value can be empty or null\r\n\t   * @type {boolean}\r\n\t   * @readonly\r\n\t   */\n\t  this.allowNull = attributeInfo.allowNull !== false;\n\t  /**\r\n\t  * Allow order by clause by this attribute\r\n\t  * @type {boolean}\r\n\t  * @readonly\r\n\t  */\n\t  this.allowSort = attributeInfo.allowSort !== false;\n\t  /**\r\n\t   * @type {boolean}\r\n\t   * @readonly\r\n\t   */\n\t  this.isUnique = attributeInfo.isUnique === true;\n\t  /**\r\n\t   * @type{String}\r\n\t   * @readonly\r\n\t   */\n\t  this.defaultValue = attributeInfo.defaultValue;\n\t  /**\r\n\t   * Allow edit\r\n\t   * @type {Boolean}\r\n\t   * @readonly\r\n\t   */\n\t  this.readOnly = attributeInfo.readOnly === true;\n\t  /**\r\n\t   * @property {Boolean}\r\n\t   * @readonly\r\n\t   */\n\t  this.isMultiLang = attributeInfo.isMultiLang === true;\n\t  /**\r\n\t   * Possible for dataType=Entity - enable cascade delete on application serve level (not on database level)\r\n\t   * @type {Boolean}\r\n\t   * @readonly\r\n\t   */\n\t  this.cascadeDelete = attributeInfo.cascadeDelete === true;\n\t  /**\r\n\t   * Required for dataType=Enum - Group code from ubm_enum.eGroup\r\n\t   * @property {String} enumGroup\r\n\t   * @readonly\r\n\t   */\n\t  this.enumGroup = attributeInfo.enumGroup;\n\t  /**\r\n\t   * @type {Object}\r\n\t   * @readonly\r\n\t   */\n\t  this.customSettings = attributeInfo.customSettings || {};\n\t  /**\r\n\t   * Required for dataType=Many - name of the many-to-many table. UB create system entity with this name and generate table during DDL generation\r\n\t   * @property {String}\r\n\t   * @readonly\r\n\t   */\n\t  this.associationManyData = attributeInfo.associationManyData;\n\t  /**\r\n\t   * Applicable to attribute with dataType=Document - name of store from storeConfig application config section. If emtpy - store with isDefault=true will be used\r\n\t   * @type{String}\r\n\t   * @readonly\r\n\t   */\n\t  this.storeName = attributeInfo.storeName;\n\t  /**\r\n\t   * Applicable for dataType=Entity. If false DDL generator will bypass foreign key generation on the database level\r\n\t   * @type {boolean}\r\n\t   */\n\t  this.generateFK = attributeInfo.generateFK !== false;\n\t\n\t  /**\r\n\t   * If true - client should shows this attribute in auto-build forms and in '*' select fields\r\n\t   * @type {boolean}\r\n\t   */\n\t  this.defaultView = attributeInfo.defaultView !== false;\n\t\n\t  /**\r\n\t   * Optional mapping of atribute to phisical data (for extended domain info only).\r\n\t   * Calculated from a entity mapping collection in accordance with application connection confiduration\r\n\t   * @type {UBEntityAttributeMapping}\r\n\t   * @readonly\r\n\t   */\n\t  this.mapping = undefined;\n\t\n\t  var me = this;\n\t  if (attributeInfo.mapping && Object.keys(attributeInfo.mapping).length) {\n\t    var dialectsPriority = UBDomain.dialectsPriority[this.entity.connectionConfig.dialect];\n\t    _.forEach(dialectsPriority, function (dialect) {\n\t      if (attributeInfo.mapping[dialect]) {\n\t        me.mapping = new UBEntityAttributeMapping(attributeInfo.mapping[dialect]);\n\t        return false; // break loop\n\t      }\n\t    });\n\t  }\n\t\n\t  /**\r\n\t   * @property {String} physicalDataType\r\n\t   * @readonly\r\n\t   */\n\t  this.physicalDataType = UBDomain.getPhysicalDataType(this.dataType || 'String');\n\t}\n\t\n\t/**\r\n\t * Return associated entity. Return null if attribute type is not Entity.\r\n\t * @returns {UBEntity}\r\n\t */\n\tUBEntityAttribute.prototype.getAssociatedEntity = function () {\n\t  return this.associatedEntity ? this.entity.domain.get(this.associatedEntity) : null;\n\t};\n\t\n\tUBEntityAttribute.prototype.asJSON = function () {\n\t  var result = {};\n\t  _.forEach(this, function (prop, propName) {\n\t    if (propName === 'entity') {\n\t      return;\n\t    }\n\t    if (prop.asJSON) {\n\t      result[propName] = prop.asJSON();\n\t    } else {\n\t      result[propName] = prop;\n\t    }\n\t  });\n\t  return result;\n\t};\n\t\n\t/**\r\n\t * Contains all properties defined in mixin section of a entity metafile\r\n\t * @class\r\n\t * @protected\r\n\t * @param {Object} mixinInfo\r\n\t * @param {Object} i18n\r\n\t * @param {String} mixinCode\r\n\t */\n\tfunction UBEntityMixin(mixinInfo, i18n, mixinCode) {\n\t  /**\r\n\t   * Mixin code\r\n\t   * @type {String}\r\n\t   */\n\t  this.code = mixinCode;\n\t  _.assign(this, mixinInfo);\n\t  if (i18n) {\n\t    _.assign(this, i18n);\n\t  }\n\t}\n\t\n\tUBEntityMixin.prototype.enabled = true;\n\t\n\t/**\r\n\t * Mixin for persisting entity to a database\r\n\t * @class\r\n\t * @extends UBEntityMixin\r\n\t * @param mixinInfo\r\n\t * @param i18n\r\n\t * @param mixinCode\r\n\t */\n\tfunction UBEntityStoreMixin(mixinInfo, i18n, mixinCode) {\n\t  UBEntityMixin.apply(this, arguments);\n\t}\n\tUBEntityStoreMixin.prototype = Object.create(UBEntityMixin.prototype);\n\tUBEntityStoreMixin.prototype.constructor = UBEntityStoreMixin;\n\t// defaults\n\t/**\r\n\t * Is `simpleAudit` enabled\r\n\t * @type {boolean}\r\n\t */\n\tUBEntityStoreMixin.prototype.simpleAudit = false;\n\t/**\r\n\t * Use a soft delete\r\n\t * @type {boolean}\r\n\t */\n\tUBEntityStoreMixin.prototype.safeDelete = false;\n\t\n\t/**\r\n\t * Historical data storage mixin\r\n\t * @class\r\n\t * @extends UBEntityMixin\r\n\t * @param mixinInfo\r\n\t * @param i18n\r\n\t * @param mixinCode\r\n\t * @constructor\r\n\t */\n\tfunction UBEntityHistoryMixin(mixinInfo, i18n, mixinCode) {\n\t  UBEntityMixin.apply(this, arguments);\n\t}\n\tUBEntityHistoryMixin.prototype = Object.create(UBEntityMixin.prototype);\n\tUBEntityHistoryMixin.prototype.constructor = UBEntityHistoryMixin;\n\t/**\r\n\t * A history storage strategy\r\n\t * @type {string}\r\n\t */\n\tUBEntityHistoryMixin.prototype.historyType = 'common';\n\t/**\r\n\t * Access control list mixin\r\n\t * @class\r\n\t * @extends UBEntityMixin\r\n\t * @param mixinInfo\r\n\t * @param i18n\r\n\t * @param mixinCode\r\n\t */\n\tfunction UBEntityAclRlsMixin(mixinInfo, i18n, mixinCode) {\n\t  UBEntityMixin.apply(this, arguments);\n\t}\n\tUBEntityAclRlsMixin.prototype = Object.create(UBEntityMixin.prototype);\n\tUBEntityAclRlsMixin.prototype.constructor = UBEntityAclRlsMixin;\n\t// defaults\n\tUBEntityAclRlsMixin.prototype.aclRlsUseUnityName = false;\n\tUBEntityAclRlsMixin.prototype.aclRlsSelectionRule = 'exists';\n\t\n\t/**\r\n\t * Full text search mixin\r\n\t * @class\r\n\t * @extends UBEntityMixin\r\n\t * @param mixinInfo\r\n\t * @param i18n\r\n\t * @param mixinCode\r\n\t */\n\tfunction UBEntityFtsMixin(mixinInfo, i18n, mixinCode) {\n\t  UBEntityMixin.apply(this, arguments);\n\t}\n\tUBEntityFtsMixin.prototype = Object.create(UBEntityMixin.prototype);\n\tUBEntityFtsMixin.prototype.constructor = UBEntityFtsMixin;\n\t/**\r\n\t * scope\r\n\t * @type {string}\r\n\t */\n\tUBEntityFtsMixin.prototype.scope = 'connection'; // sConnection\n\t/**\r\n\t * Data provider type\r\n\t * @type {string}\r\n\t */\n\tUBEntityFtsMixin.prototype.dataProvider = 'mixin'; // dcMixin\n\t/**\r\n\t * Attribute level security mixin\r\n\t * @param mixinInfo\r\n\t * @param i18n\r\n\t * @param mixinCode\r\n\t * @constructor\r\n\t * @extends UBEntityMixin\r\n\t */\n\tfunction UBEntityAlsMixin(mixinInfo, i18n, mixinCode) {\n\t  UBEntityMixin.apply(this, arguments);\n\t}\n\tUBEntityAlsMixin.prototype = Object.create(UBEntityMixin.prototype);\n\tUBEntityAlsMixin.prototype.constructor = UBEntityAlsMixin;\n\t/**\r\n\t * Is optimistic\r\n\t * @type {boolean}\r\n\t */\n\tUBEntityAlsMixin.prototype.alsOptimistic = true;\n\t\n\tmodule.exports = UBDomain;\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\r\n\t * Internal class, returned as a result of {@link UBConnection#authorize UBConnection.authorize()}\r\n\t * @module @unitybase/base/UBSession\r\n\t */\n\t/*\r\n\t @author pavel.mash\r\n\t */\n\t\n\t/* global ncrc32 */\n\t\n\t// ***********   !!!!WARNING!!!!! **********************\n\t// Module shared between server and client code\n\t/**\r\n\t * Internal class, returned as a result of {@link UBConnection#authorize UBConnection.authorize()}\r\n\t * The main method is {@link UBSession.signature UBSession.signature()}\r\n\t *\r\n\t * Developer never create this class directly.\r\n\t * @class\r\n\t * @protected\r\n\t */\n\tfunction UBSession(authResponse, secretWord, authSchema) {\n\t  var data = authResponse;\n\t  var hexa8ID = hexa8(data.result.split('+')[0]);\n\t  var userData = data.uData ? JSON.parse(data.uData) : { lang: 'en', login: 'anonymous' };\n\t  var sessionWord = data.result;\n\t  var sessionPwdHash = secretWord || '';\n\t  var sessionSaltCRC = typeof window === 'undefined' ? ncrc32(0, sessionWord + sessionPwdHash) : null;\n\t\n\t  if (!userData.login) {\n\t    userData.login = data.logonname;\n\t  }\n\t\n\t  /** @property {String} sessionID user session id converted to {@link UBSession#hexa8}\r\n\t   * @protected\r\n\t   * @readonly\r\n\t   */\n\t  Object.defineProperty(this, 'sessionID', { enumerable: true, writable: false, value: hexa8ID });\n\t  /**\r\n\t   * User logon name. Better to access this value using {@link UBConnection#userLogin UBConnection.userLogin()} method.\r\n\t   * @type {String}\r\n\t   * @private\r\n\t   * @readonly\r\n\t   */\n\t  this.logonname = data.logonname;\n\t\n\t  /** Contain custom user data. Usually filled inside **server** `onUserLogon` event handlers\r\n\t   *\r\n\t   * Do not use it directly, instead use helper method {@link UBConnection#userData UBConnection.userData()} instead.\r\n\t   *\r\n\t   * @type {Object}\r\n\t   * @protected\r\n\t   * @readonly\r\n\t   */\n\t  this.userData = userData;\n\t\n\t  /**\r\n\t   * Name of authentication schema\r\n\t   * @type {String}\r\n\t   * @protected\r\n\t   * @readonly\r\n\t   */\n\t  this.authSchema = authSchema || 'UB';\n\t\n\t  /**\r\n\t   * Session signature for authorized request. Can be added as LAST parameter in url, or to Authorization header (preferred way)\r\n\t   *\r\n\t   *      $App.connection.authorize().then(function(session){\r\n\t   *          // for URL\r\n\t   *          return 'session_signature=' + session.signature()\r\n\t   *          //for header\r\n\t   *          return {Authorization: session.authSchema + ' ' + session.signature()}\r\n\t   *      });\r\n\t   *\r\n\t   * @returns {string}\r\n\t   */\n\t  this.signature = function () {\n\t    var timeStampI, hexaTime;\n\t    switch (this.authSchema) {\n\t      case 'None':\n\t        return '';\n\t      case 'UBIP':\n\t        return this.logonname;\n\t      default:\n\t        timeStampI = Math.floor(new Date().getTime() / 1000);\n\t        hexaTime = hexa8(timeStampI);\n\t        return hexa8ID + hexaTime + hexa8(typeof window === 'undefined' ? ncrc32(sessionSaltCRC, hexaTime) : crc32(sessionWord + sessionPwdHash + hexaTime)); // + url?\n\t    }\n\t    // 1.7 return  hexa8ID + hexa8(timeStampI) + hexa8(crc32(timeStampI + '' + crc32SessionWord ));\n\t  };\n\t\n\t  /**\r\n\t   * Current session is anonymous session\r\n\t   * @returns {boolean}\r\n\t   */\n\t  this.isAnonymous = function () {\n\t    return this.authSchema === 'None';\n\t  };\n\t\n\t  /**\r\n\t   * Return authorization header\r\n\t   *\r\n\t   *      $App.connection.authorize().then(function(session){\r\n\t   *          return {Authorization: session.authHeader()}\r\n\t   *      });\r\n\t   *\r\n\t   * @returns {string}\r\n\t   */\n\t  this.authHeader = function () {\n\t    return this.isAnonymous() ? '' : this.authSchema + ' ' + this.signature();\n\t  };\n\t}\n\t\n\t/**\r\n\t * Return hexadecimal string of 8 character length from value\r\n\t * @param {String|Number} value\r\n\t * @returns {String}\r\n\t */\n\tUBSession.prototype.hexa8 = function hexa8(value) {\n\t  var num = parseInt(value, 10);\n\t  var res = isNaN(num) ? '00000000' : num.toString(16);\n\t  while (res.length < 8) {\n\t    res = '0' + res;\n\t  }\n\t  return res;\n\t};\n\tvar hexa8 = UBSession.prototype.hexa8;\n\t\n\tvar CRC32_POLYTABLES = {};\n\t/* jslint bitwise: true */\n\t/**\r\n\t * Calculate CRC32 checksum for string\r\n\t * @param {String} s string to calculate CRC32\r\n\t * @param {Number} [polynomial] polynomial basis. default to 0x04C11DB7\r\n\t * @param {Number} [initialValue] initial crc value. default to 0xFFFFFFFF\r\n\t * @param {Number} [finalXORValue] default to 0xFFFFFFFF\r\n\t * @returns {Number}\r\n\t */\n\tUBSession.prototype.crc32 = function crc32(s, polynomial, initialValue, finalXORValue) {\n\t  var table, i, j, c, crc;\n\t  s = String(s);\n\t  polynomial = polynomial || 0x04C11DB7;\n\t  initialValue = initialValue || 0xFFFFFFFF;\n\t  finalXORValue = finalXORValue || 0xFFFFFFFF;\n\t  crc = initialValue;\n\t\n\t  table = CRC32_POLYTABLES[polynomial];\n\t  if (!table) {\n\t    table = CRC32_POLYTABLES[polynomial] = function build() {\n\t      var i, j, c;\n\t      var table = [];\n\t      var reverse = function reverse(x, n) {\n\t        var b = 0;\n\t        while (n) {\n\t          b = b * 2 + x % 2;\n\t          x /= 2;\n\t          x -= x % 1;\n\t          n--;\n\t        }\n\t        return b;\n\t      };\n\t      for (i = 255; i >= 0; i--) {\n\t        c = reverse(i, 32);\n\t\n\t        for (j = 0; j < 8; j++) {\n\t          c = (c * 2 ^ (c >>> 31) % 2 * polynomial) >>> 0;\n\t        }\n\t\n\t        table[i] = reverse(c, 32);\n\t      }\n\t      return table;\n\t    }();\n\t  }\n\t\n\t  for (i = 0; i < s.length; i++) {\n\t    c = s.charCodeAt(i);\n\t    if (c > 255) {\n\t      throw new RangeError();\n\t    }\n\t    j = crc % 256 ^ c;\n\t    crc = (crc / 256 ^ table[j]) >>> 0;\n\t  }\n\t  return (crc ^ finalXORValue) >>> 0;\n\t};\n\tvar crc32 = UBSession.prototype.crc32;\n\t\n\tmodule.exports = UBSession;\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// Originally found on  from https://github.com/mozilla/localForage\n\tvar dbInfo = {\n\t  name: 'UB',\n\t  stores: ['permanent', 'session', 'userData'],\n\t  version: 1\n\t};\n\t\n\t// Initialize IndexedDB; fall back to vendor-prefixed versions if needed.\n\t// noinspection JSUnresolvedVariable\n\tvar iDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.OIndexedDB || window.msIndexedDB;\n\t\n\t/**\r\n\t * @classdesc\r\n\t * Client side cache. Wrapper around <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB\">indexedDB</a>\r\n\t * !!! Don't try to refactor this code - starting of transaction in separate promise is not work for Firefox!!! see <a href=\"http://stackoverflow.com/questions/28388129/inconsistent-interplay-between-indexeddb-transactions-and-promises\">this topic</a>\r\n\t *\r\n\t * Contain functions for simple key/value manipulations and advanced (entity related) manipulations.\r\n\t *\r\n\t * Create separate <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase\">database</a>\r\n\t * for each connection inside application.\r\n\t *\r\n\t * For every database will create three <a href =\"https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase.createObjectStore\">store</a>\r\n\t *\r\n\t *  - **permanent** for data persistent between sessions and\r\n\t *  - **session** for data, live inside user session only (from login to login)\r\n\t *  - **user** for custom data\r\n\t *\r\n\t * Usage sample\r\n\t\r\n\t        var c = new UBCache('mydb');\r\n\t        c.put([\r\n\t            {key: 'note1', value: {prop1: 1, prop2: 'do something'} },\r\n\t            {key: 'note2', value: 'do something else'}\r\n\t        ]).then();\r\n\t        c.get('note1').then(UB.logDebug); //output result to console\r\n\t        c.clear();\r\n\t        c.get('note1').then(function(value){\r\n\t            console.log(value === undefined ? 'all cleared': 'hm... something wrong')\r\n\t        });\r\n\t\r\n\t * @class UBCache\r\n\t * @author pavel.mash on 17.04.2014 (rewrites to ES6 on 12.2016)\r\n\t * @param {String} dbName Name of indexedDB database we create. Usually this is {@link UBConnection#baseURL}. Constructor lower case dbName during creation\r\n\t * @param {Number} [version] Optionally database version.\r\n\t */\n\tfunction UBCache(dbName, version) {\n\t  var _this = this;\n\t\n\t  /** indexedDB name\r\n\t   * @property {String} dbName\r\n\t   * @readonly\r\n\t   */\n\t  this.dbName = dbName.toLowerCase();\n\t\n\t  var _dbPromise = new Promise(function (resolve, reject) {\n\t    if (!iDB) {\n\t      reject({ errMsg: 'unsupportedBrowser', errDetails: 'indexedDB not found' });\n\t    }\n\t    var openRequest = iDB.open(_this.dbName, version || 1);\n\t    openRequest.onerror = function withStoreOnError(e) {\n\t      reject(e); // openRequest.error.name\n\t    };\n\t    openRequest.onblocked = function () {\n\t      reject({ errMsg: 'databaseIsBlocked', errDetails: 'we need to upgrade database, but some other browser tab also open it' });\n\t    };\n\t    openRequest.onsuccess = function withStoreOnSuccess() {\n\t      resolve(openRequest.result);\n\t    };\n\t    openRequest.onupgradeneeded = function withStoreOnUpgradeNeeded(e) {\n\t      // First time setup: create an empty object stores\n\t      var db = e.target.result;\n\t      var tx = e.target.transaction;\n\t      console.log('upgrading database \"' + db.name + '\" from version ' + e.oldVersion + ' to version ' + e.newVersion + '...');\n\t      dbInfo.stores.forEach(function (storeName) {\n\t        // noinspection JSUnresolvedVariable\n\t        if (!db.objectStoreNames.contains(storeName)) {\n\t          db.createObjectStore(storeName);\n\t        } else {\n\t          // noinspection JSUnresolvedFunction\n\t          tx.objectStore(storeName).clear();\n\t        }\n\t      });\n\t    };\n\t  });\n\t\n\t  /**\r\n\t   * Must be call before access to UBCache methods\r\n\t   * @method\r\n\t   * @private\r\n\t   * @returns {Promise} resolved to IDBDatabase\r\n\t   */\n\t  this.ready = function () {\n\t    return _dbPromise;\n\t  };\n\t}\n\t\n\t/**\r\n\t * SESSION store name\r\n\t * @readonly\r\n\t * @type {String}\r\n\t */\n\tUBCache.SESSION = 'session';\n\t/**\r\n\t * PERMANENT store name\r\n\t * @readonly\r\n\t * @type {String}\r\n\t */\n\tUBCache.PERMANENT = 'permanent';\n\t\n\t/**\r\n\t * Possible cache types for businnes logic data\r\n\t * @readonly\r\n\t * @enum\r\n\t */\n\tUBCache.cacheTypes = {\n\t  /**\r\n\t   * Кэширование не осуществляется. Запрос на сервер отправляется всегда.\r\n\t   *\r\n\t   * @type String\r\n\t   */\n\t  None: 'None',\n\t\n\t  /**\r\n\t   * Кэширование осуществляется на уровне сущности. Запрос на сервер отправляется всегда. При этом в запрос добавляется версия закэшированных данных, если таковые имеются.\r\n\t   * Результат запроса содержит\r\n\t   * или данные и версию данных, которые помещаются в кэш;\r\n\t   * или флаг notModified. В этом случае данные считываются из кэша.\r\n\t   *\r\n\t   * Если в запросе в whereList присутствует ID - кэширование не осуществляется. Запрос на сервер отправляется всегда.\r\n\t   *\r\n\t   * @type String\r\n\t   */\n\t  Entity: 'Entity',\n\t\n\t  /**\r\n\t   * Кэширование осуществляется на уровне сессии. Запрос на сервер отправляется только один раз при старте сессии. При старте сессии все закэшированные сущности удаляются из кэша.\r\n\t   *\r\n\t   * Если в запросе в whereList присутствует ID - кэширование не осуществляется. Запрос на сервер отправляется всегда.\r\n\t   *\r\n\t   * @type String\r\n\t   */\n\t  Session: 'Session',\n\t\n\t  /**\r\n\t   * Кеширование осуществляется на уровне сессии и сущности. Запрос на сервер отправляетсятолько один раз при старте сессии. При этом в запрос добавляется версия закэшированных данных, если таковые имеются.\r\n\t   * Результат запроса содержит\r\n\t   * или данные и версию данных, которые помещаются в кэш;\r\n\t   * или флаг notModified. В этом случае данные считываются из кэша.\r\n\t   *\r\n\t   * Если в запросе в whereList присутствует ID - кэширование не осуществляется. Запрос на сервер отправляется всегда.\r\n\t   *\r\n\t   * @type String\r\n\t   */\n\t  SessionEntity: 'SessionEntity'\n\t};\n\t\n\t/**\r\n\t * Predefined callback functions, called when indexedDB transaction complete.\r\n\t * Can be customized after UBCache is created.\r\n\t * Default implementation will do nothing\r\n\t * @type {function(e)}\r\n\t */\n\tUBCache.prototype.onTransactionComplete = function (e) {}\n\t// if (e.target.mode !== 'readonly'){\n\t//   UB.logDebug('IDB ' + e.target.mode + ' transaction complete');\n\t// }\n\t\n\t\n\t/**\r\n\t * Predefined callback functions, called when indexedDB transaction aborted.\r\n\t * Can be customized after UBCache is created.\r\n\t * Default implementation will put error to log\r\n\t * @type {function(e)}\r\n\t */\n\t;UBCache.prototype.onTransactionAbort = function (e) {\n\t  if (window.console) {\n\t    window.console.error('IDB transaction aborted: ' + (e.target.error.message || e.target.errorCode));\n\t  }\n\t};\n\t/**\r\n\t * Predefined callback functions, called when error occurred during indexedDB transaction.\r\n\t * Can be customized after UBCache is created.\r\n\t * Default implementation will put error to log\r\n\t * @type {function(e)}\r\n\t */\n\tUBCache.prototype.onTransactionError = function (e) {\n\t  if (window.console) {\n\t    window.console.error('IDB transaction failed: ' + e.target.errorCode);\n\t  }\n\t};\n\t\n\t/**\r\n\t * Retrieve data from store by key. If key not found - resolve result to `undefined`\r\n\t * @method\r\n\t * @param {String} key\r\n\t * @param {String} [storeName] default to 'userData'\r\n\t * @returns {Promise} resolved to key value.\r\n\t */\n\tUBCache.prototype.get = function (key) {\n\t  var storeName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'userData';\n\t\n\t  var me = this;\n\t  return this.ready().then(function (db) {\n\t    var trans = db.transaction([storeName], 'readwrite');\n\t    trans.oncomplete = me.onTransactionComplete;\n\t    trans.onabort = me.onTransactionAbort;\n\t    trans.onerror = me.onTransactionError;\n\t    return new Promise(function (resolve, reject) {\n\t      var req = trans.objectStore(storeName).get(key);\n\t      req.onsuccess = function getItemOnSuccess() {\n\t        resolve(req.result);\n\t      };\n\t      req.onerror = function getItemOnError() {\n\t        reject({ errMsg: req.error.name });\n\t      };\n\t    });\n\t  });\n\t};\n\t\n\t/**\r\n\t * Retrieves all values from store. **This is slow operation - try to avoid it**\r\n\t * @param {String} [storeName] default to 'userData'\r\n\t * @returns {Promise} resolved to Array of store keys\r\n\t */\n\tUBCache.prototype.getAllKeys = function () {\n\t  var storeName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'userData';\n\t\n\t  var me = this;\n\t  return this.ready().then(function (db) {\n\t    var trans = db.transaction([storeName], 'readwrite');\n\t    trans.oncomplete = me.onTransactionComplete;\n\t    trans.onabort = me.onTransactionAbort;\n\t    trans.onerror = me.onTransactionError;\n\t    return new Promise(function (resolve, reject) {\n\t      var results = [];\n\t      var req = trans.objectStore(storeName).openCursor();\n\t      req.onsuccess = function (e) {\n\t        var cursor = e.target.result;\n\t        if (cursor) {\n\t          results.push(cursor.key);\n\t          cursor.continue();\n\t        } else {\n\t          resolve(results);\n\t        }\n\t      };\n\t      req.onerror = function (e) {\n\t        reject(e.target.result);\n\t      };\n\t    });\n\t  });\n\t};\n\t\n\t/**\r\n\t * Put one or several values to store (in single transaction).\r\n\t * Modifies existing values or inserts as new value if nonexistent.\r\n\t *\r\n\t * **If value === `undefined` we put null instead, to understand in future get this is null value or key not exist**\r\n\t * @param {{key: string, value}|Array<{key: string, value}>} data\r\n\t * @param [storeName] default to 'userData'\r\n\t * @returns {Promise}\r\n\t */\n\tUBCache.prototype.put = function (data) {\n\t  var storeName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'userData';\n\t\n\t  var me = this;\n\t  return this.ready().then(function (db) {\n\t    var trans = db.transaction([storeName], 'readwrite');\n\t    trans.oncomplete = me.onTransactionComplete;\n\t    trans.onabort = me.onTransactionAbort;\n\t    trans.onerror = me.onTransactionError;\n\t\n\t    return new Promise(function (resolve, reject) {\n\t      var req = void 0;\n\t      if (Array.isArray(data)) {\n\t        data.forEach(function (item, i) {\n\t          req = trans.objectStore(storeName).put(item.value === undefined ? null : item.value, item.key);\n\t          req.onerror = function (e) {\n\t            reject(e.target.result);\n\t          };\n\t          req.onsuccess = function (e) {\n\t            if (i === data.length - 1) {\n\t              resolve(e.target.result);\n\t            }\n\t          };\n\t        });\n\t      } else {\n\t        req = trans.objectStore(storeName).put(data.value === undefined ? null : data.value, data.key);\n\t        req.onsuccess = req.onerror = function (e) {\n\t          resolve(e.target.result);\n\t        };\n\t      }\n\t    });\n\t  });\n\t};\n\t\n\t/**\r\n\t * Removes all data from the store\r\n\t * @param {String} [storeName] default to 'userData'\r\n\t * @returns {Promise}\r\n\t */\n\tUBCache.prototype.clear = function () {\n\t  var storeName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'userData';\n\t\n\t  var me = this;\n\t  return this.ready().then(function (db) {\n\t    var trans = db.transaction([storeName], 'readwrite');\n\t    trans.oncomplete = me.onTransactionComplete;\n\t    trans.onabort = me.onTransactionAbort;\n\t    trans.onerror = me.onTransactionError;\n\t    return new Promise(function (resolve, reject) {\n\t      var req = trans.objectStore(storeName).clear();\n\t      req.onsuccess = function (e) {\n\t        resolve(e.target.result);\n\t      };\n\t      req.onerror = function (e) {\n\t        reject(e.target.result);\n\t      };\n\t    });\n\t  });\n\t};\n\t\n\t/**\r\n\t * Remove data from store.\r\n\t *\r\n\t * - If key is *String* - we delete one key;\r\n\t * - If key is *Array*  - we delete all keys in array;\r\n\t *\r\n\t * @method\r\n\t * @example\r\n\t\r\n\t//remove data with key = 'key1' from userData store\r\n\t$App.cache.remove('key1').then();\r\n\t\r\n\t//remove 2 rows: with key = 'key1' and 'key2'  from session store\r\n\t$App.cache.remove(['key1', 'key2'], UBCache.SESSION).then();\r\n\t\r\n\t * @param {String|Array<String>|RegExp} key\r\n\t * @param [storeName] default to 'userData'\r\n\t * @returns {Promise}\r\n\t */\n\tUBCache.prototype.remove = function (key) {\n\t  var storeName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'userData';\n\t\n\t  var me = this;\n\t  return this.ready().then(function (db) {\n\t    var trans = db.transaction([storeName], 'readwrite');\n\t    trans.oncomplete = me.onTransactionComplete;\n\t    trans.onabort = me.onTransactionAbort;\n\t    trans.onerror = me.onTransactionError;\n\t    return new Promise(function (resolve, reject) {\n\t      var req = void 0;\n\t      if (typeof key === 'string') {\n\t        req = trans.objectStore(storeName).delete(key);\n\t        req.onsuccess = req.onerror = function (e) {\n\t          resolve(e.target.result);\n\t        };\n\t      } else if (Array.isArray(key)) {\n\t        // non empty array\n\t        if (key.length) {\n\t          key.forEach(function (item, i) {\n\t            req = trans.objectStore(storeName).delete(item);\n\t            req.onerror = function (e) {\n\t              reject(e.target.result);\n\t            };\n\t            req.onsuccess = function (e) {\n\t              if (i === key.length - 1) {\n\t                resolve(e.target.result);\n\t              }\n\t            };\n\t          });\n\t        } else {\n\t          resolve(true); // empty array passed - nothing to delete\n\t        }\n\t      } else {\n\t        reject({ errMsg: 'invalid key for UBCache.remove call' });\n\t      }\n\t    });\n\t  });\n\t};\n\t\n\t/**\r\n\t * Remove data from store where keys match regExp.\r\n\t * Internally use {@link UBCache#getAllKeys} so is slow.\r\n\t * Better to use `remove([key1, ..keyN])`\r\n\t * @method\r\n\t *\r\n\t * @example\r\n\t\r\n\tconsole.time('removeIfMach');\r\n\t$App.cache.removeIfMach(/^admin:ru:cdn_/, 'permanent').then(function(){\r\n\t   console.timeEnd('removeIfMach');\r\n\t})\r\n\t\r\n\t * @param {RegExp} regExp\r\n\t * @param [storeName] default to 'userData'\r\n\t * @returns {Promise}\r\n\t */\n\tUBCache.prototype.removeIfMach = function (regExp, storeName) {\n\t  var me = this;\n\t  return me.getAllKeys(storeName).then(function (allKeys) {\n\t    var machKeys = allKeys.filter(function (item) {\n\t      return regExp.test(item);\n\t    });\n\t    return me.remove(machKeys, storeName);\n\t  });\n\t};\n\t\n\tmodule.exports = UBCache;\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t/*\r\n\t  Rewrited to ES6 from UB 1.12sources by pavel.mash on 12.2016\r\n\t */\n\t\n\t/* global Blob */\n\tvar _ = __webpack_require__(2);\n\tvar EventEmitter = __webpack_require__(5);\n\tvar ubUtils = __webpack_require__(1);\n\tvar i18n = __webpack_require__(6).i18n;\n\tvar transport = __webpack_require__(12);\n\tvar UBSession = __webpack_require__(16);\n\tvar LocalDataStore = __webpack_require__(9);\n\tvar UBDomain = __webpack_require__(15);\n\tvar UBCache = __webpack_require__(17);\n\tvar CryptoJSCore = __webpack_require__(4);\n\tvar SHA256 = __webpack_require__(8);\n\tvar MD5 = __webpack_require__(7);\n\tvar UBNativeDSTUCrypto = __webpack_require__(19);\n\tvar UBNativeIITCrypto = __webpack_require__(20);\n\tvar UBNotifierWSProtocol = __webpack_require__(21);\n\tvar ClientRepository = __webpack_require__(10);\n\t\n\t// regular expression for URLs server not require authorization.\n\tvar NON_AUTH_URLS_RE = /(\\/|^)(models|auth|getAppInfo|downloads)(\\/|\\?|$)/;\n\t// regular expression for URLs server not require encryption. Note - all non-auth method not require encryption also\n\tvar NON_ENCRYPTED_URLS_RE = /(\\/|^)(initEncryption)(\\/|\\?|$)/;\n\t// all request passed in this timeout to run will be send into one runList server method execution\n\tvar BUFFERED_DELAY = 20;\n\t\n\tvar AUTH_METHOD_URL = 'auth';\n\t\n\tvar ANONYMOUS_USER = 'anonymous';\n\tvar AUTH_SCHEMA_FOR_ANONYMOUS = 'None';\n\t\n\t/**\r\n\t * Default anonymous credential\r\n\t * @param {UBConnection} conn\r\n\t * @param {Boolean} isRepeat\r\n\t * @returns {*}\r\n\t */\n\tfunction anonymousRequestAuthParams(conn, isRepeat) {\n\t  if (isRepeat) {\n\t    throw new ubUtils.UBError('Access deny');\n\t  } else {\n\t    return Promise.resolve({ authSchema: AUTH_SCHEMA_FOR_ANONYMOUS, login: ANONYMOUS_USER });\n\t  }\n\t}\n\t\n\t/**\r\n\t * @classdesc\r\n\t *\r\n\t * Connection to the UnityBase server.\r\n\t *\r\n\t * In case host set to value other then `location.host` server must be configured to accept\r\n\t * <a href=\"https://developer.mozilla.org/en-US/docs/HTTP/Access_control_CORS\">CORS</a> requests.\r\n\t * Usually it done via \"HTTPAllowOrigin\" server configuration option.\r\n\t *\r\n\t * Usage sample:\r\n\t *\r\n\t       // connect using UBIP schema\r\n\t       let conn = new UBConnection({\r\n\t           host: 'http://127.0.0.1:888',\r\n\t           requestAuthParams: function(conn, isRepeat){\r\n\t               if (isRepeat){\r\n\t                   throw new UB.UBAbortError('invalid credential')\r\n\t               } else {\r\n\t                   return Promise.resolve({authSchema: 'UBIP', login: 'admin'})\r\n\t               }\r\n\t            }\r\n\t       });\r\n\t       conn.query({entity: 'uba_user', method: 'select', fieldList: ['ID', 'name']}).then(UB.logDebug);\r\n\t\r\n\t       // Anonymous connect. Allow access to entity methods, granted by ELS rules to `Anonymous` role\r\n\t       // Request below will be success if we grant a `ubm_navshortcut.select` to `Anonymous` on the server side\r\n\t       let conn = new UBConnection({\r\n\t         host: 'http://127.0.0.1:888'\r\n\t       });\r\n\t       conn.query({entity: 'ubm_navshortcut', method: 'select', fieldList: ['ID', 'name']}).then(UB.logDebug);\r\n\t\r\n\t * This class mixes an EventEmitter, so you can subscribe for `authorized` and `authorizationFail` events:\r\n\t *\r\n\t       conn.on('authorizationFail', function(reason){\r\n\t            // indicate user credential is wrong\r\n\t       });\r\n\t\r\n\t       conn.on('authorized', function(ubConnection, session, authParams){console.debug(arguments)} );\r\n\t *\r\n\t * @class\r\n\t * @mixes EventEmitter\r\n\t * @param {Object} connectionParams connection parameters\r\n\t * @param {String} connectionParams.host UnityBase server host\r\n\t * @param {String} [connectionParams.appName='/'] UnityBase application to connect to\r\n\t * @param {Function} [connectionParams.requestAuthParams] Handler to log in.\r\n\t *      Must return promise & fulfill it by authorization parameters: {authSchema: authType, login: login, password: password }\r\n\t *          for openIDConnect must be fulfilled with  {data: uData, secretWord: ???}\r\n\t *      Called with arguments: {UBConnection} conn, {Boolean} isRepeat;\r\n\t *      isRepeat === true in case first auth request is invalid.\r\n\t *\r\n\t *      For Anonymous requests can be either omitted, or return promise, resolved to  `{authSchema: 'None'}`\r\n\t * @param {String} [connectionParams.protocol] either 'https' or 'http' (default)\r\n\t */\n\tfunction UBConnection(connectionParams) {\n\t  var host = connectionParams.host || 'http://localhost:888';\n\t  var appName = connectionParams.appName || '/';\n\t  var requestAuthParams = connectionParams.requestAuthParams;\n\t  var baseURL = void 0,\n\t      serverURL = void 0;\n\t  /*\r\n\t   * Current session (Promise). Result of {@link UBConnection#auth auth} method\r\n\t   * {@link UBConnection#xhr} use this promise as a first `then` in call chain. In case of 401 response\r\n\t   * authPromise recreated.\r\n\t   */\n\t  var currentSession = void 0;\n\t\n\t  EventEmitter.call(this);\n\t  _.assign(this, EventEmitter.prototype);\n\t\n\t  /**\r\n\t   * WebSocket `ubNotifier` protocol instance\r\n\t   * @type {UBNotifierWSProtocol}\r\n\t   */\n\t  this.ubNotifier = null;\n\t\n\t  /**\r\n\t   * Application settings transferred form a server\r\n\t   * @type {{}}\r\n\t   */\n\t  this.appConfig = {};\n\t\n\t  /**\r\n\t   * The preferred (used in previous user session if any or a default for application) locale\r\n\t   * @type {string}\r\n\t   */\n\t  this.preferredLocale = 'en';\n\t\n\t  /**\r\n\t   * Domain information. Initialized after promise, returned by by function {@link UBConnection#getDomainInfo getDomainInfo} isresolved\r\n\t   * @type {UBDomain}\r\n\t   */\n\t  this.domain = null;\n\t\n\t  if (appName.charAt(0) !== '/') {\n\t    appName = '/' + appName;\n\t  }\n\t  if (!requestAuthParams) {\n\t    requestAuthParams = anonymousRequestAuthParams;\n\t  }\n\t  serverURL = host + appName;\n\t  /** UB Server URL with protocol and host.\r\n\t   * @type {string}\r\n\t   * @readonly\r\n\t   */\n\t  this.serverUrl = serverURL;\n\t  baseURL = window.location.origin === host ? appName : serverURL;\n\t  if (baseURL.charAt(baseURL.length - 1) !== '/') baseURL = baseURL + '/';\n\t  /**\r\n\t   * The base of all urls of your requests. Will be prepend to all urls while call UB.xhr\r\n\t   * @type {String}\r\n\t   * @readonly\r\n\t   */\n\t  this.baseURL = baseURL;\n\t  /** UB application name\r\n\t   * @type {String}\r\n\t   * @readonly\r\n\t   */\n\t  this.appName = appName;\n\t\n\t  /** Result of last key agreement. Resolved to object,\r\n\t   * contain time when it was done inside\r\n\t   * - **doneTime** property\r\n\t   *  Usually this is result of UBConnection.doKeyExchange method call\r\n\t   * @private\r\n\t   * @type {Promise}\r\n\t   */\n\t  this.exchangeKeysPromise = null;\n\t\n\t  /** UBNativeDSTUCrypto instance used for encryption\r\n\t   * @type {UBNativeDSTUCrypto}\r\n\t   */\n\t  this.channelEncryptor = null;\n\t\n\t  /** UBNativeIITCrypto instance used for PKI relative operations (read keys / signatures)\r\n\t   * @private\r\n\t   * @readonly\r\n\t   * @type {UBNativeIITCrypto}\r\n\t   */\n\t  this._pki = null;\n\t\n\t  /**\r\n\t   * Check current connection use PKI\r\n\t   * @protected\r\n\t   * @returns {boolean}\r\n\t   */\n\t  this.isPKIReady = function () {\n\t    return this._pki !== null;\n\t  };\n\t\n\t  this.cache = null;\n\t\n\t  /**\r\n\t   * Last successful login name. Filled AFTER first 401 response\r\n\t   * @type {String}\r\n\t   */\n\t  this.lastLoginName = '';\n\t  /**\r\n\t   * Cache flag to enable a hack appending the current timestamp\r\n\t   * to your requests to prevent IE from caching them and always returning the same result.\r\n\t   * If \"true\", will set the param with the name \"_\"\r\n\t   * If a string, will use it as the param name\r\n\t   * @type {Boolean|String}\r\n\t   */\n\t  this.useCacheForXHR = window && (window.ActiveXObject || 'ActiveXObject' in window);\n\t\n\t  this._bufferedRequests = [];\n\t  this._bufferTimeoutID = 0;\n\t\n\t  /**\r\n\t   * Is user currently logged in. There is no guaranty what session actually exist in server.\r\n\t   * @returns {boolean}\r\n\t   */\n\t  this.isAuthorized = function () {\n\t    return currentSession !== undefined;\n\t  };\n\t  /**\r\n\t   * Return current user logon name or 'anonymous' in case not logged in\r\n\t   * @returns {String}\r\n\t   */\n\t  this.userLogin = function () {\n\t    return this.userData('login');\n\t  };\n\t\n\t  /**\r\n\t   * Return current user language or 'en' in case not logged in\r\n\t   * @returns {String}\r\n\t   */\n\t  this.userLang = function () {\n\t    return this.userData('lang');\n\t  };\n\t\n\t  /**\r\n\t   * Return custom data for logged in user, or {lang: 'en', login: 'anonymous'} in case not logged in\r\n\t   *\r\n\t   * If key is provided - return only key part of user data:\r\n\t   *\r\n\t   *      $App.connection.userData('lang');\r\n\t   *      // or the same but dedicated alias\r\n\t   *      $App.connection.userLang()\r\n\t   *\r\n\t   * @param {String} [key] Optional key\r\n\t   * @returns {*}\r\n\t   */\n\t  this.userData = function (key) {\n\t    var uData = this.isAuthorized() ? currentSession.userData : { lang: 'en', login: ANONYMOUS_USER };\n\t\n\t    return key ? uData[key] : uData;\n\t  };\n\t\n\t  /**\r\n\t   * The starter method for all authorized requests to UB server. Return authorization promise resolved to {@link UBSession}.\r\n\t   * In case unauthorized:\r\n\t   *\r\n\t   *  - call requestAuthParams method passed to UBConnection constructor to retrieve user credentials\r\n\t   *  - call {@link UBConnection#doAuth} method\r\n\t   *\r\n\t   * Used inside {@link UBConnection#xhr}, therefore developer rarely call it directly.\r\n\t   * @method\r\n\t   * @param {boolean} [isRepeat] in case user provide wrong credential - we must show logon window\r\n\t   * @returns {Promise<UBSession>} Resolved to {UBSession} if auth success or rejected to `{errMsg: string, errCode: number, errDetails: string}` if fail\r\n\t   */\n\t  this.authorize = function (isRepeat) {\n\t    var me = this;\n\t    if (currentSession) return Promise.resolve(currentSession);\n\t\n\t    this.exchangeKeysPromise = null;\n\t    return requestAuthParams(this, isRepeat).then(function (authParams) {\n\t      return me.doAuth(authParams).then(function (session) {\n\t        currentSession = session;\n\t        /**\r\n\t         * Fired for {@link UBConnection} instance after success authorization. Accept 3 args (conn: UBConnection, session: UBSession, authParams)\r\n\t         * @event authorized\r\n\t         */\n\t        me.emit('authorized', me, session, authParams);\n\t        return session;\n\t      }).catch(function (reason) {\n\t        if (!reason || !(reason instanceof ubUtils.UBAbortError)) {\n\t          /**\r\n\t           * Fired for {@link UBConnection} instance in case of bad authorization Accept 1 args (reason)\r\n\t           * @event authorizationFail\r\n\t           */\n\t          me.emit('authorizationFail', reason);\n\t        }\n\t        return me.authorize(true);\n\t      });\n\t    });\n\t  };\n\t\n\t  /**\r\n\t   * Clear current user authorization promise. Next request repeat authorization\r\n\t   * @private\r\n\t   */\n\t  this.authorizationClear = function () {\n\t    this.lastLoginName = this.userLogin();\n\t    currentSession = undefined;\n\t  };\n\t\n\t  /**\r\n\t   * UBIP Auth schema implementation\r\n\t   * @param authParams\r\n\t   * @returns {Promise}\r\n\t   */\n\t  this.authHandshakeUBIP = function (authParams) {\n\t    if (!authParams.login) {\n\t      return Promise.reject({ errMsg: 'invalid user name' });\n\t    }\n\t\n\t    return this.post(AUTH_METHOD_URL, '', { headers: { Authorization: authParams.authSchema + ' ' + authParams.login } });\n\t  };\n\t\n\t  /**\r\n\t   * openID Connect auth schema.\r\n\t   * This function act as a proxy but change authSchema back to 'UB' for authorization token generation\r\n\t   * @param authParams\r\n\t   * @return {*}\r\n\t   */\n\t  this.authHandshakeOpenIDConnect = function (authParams) {\n\t    return Promise.resolve(authParams).then(function (authParams) {\n\t      authParams.authSchema = 'UB';\n\t      return authParams;\n\t    });\n\t  };\n\t\n\t  /**\r\n\t   * UB Auth schema implementation\r\n\t   * @param authParams\r\n\t   * @returns {Promise}\r\n\t   */\n\t  this.authHandshakeUB = function (authParams) {\n\t    var me = this;\n\t    var secretWord = void 0;\n\t\n\t    if (!authParams.login || !authParams.password) {\n\t      return Promise.reject({ errMsg: 'invalid user name or password' });\n\t    }\n\t\n\t    return this.post(AUTH_METHOD_URL, '', {\n\t      params: {\n\t        AUTHTYPE: authParams.authSchema,\n\t        userName: authParams.login\n\t      }\n\t    }).then(function (resp) {\n\t      var serverNonce = void 0,\n\t          pwdHash = void 0,\n\t          pwdForAuth = void 0;\n\t      var request = {\n\t        params: {\n\t          AUTHTYPE: authParams.authSchema,\n\t          userName: authParams.login,\n\t          password: ''\n\t        }\n\t      };\n\t      var clientNonce = SHA256(new Date().toISOString().substr(0, 16)).toString();\n\t      request.params.clientNonce = clientNonce;\n\t      if (resp.data.connectionID) {\n\t        request.params.connectionID = resp.data.connectionID;\n\t      }\n\t      // LDAP AUTH?\n\t      var realm = resp.data.realm;\n\t      if (realm) {\n\t        serverNonce = resp.data.nonce;\n\t        if (!serverNonce) {\n\t          throw new Error('invalid LDAP auth response');\n\t        }\n\t        if (resp.data.useSasl) {\n\t          pwdHash = MD5(authParams.login.split('\\\\')[1].toUpperCase() + ':' + realm + ':' + authParams.password);\n\t          // we must calculate md5(login + ':' + realm + ':' + password) in binary format\n\t          pwdHash.concat(CryptoJSCore.enc.Utf8.parse(':' + serverNonce + ':' + clientNonce));\n\t          pwdForAuth = MD5(pwdHash).toString();\n\t          secretWord = pwdForAuth; // :( medium unsecured\n\t        } else {\n\t          pwdForAuth = window.btoa(authParams.password);\n\t          secretWord = pwdForAuth; // todo -  very unsecured!!\n\t        }\n\t      } else {\n\t        serverNonce = resp.data.result;\n\t        if (!serverNonce) {\n\t          throw new Error('invalid auth response');\n\t        }\n\t        pwdHash = SHA256('salt' + authParams.password).toString();\n\t        var appForAuth = appName === '/' ? '/' : appName.replace(/\\//g, '');\n\t        pwdForAuth = SHA256(appForAuth.toLowerCase() + serverNonce + clientNonce + authParams.login + pwdHash).toString();\n\t        secretWord = pwdHash;\n\t      }\n\t      request.params.password = pwdForAuth;\n\t      return me.post(AUTH_METHOD_URL, '', request).then(function (response) {\n\t        response.secretWord = secretWord;\n\t        return response;\n\t      });\n\t    });\n\t  };\n\t\n\t  /**\r\n\t   * CERT auth schema implementation\r\n\t   * @param authParams\r\n\t   * @returns {Promise}\r\n\t   */\n\t  this.authHandshakeCERT = function (authParams) {\n\t    var me = this;\n\t    var pki = void 0,\n\t        secretWord = void 0;\n\t    var urlParams = {\n\t      AUTHTYPE: authParams.authSchema\n\t    };\n\t\n\t    if (authParams.login) {\n\t      urlParams.userName = authParams.login;\n\t    }\n\t    if (authParams.password) {\n\t      urlParams.password = authParams.password;\n\t    }\n\t    if (authParams.registration) {\n\t      urlParams.registration = authParams.registration;\n\t    }\n\t\n\t    return me.pki().then(function (pkiInit) {\n\t      pki = pkiInit;\n\t      // noinspection JSCheckFunctionSignatures\n\t      return pki.readPK(me);\n\t    }).then(function (certInfo) {\n\t      var reqData = certInfo.ownIITCert;\n\t      // in case we have different certificates for signing and encryption - pass them all\n\t      if (certInfo.ownIITEncryptCert && certInfo.ownIITEncryptCert !== '') {\n\t        reqData = [certInfo.ownIITCert, certInfo.ownIITEncryptCert, certInfo.ownIITEncryptSignature].join(' ');\n\t      }\n\t      return me.xhr({\n\t        url: AUTH_METHOD_URL,\n\t        method: 'POST',\n\t        headers: { 'Content-Type': 'application/octet-stream' },\n\t        params: urlParams,\n\t        responseType: 'arraybuffer',\n\t        data: reqData\n\t      });\n\t    }).then(function () {\n\t      throw new ubUtils.UBError('msgInvalidCertAuth');\n\t    }, function (resp) {\n\t      var aValues = void 0,\n\t          authData = void 0,\n\t          serverMessage = void 0;\n\t\n\t      if (resp instanceof Error || resp instanceof ubUtils.UBError) {\n\t        throw resp;\n\t      }\n\t      if (resp.status !== 401) {\n\t        if (resp.data && resp.data instanceof ArrayBuffer && resp.data.byteLength > 1) {\n\t          try {\n\t            // noinspection JSCheckFunctionSignatures\n\t            var respObj = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(resp.data)));\n\t            if ((respObj.errCode === 65 || respObj.errCode === 0) && respObj.errMsg && /<<<.*>>>/.test(respObj.errMsg)) {\n\t              serverMessage = respObj.errMsg.match(/<<<(.*)>>>/)[1];\n\t            }\n\t          } catch (err) {}\n\t          if (serverMessage) throw new ubUtils.UBError(serverMessage);\n\t        }\n\t        throw new ubUtils.UBError('msgInvalidCertAuth');\n\t      }\n\t\n\t      // begin phrase 2 of auth.\n\t      // wait for response WWW-Authenticate: CERT connectionId server_certificate\n\t      // and encrypted by client certificate secret word in body\n\t      authData = resp.headers('WWW-Authenticate');\n\t      if (!authData && authData.substr(0, 5) !== 'CERT ') {\n\t        throw new Error('invalidCertAuthRespAuthType');\n\t      }\n\t      aValues = authData.split(' ');\n\t      if (aValues.length !== 3) throw new Error('invalidCertAuthResponse');\n\t      urlParams.CONNECTIONID = aValues[1];\n\t      return pki.setRecipientCertificate(aValues[2]).then(function () {\n\t        return ubUtils.base64FromAny(resp.data);\n\t      }).then(function (envelop) {\n\t        if (!envelop || envelop === '') {\n\t          throw new Error('invalidCertAuthEnvelop');\n\t        }\n\t        // decrypt secret word using client private key\n\t        return pki.decryptEnvelope(envelop, true);\n\t      }).then(function (secretWordB64) {\n\t        // memorize it\n\t        secretWord = window.atob(secretWordB64);\n\t        // encrypt secret word with server public key\n\t        return pki.encryptEnvelope(secretWordB64, true);\n\t      }).then(function (encryptEnvelopeRes) {\n\t        var envelop = ubUtils.base64toArrayBuffer(encryptEnvelopeRes);\n\t        if (envelop.byteLength === 0) {\n\t          throw new Error('invalidCertAuthEnvelopOut');\n\t        }\n\t        // repeat request with encrypted secret word\n\t        return me.xhr({\n\t          url: AUTH_METHOD_URL,\n\t          method: 'POST',\n\t          headers: { 'Content-Type': 'application/octet-stream' },\n\t          params: urlParams,\n\t          data: envelop\n\t        });\n\t      }).then(function (response) {\n\t        response.secretWord = secretWord;\n\t        return response;\n\t      });\n\t    }).then( // a-la fin\n\t    function () {\n\t      if (pki) pki.closePK();\n\t    }, function () {\n\t      if (pki) pki.closePK();\n\t    });\n\t  };\n\t\n\t  /**\r\n\t   * Do authentication in UnityBase server. Usually called from UBConnection #authorize method in case authorization expire or user not authorized.\r\n\t   * Resolve to {@link UBSession} session object.\r\n\t   *\r\n\t   * @private\r\n\t   * @param {Object} authParams\r\n\t   * @param {String} [authParams.authSchema] Either 'UB' (default) or 'CERT'. On case of CERT UBDesktop service NPI extension must be installed in browser\r\n\t   * @param {String} [authParams.login] Optional login\r\n\t   * @param {String} [authParams.password] Optional password\r\n\t   * @returns {Promise} Authentication promise. Resolved to {@link UBSession} is auth success or rejected to {errMsg: string, errCode: number, errDetails: string} if fail\r\n\t   */\n\t  this.doAuth = function (authParams) {\n\t    var me = this;\n\t    var promise = void 0;\n\t\n\t    authParams.authSchema = authParams.authSchema || 'UB';\n\t    if (me.isAuthorized()) {\n\t      return Promise.reject({ errMsg: 'invalid auth call', errDetails: 'contact developers' });\n\t    }\n\t\n\t    switch (authParams.authSchema) {\n\t      case AUTH_SCHEMA_FOR_ANONYMOUS:\n\t        promise = Promise.resolve({ data: { result: '0+0', uData: JSON.stringify({ login: ANONYMOUS_USER }) }, secretWord: '' });\n\t        break;\n\t      case 'UB':\n\t        promise = me.authHandshakeUB(authParams);\n\t        break;\n\t      case 'CERT':\n\t        promise = me.authHandshakeCERT(authParams);\n\t        break;\n\t      case 'UBIP':\n\t        promise = me.authHandshakeUBIP(authParams);\n\t        break;\n\t      case 'OpenIDConnect':\n\t        promise = me.authHandshakeOpenIDConnect(authParams);\n\t        break;\n\t      case 'Negotiate':\n\t        promise = me.post(AUTH_METHOD_URL, '', {\n\t          params: {\n\t            USERNAME: '',\n\t            AUTHTYPE: authParams.authSchema\n\t          }\n\t        }).then(function (resp) {\n\t          resp.secretWord = resp.data.logonname;\n\t          return resp;\n\t        });\n\t        break;\n\t      default:\n\t        promise = Promise.reject({ errMsg: 'invalid authentication schema ' + authParams.authSchema });\n\t        break;\n\t    }\n\t    promise = promise.then(function (authResponse) {\n\t      var ubSession = new UBSession(authResponse.data, authResponse.secretWord, authParams.authSchema);\n\t      var userData = ubSession.userData;\n\t      if (!userData.lang || me.appConfig.supportedLanguages.indexOf(userData.lang) === -1) {\n\t        userData.lang = me.appConfig.supportedLanguages[0];\n\t      }\n\t      return ubSession;\n\t    }, function (rejectReason) {\n\t      var errInfo = {};\n\t      if (!(rejectReason instanceof Error)) {\n\t        if (rejectReason.data) {\n\t          errInfo = {\n\t            errMsg: rejectReason.data.errMsg,\n\t            errCode: rejectReason.data.errCode,\n\t            errDetails: rejectReason.data.errMsg\n\t          };\n\t        }\n\t        if (rejectReason.status === 403) {\n\t          errInfo.errMsg = authParams.authSchema === 'UB' ? 'msgInvalidUBAuth' : 'msgInvalidCertAuth';\n\t        } else {\n\t          if (!errInfo.errMsg) {\n\t            errInfo.errMsg = 'unknownError';\n\t          } // internalServerError\n\t        }\n\t        if (rejectReason.status === 0) {\n\t          errInfo.errDetails = 'network error';\n\t        }\n\t        if (/<<<.*>>>/.test(errInfo.errMsg)) {\n\t          errInfo.errMsg = errInfo.errMsg.match(/<<<(.*)>>>/)[1];\n\t        }\n\t\n\t        var codeMsg = me.serverErrorByCode(errInfo.errCode);\n\t        if (codeMsg) {\n\t          errInfo.errDetails = codeMsg + ' ' + errInfo.errDetails;\n\t          if (i18n(codeMsg) !== codeMsg) {\n\t            errInfo.errMsg = codeMsg;\n\t          }\n\t        }\n\t\n\t        throw new ubUtils.UBError(errInfo.errMsg, errInfo.errDetails, errInfo.errCode);\n\t      } else {\n\t        throw rejectReason; // rethrow error\n\t      }\n\t    });\n\t    return promise;\n\t  };\n\t\n\t  this.recordedXHRs = [];\n\t  /**\r\n\t   * Set this to `true` to memorize all requests to this.recordedXHRs array (for debug only!).\r\n\t   * @type {Boolean}\r\n\t   */\n\t  this.recorderEnabled = false;\n\t}\n\t\n\t/**\r\n\t * Initialize client cache. Called from application after obtain userDbVersion (in case of Ext-based client called from {@link UB.core.UBApp#launch}.\r\n\t *\r\n\t * - recreate Indexed Db database if version changed\r\n\t * - create instance of UBCache (accessible via {@link UBConnection#cache UBConnection.cache} property) and clear UBCache.SESSION store.\r\n\t *\r\n\t * @param {Number} userDbVersion Indexed DB database version required for current application\r\n\t * @returns {Promise}\r\n\t */\n\tUBConnection.prototype.initCache = function (userDbVersion) {\n\t  var me = this;\n\t  /**\r\n\t   * @property {UBCache} cache\r\n\t   * @readonly\r\n\t   * @type {UBCache}\r\n\t   */\n\t  me.cache = new UBCache(me.baseURL, userDbVersion);\n\t  /**\r\n\t   * List of keys, requested in the current user session.\r\n\t   * Cleared each time login done\r\n\t   * @protected\r\n\t   * @property {Object} cachedSessionEntityRequested\r\n\t   */\n\t  me.cachedSessionEntityRequested = {};\n\t  // clear use session store\n\t  return me.cache.clear(UBCache.SESSION);\n\t};\n\t\n\t/**\r\n\t * Calculate cache key for request. This key is used to store data inside UBCache\r\n\t * @param {String} root This is usually entity name\r\n\t * @param {Array<string>} [attributes] if present - add attributes hash. This is usually array of entity attributes we want to put inside cache\r\n\t * @returns {String}\r\n\t */\n\tUBConnection.prototype.cacheKeyCalculate = function (root, attributes) {\n\t  var me = this;\n\t  var keyPart = [me.userLogin().toLowerCase(), me.userLang(), root];\n\t  if (Array.isArray(attributes)) {\n\t    keyPart.push(MD5(JSON.stringify(attributes)).toString());\n\t  }\n\t  return keyPart.join('#').replace(/[\\\\:\\.]/g, '#'); // replace all :, \\ -> #;\n\t};\n\t\n\t/**\r\n\t * Refresh all cache occurrence for root depending on cacheType:\r\n\t *\r\n\t * - if `Session` - clear indexedDB for this root.\r\n\t * - if `SessionEntity` - remove entry in {@link UBConnection#cachedSessionEntityRequested}\r\n\t * - else - do nothing\r\n\t * @param {String} root Root part of cache key. The same as in {@link UBConnection#cacheKeyCalculate}\r\n\t * @param {UBCache.cacheTypes} cacheType\r\n\t * @returns {Promise}\r\n\t */\n\tUBConnection.prototype.cacheOccurrenceRefresh = function (root, cacheType) {\n\t  var me = this;\n\t  var cacheKey = void 0,\n\t      machKeys = void 0,\n\t      machRe = void 0;\n\t  var promise = Promise.resolve(true);\n\t  var domain = void 0,\n\t      mixin = void 0,\n\t      domainMixin = void 0;\n\t\n\t  if (cacheType === UBCache.cacheTypes.Session || cacheType === UBCache.cacheTypes.SessionEntity) {\n\t    domain = this.domain.get(root);\n\t    if (domain && domain.hasMixin('unity')) {\n\t      mixin = domain.mixin('unity');\n\t      domainMixin = this.domain.get(mixin.entity);\n\t      if (domainMixin && mixin.entity !== root && domainMixin.cacheType !== UBCache.cacheTypes.None) {\n\t        promise = promise.then(function () {\n\t          me.cacheOccurrenceRefresh(mixin.entity, domainMixin.cacheType);\n\t        });\n\t      }\n\t    }\n\t    cacheKey = me.cacheKeyCalculate(root);\n\t    machRe = new RegExp('^' + cacheKey);\n\t    machKeys = Object.keys(me.cachedSessionEntityRequested).filter(function (item) {\n\t      return machRe.test(item);\n\t    });\n\t    machKeys.forEach(function (key) {\n\t      delete me.cachedSessionEntityRequested[key];\n\t    });\n\t    if (cacheType === UBCache.cacheTypes.Session) {\n\t      promise = promise.then(function () {\n\t        me.cache.removeIfMach(machRe, UBCache.SESSION);\n\t      });\n\t    }\n\t  }\n\t  return promise;\n\t};\n\t\n\t/**\r\n\t * Remove all cache occurrence for root depending on cacheType:\r\n\t *\r\n\t * - clear indexedDB for this root.\r\n\t * - remove entry in {@link UBConnection#cachedSessionEntityRequested}\r\n\t\r\n\t * @param {String} root Root part of cache key. The same as in {@link UBConnection#cacheKeyCalculate}\r\n\t * @param {String} cacheType One of {@link UBCache#cacheTypes}\r\n\t * @returns {Promise}\r\n\t */\n\tUBConnection.prototype.cacheOccurrenceRemove = function (root, cacheType) {\n\t  var me = this;\n\t\n\t  var cacheKey = me.cacheKeyCalculate(root);\n\t  var machRe = new RegExp('^' + cacheKey);\n\t  var machKeys = Object.keys(me.cachedSessionEntityRequested).filter(function (item) {\n\t    return machRe.test(item);\n\t  });\n\t  machKeys.forEach(function (key) {\n\t    delete me.cachedSessionEntityRequested[key];\n\t  });\n\t  var cacheStore = cacheType === UBCache.cacheTypes.Session ? UBCache.SESSION : UBCache.PERMANENT;\n\t  return me.cache.removeIfMach(machRe, cacheStore);\n\t};\n\t\n\t/**\r\n\t * Clear all local cache (indexedDB session & permanent and UBConnection.cachedSessionEntityRequested)\r\n\t * @returns {Promise}\r\n\t */\n\tUBConnection.prototype.cacheClearAll = function () {\n\t  var me = this;\n\t  Object.keys(me.cachedSessionEntityRequested).forEach(function (item) {\n\t    delete me.cachedSessionEntityRequested[item];\n\t  });\n\t  return Promise.all([me.cache.clear(UBCache.SESSION), me.cache.clear(UBCache.PERMANENT)]);\n\t};\n\t\n\t/**\r\n\t * Return instance of UBNativeIITCrypto for PKI operation\r\n\t * @returns {Promise<UBNativeIITCrypto>}\r\n\t */\n\tUBConnection.prototype.pki = function () {\n\t  var me = this;\n\t  return new Promise(function (resolve, reject) {\n\t    if (!me._pki) {\n\t      me._pki = new UBNativeIITCrypto();\n\t      me._pkiInit = me._pki.init();\n\t    }\n\t    me._pkiInit.then(function () {\n\t      resolve(me._pki);\n\t    }, function (reason) {\n\t      reject(reason);\n\t    });\n\t  });\n\t};\n\t\n\t/**\r\n\t * Perform key exchange in case of encrypted communication\r\n\t * @param session\r\n\t * @returns {Promise}\r\n\t */\n\tUBConnection.prototype.exchangeKeys = function (session) {\n\t  var doneAt = void 0,\n\t      now = void 0;\n\t  var me = this;\n\t  if (!me.exchangeKeysPromise) {\n\t    me.exchangeKeysPromise = this.doKeyExchange(session);\n\t  } else {\n\t    // check session key is near to expire. do key exchange if yes\n\t    if (me.exchangeKeysPromise.isFulfilled() && me.encryptionKeyLifetime > 0) {\n\t      doneAt = me.exchangeKeysPromise.valueOf().doneTime;\n\t      now = new Date().getTime();\n\t      if ((now - doneAt) / 1000 > this.encryptionKeyLifetime - 10) {\n\t        me.exchangeKeysPromise = me.doKeyExchange(session);\n\t      }\n\t    }\n\t  }\n\t  return me.exchangeKeysPromise;\n\t};\n\t/**\r\n\t * Shortcut method to perform authorized `GET` request to application we connected\r\n\t * @param {string} url Relative or absolute URL specifying the destination of the request\r\n\t * @param {Object=} [config] Optional configuration object as in {xhr}\r\n\t * @returns {Promise} Future object\r\n\t */\n\tUBConnection.prototype.get = function (url, config) {\n\t  return this.xhr(_.assign({}, config, {\n\t    method: 'GET',\n\t    url: url\n\t  }));\n\t};\n\t\n\t/**\r\n\t * Shortcut method to perform authorized `POST` request to application we connected\r\n\t * @param {string} url Relative or absolute URL specifying the destination of the request\r\n\t * @param {*} data Request content\r\n\t * @param {Object=} [config] Optional configuration object as in {xhr}\r\n\t * @returns {Promise} Future object\r\n\t */\n\tUBConnection.prototype.post = function (url, data, config) {\n\t  return this.xhr(_.assign({}, config, {\n\t    method: 'POST',\n\t    url: url,\n\t    data: data\n\t  }));\n\t};\n\t\n\t/**\r\n\t * Shortcut method to perform authorized/encrypted request to application we connected.\r\n\t * Will:\r\n\t *\r\n\t *  - add Authorization header for non-anonymous sessions\r\n\t *  - add {@link UBConnection#baseURL} to config.url\r\n\t *  - call {@link ub-core.xhr}\r\n\t *  - in case server return 401 clear current authorization,\r\n\t *  call {UBConnection#authorize) and repeat the request\r\n\t *\r\n\t * @param config Request configuration as described in {transport.xhr}\r\n\t * @return {Promise}\r\n\t */\n\tUBConnection.prototype.xhr = function (config) {\n\t  var me = this;\n\t  var cfg = _.assign({ headers: {} }, config);\n\t  var url = cfg.url;\n\t  var isBase64 = false;\n\t  var promise = void 0;\n\t\n\t  if (me.recorderEnabled) {\n\t    me.recordedXHRs.push(config);\n\t  }\n\t  // prepend baseURl only if not already prepended\n\t  if (url.length < me.baseURL.length || url.substring(0, me.baseURL.length) !== me.baseURL) {\n\t    cfg.url = me.baseURL + cfg.url;\n\t  }\n\t\n\t  if (NON_AUTH_URLS_RE.test(url)) {\n\t    // request not require authentication - pass is as is\n\t    promise = transport.xhr(cfg);\n\t  } else {\n\t    promise = me.authorize();\n\t    if (me.trafficEncryption && !NON_ENCRYPTED_URLS_RE.test(url)) {\n\t      promise = promise.then(function (session) {\n\t        return me.exchangeKeys(session);\n\t      }).then(function () {\n\t        var dataType = _typeof(cfg.data);\n\t        // string and stringified objects is not need to be base64 encoded. Anything else - must\n\t        if (dataType === 'string' || dataType === 'object' && !(cfg.data instanceof Blob) && !cfg.data.byteLength) {\n\t          return JSON.stringify(cfg.data);\n\t        } else {\n\t          isBase64 = true;\n\t          return ubUtils.base64FromAny(cfg.data);\n\t        }\n\t      }).then(function (sendData) {\n\t        cfg.transformResponse = decryptResponse;\n\t        cfg.responseType = 'arraybuffer';\n\t        cfg.transformRequest = function (data) {\n\t          return data;\n\t        }; // NOP\n\t        if (sendData) {\n\t          var _ret = function () {\n\t            var compress = sendData.length > 1000;\n\t            return {\n\t              v: me.channelEncryptor.encryptToArray(sendData, isBase64, compress).then(function (encryptToArrayRes) {\n\t                cfg.headers['Content-Encoding'] = compress ? 'UBEZ' : 'UBE';\n\t                cfg.data = new Uint8Array(encryptToArrayRes);\n\t              })\n\t            };\n\t          }();\n\t\n\t          if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t        } else {\n\t          return true;\n\t        }\n\t      });\n\t    }\n\t    promise = promise.then(function () {\n\t      // we must repeat authorize to obtain new session key ( because key exchange may happens before)\n\t      return me.authorize().then( /** @param {UBSession} session */function (session) {\n\t        var head = session.authHeader();\n\t        if (head) cfg.headers.Authorization = head; // do not add header for anonymous session\n\t        return transport.xhr(cfg);\n\t      });\n\t    }).catch(function (reason) {\n\t      // in case of 401 - do auth and repeat request\n\t      var errMsg = '';\n\t      if (reason.status === 401) {\n\t        ubUtils.logDebug('unauth: %o', reason);\n\t        if (me.isAuthorized()) {\n\t          me.authorizationClear();\n\t        }\n\t        // reason.config.url: \"/bla-bla/logout\"\n\t        if (reason.config.url && /\\/logout/.test(reason.config.url)) {\n\t          me.lastLoginName = '';\n\t        } else {\n\t          transport.xhr.allowRequestReiteration(); // prevent a monkeyRequestsDetected error during relogon [UB-1699]\n\t          return me.xhr(config);\n\t        }\n\t      }\n\t\n\t      if (reason.data && reason.data.hasOwnProperty('errCode')) {\n\t        // this is server side error response\n\t        var errCode = reason.data.errCode;\n\t        var errDetails = errMsg = reason.data.errMsg;\n\t\n\t        if (/<<<.*>>>/.test(errMsg)) {\n\t          // this is custom error\n\t          errMsg = i18n(errMsg.match(/<<<(.*)>>>/)[1]); // extract rear message and translate\n\t        }\n\t        /**\r\n\t         * Fired for {@link UBConnection} instance in case user password is expired. The only valid endpoint after this is `changePassword`\r\n\t         * @event passwordExpired\r\n\t         */\n\t        if (errCode === 72 && me.emit('passwordExpired')) {\n\t          throw new ubUtils.UBAbortError();\n\t        }\n\t        throw new ubUtils.UBError(errMsg, errDetails, errCode);\n\t      } else {\n\t        throw reason; //! Important - rethrow the reason is important. Do not create a new Error here\n\t      }\n\t    });\n\t  }\n\t  return promise;\n\t\n\t  function decryptResponse(data, headers) {\n\t    var encoding = (headers('content-encoding') || '').toUpperCase();\n\t    var compressed = encoding === 'UBEZ';\n\t    var encrypted = compressed || encoding === 'UBE';\n\t    var jsonContent = (headers('content-type') || '').indexOf('json') >= 0;\n\t    var resAsBase64 = config.responseType === 'arraybuffer';\n\t\n\t    var promise = Promise.resolve(data);\n\t    if (encrypted) {\n\t      promise = promise.then(function (dataPromise) {\n\t        return me.channelEncryptor.decryptArr(dataPromise, resAsBase64, compressed);\n\t      });\n\t    }\n\t    return promise.then(function (dataPromise) {\n\t      if (config.responseType === 'arraybuffer') {\n\t        dataPromise = ubUtils.base64toArrayBuffer(dataPromise);\n\t      }\n\t      if (typeof dataPromise === 'string' && jsonContent) {\n\t        try {\n\t          dataPromise = JSON.parse(dataPromise);\n\t        } catch (err) {\n\t          console.log(dataPromise);\n\t          throw err;\n\t        }\n\t      }\n\t      return dataPromise;\n\t    });\n\t  }\n\t};\n\t/**\r\n\t * Base64 encoded server certificate\r\n\t * @property {String} serverCertificate\r\n\t * @readonly */\n\t/** Lifetime (in second) of session encryption\r\n\t * @property {Number} encryptionKeyLifetime\r\n\t * @readonly */\n\t/**\r\n\t * Possible server authentication method\r\n\t * @property {Array.<string>} authMethods\r\n\t * @readonly */\n\t/**\r\n\t * Retrieve application information. Usually this is first method developer must call after create connection\r\n\t * @method\r\n\t * @returns {Promise}  Promise resolved to result of getAppInfo method\r\n\t */\n\tUBConnection.prototype.getAppInfo = function () {\n\t  var me = this;\n\t  return me.get('getAppInfo') // non-auth request\n\t  .then(function (resp) {\n\t    var appInfo = resp.data;\n\t    /** Is server require content encryption\r\n\t     * @property {Boolean} trafficEncryption\r\n\t     * The base of all urls of your requests. Will be prepend to all urls.\r\n\t     * @readonly */\n\t    Object.defineProperty(me, 'trafficEncryption', { enumerable: true, writable: false, value: appInfo.trafficEncryption || false });\n\t    /** The server certificate for cryptographic operations (base46 encoded)\r\n\t     * @property {Boolean} serverCertificate\r\n\t     * @readonly */\n\t    Object.defineProperty(me, 'serverCertificate', { enumerable: true, writable: false, value: appInfo.serverCertificate || '' });\n\t    Object.defineProperty(me, 'encryptionKeyLifetime', { enumerable: true, writable: false, value: appInfo.encryptionKeyLifetime || 0 });\n\t    Object.defineProperty(me, 'authMethods', { enumerable: true, writable: false, value: appInfo.authMethods });\n\t    /**\r\n\t     * An array of WebSocket protocol names supported by server\r\n\t     * @property {Array<String>} supportedWSProtocols\r\n\t     */\n\t    Object.defineProperty(me, 'supportedWSProtocols', { enumerable: true, writable: false, value: appInfo.supportedWSProtocols || [] });\n\t    /** UnityBase server version\r\n\t     * @property {String} serverVersion\r\n\t     * @readonly\r\n\t     */\n\t    Object.defineProperty(me, 'serverVersion', { enumerable: true, writable: false, value: appInfo.serverVersion || '' });\n\t    ubUtils.apply(me.appConfig, appInfo.uiSettings.adminUI);\n\t    return appInfo;\n\t  });\n\t};\n\t\n\t/**\r\n\t * Retrieve domain information from server. Promise resolve instance of UBDomain.\r\n\t * @param {Function} [callBack] This parameter will be deleted in next version\r\n\t * @returns {Promise}\r\n\t */\n\tUBConnection.prototype.getDomainInfo = function (callBack) {\n\t  var me = this;\n\t  return me.get('getDomainInfo', { params: {\n\t      v: 4, userName: this.userLogin() }\n\t  }).then(function (response) {\n\t    var result = response.data;\n\t    var domain = new UBDomain(result);\n\t    me.domain = domain;\n\t    if (callBack) {\n\t      callBack(result, domain);\n\t    }\n\t    return domain;\n\t  });\n\t};\n\t\n\t/**\r\n\t * If connection require encryption then initialize UBConnection.channelEncryptor\r\n\t * @return {Promise}\r\n\t */\n\tUBConnection.prototype.initEncriptionIfNeed = function () {\n\t  var me = this;\n\t  if (me.trafficEncryption && !me.channelEncryptor) {\n\t    if (!me.serverCertificate) {\n\t      me.channelEncryptor = null;\n\t      return Promise.reject(new Error('During call to getAppInfo server not return certificate required for encrypted communication'));\n\t    } else {\n\t      me.channelEncryptor = new UBNativeDSTUCrypto();\n\t      return me.channelEncryptor.init(me.serverCertificate);\n\t    }\n\t  } else {\n\t    return Promise.resolve(true);\n\t  }\n\t};\n\t\n\t/**\r\n\t * Generate session encryption key and send it to server inside envelope.\r\n\t * Must be called for encrypted communication AFTER call to\r\n\t *  {@link UBConnection#getAppInfo getAppInfo} and authenticate user\r\n\t * @returns {Promise}\r\n\t * @private\r\n\t */\n\tUBConnection.prototype.doKeyExchange = function (session) {\n\t  var me = this;\n\t  if (!me.trafficEncryption) {\n\t    return Promise.resolve({\n\t      doneTime: 0,\n\t      trafficEncryption: me.trafficEncryption\n\t    });\n\t  }\n\t  if (!me.isAuthorized()) {\n\t    return Promise.reject({ errMsg: 'must be authorized before do key agreement' });\n\t  }\n\t  // TODO - wait for pending requests before call to getEnvelopeWithKey\n\t  // let envelope =\n\t  return me.channelEncryptor.getEnvelopeWithKey().then(function (envelope) {\n\t    var initEncryptionRequest = {\n\t      url: 'initEncryption',\n\t      method: 'POST',\n\t      data: envelope,\n\t      headers: {\n\t        'Content-Type': 'application/octet-stream',\n\t        'Authorization': 'UB ' + session.signature()\n\t      }\n\t    };\n\t    return me.xhr(initEncryptionRequest);\n\t  }).then(function () {\n\t    return {\n\t      doneTime: new Date().getTime(),\n\t      trafficEncryption: me.trafficEncryption\n\t    };\n\t  });\n\t};\n\t\n\t/**\r\n\t * Process buffered requests from this._bufferedRequests\r\n\t * @private\r\n\t */\n\tUBConnection.prototype.processBuffer = function processBuffer() {\n\t  var me = this;\n\t  var bufferCopy = me._bufferedRequests;\n\t  // get ready to new buffer queue\n\t  me._bufferTimeoutID = 0;\n\t  me._bufferedRequests = [];\n\t\n\t  me.post('ubql', _.map(bufferCopy, 'request')).then(function (responses) {\n\t    // we expect responses in order we send requests to server\n\t    bufferCopy.forEach(function (bufferedRequest, num) {\n\t      bufferedRequest.deferred.resolve(responses.data[num]);\n\t    });\n\t  }, function (failReason) {\n\t    bufferCopy.forEach(function (bufferedRequest) {\n\t      bufferedRequest.deferred.reject(failReason);\n\t    });\n\t  });\n\t};\n\t\n\t/**\r\n\t * Promise of running UBQL command(s) (asynchronously).\r\n\t * The difference from {@link UBConnection.post} is:\r\n\t *\r\n\t * - ability to buffer request: can merge several `query` in the 20ms period into one ubql call\r\n\t *\r\n\t * For well known UnityBase methods use aliases (addNew, select, insert, update, doDelete)\r\n\t * @param {Object} ubq    Request to execute\r\n\t * @param {String} ubq.entity Entity to execute the method\r\n\t * @param {String} ubq.method Method of entity to executed\r\n\t * @param {Array.<String>} [ubq.fieldList]\r\n\t * @param {Object} [ubq.whereList]\r\n\t * @param {Object} [ubq.execParams]\r\n\t * @param {Number} [ubq.ID]\r\n\t * @param {Object} [ubq.options]\r\n\t * @param {String} [ubq.lockType]\r\n\t * @param {Boolean} [ubq.__skipOptimisticLock] In case this parameter true and in the buffered\r\n\t * @param {Boolean} [ubq.__nativeDatasetFormat]\r\n\t * @param {Boolean} [allowBuffer] Allow buffer this request to single runList. False by default\r\n\t * @method\r\n\t * @returns {Promise}\r\n\t *\r\n\t * Example:\r\n\t *\r\n\t *      //this two execution is passed to single ubql server execution\r\n\t *      $App.connection.query({entity: 'uba_user', method: 'select', fieldList: ['*']}, true).then(UB.logDebug);\r\n\t *      $App.connection.query({entity: 'ubm_navshortcut', method: 'select', fieldList: ['*']}, true).then(UB.logDebug);\r\n\t *\r\n\t *      //but this request is passed in separate ubql (because allowBuffer false in first request\r\n\t *      $App.connection.query({entity: 'uba_user', method: 'select', fieldList: ['*']}).then(UB.logDebug);\r\n\t *      $App.connection.query({entity: 'ubm_desktop', method: 'select', fieldList: ['*']}, true).then(UB.logDebug);\r\n\t */\n\tUBConnection.prototype.query = function query(ubq, allowBuffer) {\n\t  var me = this;\n\t  if (allowBuffer === undefined || allowBuffer === false || !BUFFERED_DELAY) {\n\t    return me.post('ubql', [ubq]).then(function (response) {\n\t      return response.data[0];\n\t    });\n\t  } else {\n\t    if (!this._bufferTimeoutID) {\n\t      this._bufferTimeoutID = setTimeout(me.processBuffer.bind(me), BUFFERED_DELAY);\n\t    }\n\t    return new Promise(function (resolve, reject) {\n\t      me._bufferedRequests.push({ request: ubq, deferred: { resolve: resolve, reject: reject } });\n\t    });\n\t  }\n\t};\n\t\n\t/**\r\n\t * @deprecated Since UB 1.11 use `query` method\r\n\t * @private\r\n\t */\n\tUBConnection.prototype.run = UBConnection.prototype.query;\n\t\n\t/**\r\n\t * Convert raw server response data to javaScript data according to attribute types.\r\n\t * Called by {@link UBConnection#select}\r\n\t * Currently only Data/DateTime & boolean conversion done\r\n\t * If resultLock present - resultLock.lockTime also converted\r\n\t *\r\n\t *      // convert all string representation of date/dateTime to Date object, integer representation of bool to Boolean\r\n\t *      return me.query({entity: 'my_entity', method: 'select'}, true)\r\n\t *          .then(me.convertResponseDataToJsTypes.bind(me));\r\n\t *\r\n\t * @method\r\n\t * @param serverResponse\r\n\t * @returns {*}\r\n\t */\n\tUBConnection.prototype.convertResponseDataToJsTypes = function (serverResponse) {\n\t  var convertRules = void 0,\n\t      rulesLen = void 0,\n\t      dataLen = void 0,\n\t      data = void 0,\n\t      d = void 0,\n\t      r = void 0,\n\t      column = void 0;\n\t  if (serverResponse.entity && // fieldList &&  serverResponse.fieldList\n\t  serverResponse.resultData && !serverResponse.resultData.notModified && serverResponse.resultData.fields && serverResponse.resultData.data && serverResponse.resultData.data.length) {\n\t    convertRules = this.domain.get(serverResponse.entity).getConvertRules(serverResponse.resultData.fields);\n\t    rulesLen = convertRules.length;\n\t    data = serverResponse.resultData.data;\n\t    dataLen = data.length;\n\t    if (rulesLen) {\n\t      for (d = 0; d < dataLen; d++) {\n\t        for (r = 0; r < rulesLen; r++) {\n\t          column = convertRules[r].index;\n\t          data[d][column] = convertRules[r].convertFn(data[d][column]);\n\t        }\n\t      }\n\t    }\n\t  }\n\t  if (serverResponse.resultLock && serverResponse.resultLock.lockTime) {\n\t    serverResponse.resultLock.lockTime = ubUtils.iso8601Parse(serverResponse.resultLock.lockTime);\n\t  }\n\t  return serverResponse;\n\t};\n\t\n\t/**\r\n\t * Call a {@link LocalDataStore#doFilterAndSort} - see a parameters there\r\n\t * @protected\r\n\t * @param {TubCachedData} cachedData\r\n\t * @param {TubSelectRequest} ubRequest\r\n\t * @returns {Object}\r\n\t */\n\tUBConnection.prototype.doFilterAndSort = function (cachedData, ubRequest) {\n\t  return LocalDataStore.doFilterAndSort(cachedData, ubRequest);\n\t};\n\t\n\t/**\r\n\t * Promise of running UBQL command with `addNew` method (asynchronously).\r\n\t * Two difference from {@link UBConnection.query}:\r\n\t *\r\n\t * - ubRequest.method set to 'addnew'\r\n\t * - requests is always buffered in the 20ms period into one ubql call\r\n\t * - `Date` & 'DateTime' entity attributes are converted from ISO8601 text representation to javaScript Date object\r\n\t *\r\n\t * Example:\r\n\t *\r\n\t *      $App.connection.addNew({entity: 'uba_user', fieldList: ['*']}).then(UB.logDebug);\r\n\t *\r\n\t * @param {Object} serverRequest    Request to execute\r\n\t * @param {String} serverRequest.entity Entity to execute the method\r\n\t * @param {String} [serverRequest.method] Method of entity to executed. Default to 'select'\r\n\t * @param {Array.<string>} serverRequest.fieldList\r\n\t * @param {Object} [serverRequest.execParams]\r\n\t * @param {Object} [serverRequest.options]\r\n\t * @param {String} [serverRequest.lockType]\r\n\t * @param {Boolean} [serverRequest.alsNeed]\r\n\t * @returns {Promise}\r\n\t */\n\tUBConnection.prototype.addNew = function (serverRequest) {\n\t  var me = this;\n\t  serverRequest.method = 'addnew';\n\t  return me.query(serverRequest, true).then(me.convertResponseDataToJsTypes.bind(me));\n\t};\n\t\n\t/**\r\n\t * Called in update/insert/delete methods and if request entity is cached then clear cache\r\n\t * @private\r\n\t * @param serverResponse\r\n\t * @return {Promise} Promise resolved to serverResponse\r\n\t */\n\tUBConnection.prototype.invalidateCache = function (serverResponse) {\n\t  var me = this;\n\t  var cacheType = me.domain.get(serverResponse.entity).cacheType;\n\t  if (cacheType === UBCache.cacheTypes.none) {\n\t    return serverResponse;\n\t  }\n\t  return me.cacheOccurrenceRefresh(serverResponse.entity, cacheType).then(function () {\n\t    return serverResponse;\n\t  });\n\t};\n\t\n\t/**\r\n\t * Promise of running UBQL command with `update` method (asynchronously).\r\n\t * Difference from {@link UBConnection.query}:\r\n\t *\r\n\t * - ubRequest.method set to 'update'\r\n\t * - `Date` & 'DateTime' entity attributes are converted from ISO8601 text representation to javaScript Date object\r\n\t * - if necessary it will clear cache\r\n\t *\r\n\t * Example:\r\n\t *\r\n\t *      $App.connection.update({entity: 'uba_user', fieldList: ['ID','name'], execParams: {ID: 1, name:'newName'}}).then(UB.logDebug);\r\n\t *\r\n\t * @param {Object} serverRequest    Request to execute\r\n\t * @param {String} serverRequest.entity Entity to execute the method\r\n\t * @param {String} [serverRequest.method] Method of entity to executed. Default to 'update'\r\n\t * @param {Array.<string>} serverRequest.fieldList\r\n\t * @param {Object} [serverRequest.execParams]\r\n\t * @param {Object} [serverRequest.options]\r\n\t * @param {String} [serverRequest.lockType]\r\n\t * @param {Boolean} [serverRequest.alsNeed]\r\n\t * @param {Boolean} [allowBuffer] Default - false. Allow several \"in the same time\" request to be buffered to one transaction.\r\n\t * @returns {Promise}\r\n\t */\n\tUBConnection.prototype.update = function (serverRequest, allowBuffer) {\n\t  var me = this;\n\t  serverRequest.method = serverRequest.method || 'update';\n\t  return me.query(serverRequest, allowBuffer).then(me.convertResponseDataToJsTypes.bind(me)).then(me.invalidateCache.bind(me));\n\t};\n\t\n\t/**\r\n\t * Promise of running UnityBase UBQL command with `insert` method (asynchronously).\r\n\t * Difference from {@link UBConnection.query}:\r\n\t *\r\n\t * - ubRequest.method set to 'insert'\r\n\t * - `Date` & 'DateTime' entity attributes are converted from ISO8601 text representation to javaScript Date object\r\n\t * - if necessary it will clear cache\r\n\t *\r\n\t * @param {Object} serverRequest    Request to execute\r\n\t * @param {String} serverRequest.entity Entity to execute the method\r\n\t * @param {String} [serverRequest.method] Method of entity to executed. Default to 'insert'\r\n\t * @param {Array.<string>} serverRequest.fieldList\r\n\t * @param {Object} [serverRequest.execParams]\r\n\t * @param {Object} [serverRequest.options]\r\n\t * @param {String} [serverRequest.lockType]\r\n\t * @param {Boolean} [serverRequest.alsNeed]\r\n\t *\r\n\t * @param {Boolean} [allowBuffer] Default - false. Allow several \"in the same time\" request to be buffered to one transaction.\r\n\t *\r\n\t * @method\r\n\t * @returns {Promise}\r\n\t *\r\n\t * Example:\r\n\t *\r\n\t *      $App.connection.insert({entity: 'uba_user', fieldList: ['ID','name'], execParams: {ID: 1, name:'newName'}).then(UB.logDebug);\r\n\t *\r\n\t */\n\tUBConnection.prototype.insert = function (serverRequest, allowBuffer) {\n\t  var me = this;\n\t  serverRequest.method = serverRequest.method || 'insert';\n\t  return me.query(serverRequest, allowBuffer).then(me.convertResponseDataToJsTypes.bind(me)).then(me.invalidateCache.bind(me));\n\t};\n\t\n\t/**\r\n\t * Promise of running UBQL command with delete method (asynchronously).\r\n\t * Difference from {@link UBConnection.query}:\r\n\t *\r\n\t * - ubRequest.method set to 'delete' by default\r\n\t * - if necessary it will clear cache\r\n\t *\r\n\t * @param {Object} serverRequest    Request to execute\r\n\t * @param {String} serverRequest.entity Entity to execute the method\r\n\t * @param {String} [serverRequest.method] Method of entity to executed. Default to 'delete'\r\n\t * @param {Object} [serverRequest.execParams]\r\n\t * @param {Object} [serverRequest.options]\r\n\t * @param {String} [serverRequest.lockType]\r\n\t * @param {Boolean} [serverRequest.alsNeed]\r\n\t *\r\n\t * @param {Boolean} [allowBuffer] Default - false. Allow several \"in the same time\" request to be buffered to one transaction.\r\n\t *\r\n\t * @method\r\n\t * @returns {Promise}\r\n\t *\r\n\t * Example:\r\n\t *\r\n\t *      $App.connection.doDelete({entity: 'uba_user', fieldList: ['ID','name'], execParams: {ID: 1, name:'newName'}).then(UB.logDebug);\r\n\t *\r\n\t */\n\tUBConnection.prototype.doDelete = function (serverRequest, allowBuffer) {\n\t  var me = this;\n\t  serverRequest.method = serverRequest.method || 'delete';\n\t  return me.query(serverRequest, allowBuffer).then(me.invalidateCache.bind(me));\n\t};\n\t\n\t/**\r\n\t * Promise of running UBQL (asynchronously).\r\n\t * Two difference from {@link UBConnection.query}:\r\n\t *\r\n\t * - ubRequest.method by default set to 'select'\r\n\t * - requests is always buffered in the 20ms period into one ubql call\r\n\t * - `Date` & 'DateTime' entity attributes are converted from ISO8601 text representation to javaScript Date object\r\n\t * - if request entity is cached - cache used\r\n\t *\r\n\t * @param {Object} serverRequest    Request to execute\r\n\t * @param {String} serverRequest.entity Entity to execute the method\r\n\t * @param {String} [serverRequest.method] Method of entity to executed. Default to 'select'\r\n\t * @param {Number} [serverRequest.ID] if passed - request bypass cache, where & order list is ignored. Can be used to load single record from server\r\n\t * @param {Array.<string>} serverRequest.fieldList\r\n\t * @param {Object} [serverRequest.whereList]\r\n\t * @param {Object} [serverRequest.execParams]\r\n\t * @param {Object} [serverRequest.options]\r\n\t * @param {String} [serverRequest.lockType]\r\n\t * @param {Boolean} [serverRequest.alsNeed]\r\n\t * @param {Boolean} [serverRequest.__skipOptimisticLock] In case this parameter true and in the buffered\r\n\t * @param {Boolean} [bypassCache=false] Do not use cache while request even if entity cached.\r\n\t *   If  `__mip_disablecache: true` is passed in serverRequest cache is also disabled.\r\n\t * @method\r\n\t * @returns {Promise}\r\n\t *\r\n\t * Example:\r\n\t *\r\n\t *      //retrieve users\r\n\t *      $App.connection.select({entity: 'uba_user', fieldList: ['*']}).then(UB.logDebug);\r\n\t *\r\n\t *      //retrieve users and desktops and then both done - do something\r\n\t *      Promise.all($App.connection.select({entity: 'uba_user', fieldList: ['ID', 'name']})\r\n\t *        $App.connection.select({entity: 'ubm_desktop', fieldList: ['ID', 'code']})\r\n\t *      ).then(UB.logDebug);\r\n\t */\n\tUBConnection.prototype.select = function (serverRequest, bypassCache) {\n\t  var me = this;\n\t  var cacheTypes = UBCache.cacheTypes;\n\t  var serverRequestWOLimits = {};\n\t  var dataPromise = void 0,\n\t      cKey = void 0,\n\t      cacheStoreName = void 0;\n\t  /**\r\n\t   *\r\n\t   * @param {Object} serverResponse\r\n\t   * @param {Object} serverResponse.resultData       miscmimi\r\n\t   * @param {Boolean} [serverResponse.resultData.notModified]\r\n\t   * @param {String} storeName\r\n\t   * @returns {*}\r\n\t   */\n\t  var processVersionedResponse = function processVersionedResponse(serverResponse, storeName) {\n\t    if (serverResponse.resultData.notModified) {\n\t      // in case we refresh cachedSessionEntityRequested or just after login - put version to cachedSessionEntityRequested\n\t      me.cachedSessionEntityRequested[cKey] = serverResponse.version;\n\t      return me.cache.get(cKey, storeName);\n\t    } else {\n\t      return me.cache.put([{ key: cKey + ':v', value: serverResponse.version }, { key: cKey, value: serverResponse.resultData }], storeName).then(function () {\n\t        me.cachedSessionEntityRequested[cKey] = serverResponse.version;\n\t        return serverResponse.resultData;\n\t      });\n\t    }\n\t  };\n\t\n\t  bypassCache = bypassCache || serverRequest.__mip_disablecache === true;\n\t  var cacheType = bypassCache || serverRequest.ID || serverRequest.bypassCache ? UBCache.cacheTypes.None : me.domain.get(serverRequest.entity).cacheType;\n\t\n\t  if (!serverRequest.method) {\n\t    serverRequest.method = 'select';\n\t  }\n\t  // if exist expression where ID = ... bypass cache\n\t  //        if (idInWhere(serverRequest.whereList)){\n\t  //            cacheType = cacheTypes.None;\n\t  //        }\n\t  if (cacheType === cacheTypes.None) {\n\t    // where & order is done by server side\n\t    dataPromise = me.query(serverRequest, true).then(me.convertResponseDataToJsTypes.bind(me)).then(function (response) {\n\t      var responseWithTotal = {};\n\t      ubUtils.apply(responseWithTotal, response);\n\t      if (response.__totalRecCount) {\n\t        responseWithTotal.total = response.__totalRecCount;\n\t      } else if (response.resultData && response.resultData.data) {\n\t        var resRowCount = response.resultData.data.length;\n\t        if (!serverRequest.options) {\n\t          responseWithTotal.total = resRowCount;\n\t        } else {\n\t          var opt = serverRequest.options || {};\n\t          var start = opt.start ? opt.start : 0;\n\t          var limit = opt.limit || 0;\n\t          // in case we fetch less data then requested - this is last page and we know total\n\t          responseWithTotal.total = resRowCount < limit ? start + resRowCount : -1;\n\t        }\n\t      }\n\t      return responseWithTotal;\n\t    });\n\t  } else {\n\t    // where & order is done by client side\n\t    // TODO check all filtered attribute is present in whereList - rewrite me.checkFieldList(operation);\n\t    cKey = me.cacheKeyCalculate(serverRequest.entity, serverRequest.fieldList);\n\t    cacheStoreName = cacheType === cacheTypes.Session ? UBCache.SESSION : UBCache.PERMANENT;\n\t    // retrieve data either from cache or from server\n\t    dataPromise = me.cache.get(cKey + ':v', cacheStoreName).then(function (version) {\n\t      var cachedPromise = void 0;\n\t      if (!version || // no data in cache or invalid version\n\t      // or must re-validate version\n\t      version && cacheType === cacheTypes.Entity ||\n\t      // or SessionEntity cached not this current cache version\n\t      version && cacheType === cacheTypes.SessionEntity && me.cachedSessionEntityRequested[cKey] !== version) {\n\t        ubUtils.apply(serverRequestWOLimits, serverRequest);\n\t        delete serverRequestWOLimits.whereList;\n\t        delete serverRequestWOLimits.orderList;\n\t        delete serverRequestWOLimits.options;\n\t        serverRequestWOLimits.version = version || '-1';\n\t        cachedPromise = me.query(serverRequestWOLimits, true).then(me.convertResponseDataToJsTypes.bind(me)).then(function (response) {\n\t          return processVersionedResponse(response, cacheStoreName);\n\t        });\n\t      } else {\n\t        // retrieve data from cache\n\t        cachedPromise = me.cache.get(cKey, cacheStoreName);\n\t      }\n\t      return cachedPromise;\n\t    }).then(function (cacheResponse) {\n\t      // noinspection JSCheckFunctionSignatures\n\t      return me.doFilterAndSort(cacheResponse, serverRequest);\n\t    });\n\t  }\n\t  return dataPromise;\n\t};\n\t\n\t/**\r\n\t * Alias to {@link LocalDataStore#selectResultToArrayOfObjects LocalDataStore.selectResultToArrayOfObjects}\r\n\t *\r\n\t * @param {{resultData: {data: Array.<Array>, fields: Array.<String>}}} selectResult\r\n\t * @returns {Array.<*>}\r\n\t * @private\r\n\t * @deprecated Use LocalDataStore.selectResultToArrayOfObjects\r\n\t */\n\tUBConnection.selectResultToArrayOfObjects = LocalDataStore.selectResultToArrayOfObjects;\n\t\n\t/**\r\n\t * Execute numbers of ubRequest in one server request (one transaction)\r\n\t *\r\n\t *      $App.connection.runTrans([\r\n\t *           { entity: 'my_entity', method: 'update', ID: 1, execParams: {code: 'newCode'} },\r\n\t *           { entity: 'my_entity', method: 'update', ID: 2, execParams: {code: 'newCodeforElementWithID=2'} },\r\n\t *       ]).then(UB.logDebug);\r\n\t *\r\n\t * @method\r\n\t * @param {Array.<ubRequest>} ubRequestArray\r\n\t * @returns {Promise} Resolved to response.data\r\n\t */\n\tUBConnection.prototype.runTrans = function run(ubRequestArray) {\n\t  var me = this;\n\t  return me.post('ubql', ubRequestArray).then(function (response) {\n\t    return response.data;\n\t  });\n\t};\n\t\n\tvar ALLOWED_GET_DOCUMENT_PARAMS = ['entity', 'attribute', 'ID', 'id', 'isDirty', 'forceMime', 'fileName', 'store', 'revision'];\n\t/**\r\n\t * Retrieve content of `document` type attribute field from server. Usage samples:\r\n\t *\r\n\t *      //Retrieve content of document as string using GET\r\n\t *      $App.connection.getDocument({\r\n\t *          entity:'ubm_form',\r\n\t *          attribute: 'formDef',\r\n\t *          ID: 100000232003\r\n\t *       }).then(function(result){console.log(typeof result)}); // string\r\n\t *\r\n\t *      //The same, but using POST for bypass cache\r\n\t *      $App.connection.getDocument({\r\n\t *          entity:'ubm_form',\r\n\t *          attribute: 'formDef',\r\n\t *          ID: 100000232003\r\n\t *       }, {\r\n\t *          bypassCache: true\r\n\t *       }).then(function(result){console.log(typeof result)}); // string\r\n\t *\r\n\t *\r\n\t *      //Retrieve content of document as ArrayBuffer and bypass cache\r\n\t *      $App.connection.getDocument({\r\n\t *          entity:'ubm_form',\r\n\t *          attribute: 'formDef',\r\n\t *          ID: 100000232003\r\n\t *       }, {\r\n\t *          bypassCache: true, resultIsBinary: true\r\n\t *       }).then(function(result){\r\n\t *          console.log('Result is', typeof result, 'of length' , result.byteLength, 'bytes'); //output: Result is object of length 2741 bytes\r\n\t *       });\r\n\t *\r\n\t * @param {Object} params\r\n\t * @param {String} params.entity Code of entity to retrieve from\r\n\t * @param {String} params.attribute `document` type attribute code\r\n\t * @param {Number} params.id Instance ID\r\n\t * @param {String} [params.forceMime] If passed and server support transformation from source MIME type to `forceMime` server perform transformation and return documenRt representation in the passed MIME\r\n\t * @param {Number} [params.revision] Optional revision of the documnet (if supported by server-side store configuration). Default is current revision.\r\n\t * @param {String} [params.fileName] ????\r\n\t * @param {Boolean} [params.isDirty=false] Optional ability to retrieve document in **dirty** state\r\n\t * @param {String} [params.store] ????\r\n\t *\r\n\t * @param {Object} [options] Additional request options\r\n\t * @param {Boolean} [options.resultIsBinary=false] if true - return document content as arrayBuffer\r\n\t * @param {Boolean} [options.bypassCache] HTTP POST verb will be used instead of GET for bypass browser cache\r\n\t * @returns {Promise} Resolved to document content (either ArrayBuffer in case options.resultIsBinary===true or text/json)\r\n\t */\n\tUBConnection.prototype.getDocument = function (params, options) {\n\t  var opt = _.defaults({}, options);\n\t  var reqParams = {\n\t    url: 'getDocument',\n\t    method: opt.bypassCache ? 'POST' : 'GET'\n\t  };\n\t  if (options && options.resultIsBinary) {\n\t    reqParams.responseType = 'arraybuffer';\n\t  }\n\t  if (opt.bypassCache) {\n\t    reqParams.data = _.clone(params);\n\t    Object.keys(reqParams.data).forEach(function (key) {\n\t      if (ALLOWED_GET_DOCUMENT_PARAMS.indexOf(key) === -1) {\n\t        delete reqParams.data[key];\n\t        ubUtils.logDebug('invalid parameter \"' + key + '\" passed to getDocument request');\n\t      }\n\t    });\n\t  } else {\n\t    reqParams.params = params;\n\t  }\n\t  return this.xhr(reqParams).then(function (response) {\n\t    return response.data;\n\t  });\n\t};\n\t\n\t/**\r\n\t * Alias to {@link UBSession.hexa8 UBSession.hexa8}\r\n\t * @private\r\n\t * @deprecated since 1.8 use UBSession.prototype.hexa8 instead\r\n\t */\n\tUBConnection.prototype.hexa8 = UBSession.prototype.hexa8;\n\t\n\t/**\r\n\t * Alias to {@link UBSession.hexa8 UBSession.crc32}\r\n\t * @private\r\n\t * @deprecated since 1.8 use UBSession.prototype.crc32 instead\r\n\t */\n\tUBConnection.prototype.crc32 = UBSession.prototype.crc32;\n\t\n\t/**\r\n\t * Log out user from server\r\n\t */\n\tUBConnection.prototype.logout = function () {\n\t  var me = this;\n\t  if (me.isAuthorized()) {\n\t    return me.post('logout', {}).then(function () {\n\t      return new Promise(function (resolve) {\n\t        setTimeout(function () {\n\t          if (me._pki) {\n\t            me._pki.closePK();\n\t          }\n\t          resolve(true);\n\t        }, 20);\n\t      });\n\t    });\n\t  } else {\n\t    return Promise.resolve(true);\n\t  }\n\t};\n\t\n\t/**\r\n\t * Known server-side error codes\r\n\t * @enum\r\n\t * @private\r\n\t */\n\tUBConnection.prototype.serverErrorCodes = {\n\t  1: 'ubErrNotImplementedErrnum',\n\t  2: 'ubErrRollbackedErrnum',\n\t  3: 'ubErrNotExecutedErrnum',\n\t  4: 'ubErrInvaliddataforrunmethod',\n\t  5: 'ubErrInvaliddataforrunmethodlist',\n\t  6: 'ubErrNoMethodParameter',\n\t  7: 'ubErrMethodNotExist',\n\t  8: 'ubErrElsAccessDeny',\n\t  9: 'ubErrElsInvalidUserOrPwd',\n\t  10: 'ubErrElsNeedAuth',\n\t  11: 'ubErrNoEntityParameter',\n\t  13: 'ubErrNoSuchRecord',\n\t  14: 'ubErrInvalidDocpropFldContent',\n\t  15: 'ubErrEntityNotExist',\n\t  16: 'ubErrAttributeNotExist',\n\t  17: 'ubErrNotexistEntitymethod',\n\t  18: 'ubErrInvalidSetdocData',\n\t  19: 'ubErrSoftlockExist',\n\t  20: 'ubErrNoErrorDescription',\n\t  21: 'ubErrUnknownStore',\n\t  22: 'ubErrObjdatasrcempty',\n\t  23: 'ubErrObjattrexprbodyempty',\n\t  24: 'ubErrNecessaryfieldNotExist',\n\t  25: 'ubErrRecordmodified',\n\t  26: 'ubErrNotexistnecessparam',\n\t  27: 'ubErrNotexistfieldlist',\n\t  28: 'ubErrUpdaterecnotfound',\n\t  29: 'ubErrNecessaryparamnotexist',\n\t  30: 'ubErrInvalidstoredirs',\n\t  31: 'ubErrNofileinstore',\n\t  32: 'ubErrAppnotsupportconnection',\n\t  33: 'ubErrAppnotsupportstore',\n\t  34: 'ubErrDeleterecnotfound',\n\t  35: 'ubErrNotfoundlinkentity',\n\t  36: 'ubErrEntitynotcontainmixinaslink',\n\t  37: 'ubErrEssnotinherfromessaslink',\n\t  38: 'ubErrInstancedatanameisreadonly',\n\t  39: 'ubErrManyrecordsforsoftlock',\n\t  40: 'ubErrNotfoundidentfieldsl',\n\t  41: 'ubErrInvalidlocktypevalue',\n\t  42: 'ubErrLockedbyanotheruser',\n\t  43: 'ubErrInvalidwherelistinparams',\n\t  44: 'ubErrRecnotlocked',\n\t  45: 'ubErrManyrecordsforchecksign',\n\t  46: 'ubErrNotfoundparamnotrootlevel',\n\t  47: 'ubErrCantcreatedirlogmsg',\n\t  48: 'ubErrCantcreatedirclientmsg',\n\t  49: 'ubErrConnectionNotExist',\n\t  50: 'ubErrDirectUnityModification',\n\t  51: 'ubErrCantdelrecthisvalueusedinassocrec',\n\t  52: 'ubErrAssocattrnotfound',\n\t  53: 'ubErrAttrassociationtoentityisempty',\n\t  54: 'ubErrNotfoundconforentityinapp',\n\t  55: 'ubErrNewversionrecnotfound',\n\t  56: 'ubErrElsAccessDenyEntity',\n\t  57: 'ubErrAlsAccessDenyEntityattr',\n\t  58: 'ubErrDatastoreEmptyentity',\n\t  // 59: \"ubErrCustomerror\"\n\t  67: 'ubErrTheServerHasExceededMaximumNumberOfConnections',\n\t  69: 'ubErrFtsForAppDisabled',\n\t  72: 'ubErrElsPwdIsExpired',\n\t  73: 'ELS_USER_NOT_FOUND',\n\t  74: 'VALUE_MUST_ME_UNIQUE'\n\t};\n\t\n\t/**\r\n\t * Return server-side error message by error number\r\n\t * @param {Number} errorNum\r\n\t * @return {String}\r\n\t */\n\tUBConnection.prototype.serverErrorByCode = function (errorNum) {\n\t  return this.serverErrorCodes[errorNum];\n\t};\n\t\n\t/**\r\n\t * Create a new instance of repository\r\n\t * @param {String} entityName name of Entity we create for\r\n\t * @returns {ServerRepository}\r\n\t */\n\tUBConnection.prototype.Repository = function (entityName) {\n\t  return new ClientRepository(this, entityName);\n\t};\n\t\n\tvar LDS = window && window.localStorage;\n\t/**\r\n\t * Connect to UnityBase server\r\n\t *\r\n\t * Example:\r\n\t *\r\n\t const UB = require('@unitybase/ub-core')\r\n\t let conn = UB.connect({\r\n\t    host: window.location.origin,\r\n\t    path: window.location.pathname,\r\n\t    onCredentialRequired: function(conn, isRepeat){\r\n\t        if (isRepeat){\r\n\t            throw new UB.UBAbortError('invalid')\r\n\t        } else {\r\n\t            return Promise.resolve({authSchema: 'UB', login: 'admin', password: 'admin'})\r\n\t        }\r\n\t    },\r\n\t    onAuthorizationFail:  function(reason){\r\n\t        alert(reason);\r\n\t    }\r\n\t });\r\n\t conn.then(function(conn){\r\n\t    conn.get('stat').then(function(statResp){\r\n\t        document.getElementById('ubstat').innerText = JSON.stringify(statResp.data, null, '\\t');\r\n\t    });\r\n\t\r\n\t    conn.Repository('ubm_navshortcut').attrs(['ID', 'code', 'caption']).selectAsArray().then(function(data){\r\n\t        let tmpl = _.template(document.getElementById('repo-template').innerHTML);\r\n\t        let result = tmpl(data.resultData);\r\n\t        // document.getElementById('ubnav').innerText = JSON.stringify(data.resultData);\r\n\t        document.getElementById('ubnav').innerHTML = result;\r\n\t    });\r\n\t });\r\n\t\r\n\t * @param cfg\r\n\t * @param {string} cfg.host Server host\r\n\t * @param {string} [cfg.path] API path - the same as in Server config `httpServer.path`\r\n\t * @param cfg.onCredentialRequired Callback for requesting a user creadentials. See {@link UBConnection} constructor `requestAuthParams` parameter description\r\n\t * @param [cfg.onAuthorizationFail] Callback for authorization failure. See {@link authorizationFail} event.\r\n\t * @param [cfg.onNeedChangePassword] Callback for a password exparition. See {@link passwordExpired} event\r\n\t * @param [cfg.onGotApplicationConfig]\r\n\t * @param [cfg.onGotApplicationDomain]\r\n\t * @return Promise<UBConnection>\r\n\t */\n\tfunction connect(cfg) {\n\t  var config = this.config = _.clone(cfg);\n\t\n\t  var connection = new UBConnection({\n\t    host: config.host,\n\t    appName: config.path || '/',\n\t    requestAuthParams: config.onCredentialRequired\n\t  });\n\t  if (config.onAuthorizationFail) {\n\t    connection.on('authorizationFail', config.onAuthorizationFail);\n\t  }\n\t  if (config.onNeedChangePassword) {\n\t    connection.on('passwordExpired', config.onNeedChangePassword);\n\t  }\n\t\n\t  return connection.getAppInfo().then(function (appInfo) {\n\t    // apply a default app settings to the gerAppInfo result\n\t    connection.appConfig = _.defaults(_.clone(appInfo), {\n\t      applicationName: 'UnityBase',\n\t      applicationTitle: 'UnityBase',\n\t      loginWindowTopLogoURL: '',\n\t      loginWindowBottomLogoURL: '',\n\t      themeName: 'UBGrayTheme',\n\t      userDbVersion: null,\n\t      defaultLang: 'en',\n\t      supportedLanguages: ['en']\n\t    });\n\t    // create ubNotifier after retrieve appInfo (we need to know supported WS protocols)\n\t    connection.ubNotifier = new UBNotifierWSProtocol(connection);\n\t    // try to determinate default user language\n\t    var preferredLocale = LDS && LDS.getItem(connection.appName + 'preferredLocale');\n\t    if (!preferredLocale) {\n\t      preferredLocale = connection.appConfig.defaultLang;\n\t    }\n\t    // is language supported by application?\n\t    if (connection.appConfig.supportedLanguages.indexOf(preferredLocale) === -1) {\n\t      preferredLocale = connection.appConfig.defaultLang;\n\t    }\n\t    connection.preferredLocale = preferredLocale;\n\t    return config.onGotApplicationConfig ? config.onGotApplicationConfig(connection) : true;\n\t  }).then(function () {\n\t    return connection.initEncriptionIfNeed();\n\t  }).then(function () {\n\t    return connection.initCache(connection.appConfig.userDbVersion);\n\t  }).then(function () {\n\t    return connection.authorize();\n\t  }).then(function () {\n\t    // here we authorized and know a user-related data\n\t    var myLocale = connection.userData('lang');\n\t    LDS && LDS.setItem(connection.appName + 'preferredLocale', myLocale);\n\t    connection.preferredLocale = myLocale;\n\t    return connection.getDomainInfo(config.onGotApplicationDomain);\n\t  }).then(function (domain) {\n\t    connection.domain = domain;\n\t    return connection;\n\t  });\n\t}\n\t\n\tmodule.exports = {\n\t  UBConnection: UBConnection,\n\t  connect: connect\n\t};\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/*\r\n\t @author pavel.mash\r\n\t */\n\tvar ubUtils = __webpack_require__(1);\n\tvar UBNativeMessage = __webpack_require__(11);\n\t\n\t/**\r\n\t * @class UBNativeDSTUCrypto\r\n\t * Ukrainian DSTU cryptographic service. Require native messages feature 'dstu' to be installed.\r\n\t * @constructor\r\n\t * Construct new Cryptography service\r\n\t * @param {Object} config initial parameters\r\n\t * @param {Number} [config.waitTimeout=180000] Default timeout for cryptographic operation (in ms)\r\n\t */\n\tfunction UBNativeDSTUCrypto(config) {\n\t  var crypto = Object.create(UBNativeDSTUCrypto.prototype),\n\t      nm,\n\t      initialized = false;\n\t\n\t  nm = new UBNativeMessage('dstu');\n\t  /**\r\n\t   * Native messages plugin instance\r\n\t   * @property {UBNativeMessage} plugin\r\n\t   * @protected\r\n\t   */\n\t  crypto.nm = nm;\n\t  crypto.nm.callTimeOut = config && config.waitTimeout || 180000;\n\t\n\t  /**\r\n\t   * Initialize encryption\r\n\t   * @param {String} serverCertificate base64 encoded server side certificate\r\n\t   * @return {Promise<UBNativeDSTUCrypto>} resolved to self\r\n\t   */\n\t  crypto.init = function (serverCertificate) {\n\t    if (initialized) {\n\t      return Promise.resolve(crypto);\n\t    } else {\n\t      return nm.connect().then(function (nm) {\n\t        return nm.invoke('init', serverCertificate).then(function () {\n\t          initialized = true;\n\t          return crypto;\n\t        });\n\t      });\n\t    }\n\t  };\n\t\n\t  /**\r\n\t   * Encrypt data and return result as array buffer\r\n\t   * @method\r\n\t   * @param {String} data\r\n\t   * @param {Boolean} isBase64\r\n\t   * @param {Boolean} [compress=false] (Optional)\r\n\t   * @returns {Promise} ArrayBuffer\r\n\t   */\n\t  crypto.encryptToArray = function (data, isBase64, compress) {\n\t    return nm.invoke('encrypt', { data: data, isBase64: isBase64, compress: compress || false }).then(function (base64encrypted) {\n\t      return ubUtils.base64toArrayBuffer(base64encrypted);\n\t    });\n\t  };\n\t\n\t  /**\r\n\t   * Decrypt array buffer data\r\n\t   * @method\r\n\t   * @param {ArrayBuffer} data\r\n\t   * @param {Boolean} toBase64\r\n\t   * @param {Boolean} [isCompressed=false] (optional)\r\n\t   * @returns {Promise} as Base64\r\n\t   */\n\t  crypto.decryptArr = function (data, toBase64, isCompressed) {\n\t    if (!data) {\n\t      throw new Error('Do not call decryptArr method with empty value');\n\t    }\n\t    return ubUtils.base64FromAny(data).then(function (b64) {\n\t      return nm.invoke('decrypt', { data: b64, toBase64: toBase64, isCompressed: isCompressed || false });\n\t    });\n\t  };\n\t\n\t  /**\r\n\t   * Creating an envelope with an encryption key.\r\n\t   * @returns {Promise} resolver to encryption key envelope\r\n\t   */\n\t  crypto.getEnvelopeWithKey = function () {\n\t    return nm.invoke('getEnvelopeWithKey');\n\t  };\n\t\n\t  return crypto;\n\t}\n\t\n\tmodule.exports = UBNativeDSTUCrypto;\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/*\r\n\t @author v.orel\r\n\t */\n\tvar ubUtils = __webpack_require__(1);\n\tvar UBNativeMessage = __webpack_require__(11);\n\t\n\t/**\r\n\t * @class UBNativeIITCrypto\r\n\t * Ukrainian IIT cryptographic service. Require native messages feature 'iit' to be installed.\r\n\t *\r\n\t * In Ext-based application instance of  UBNativeIITCrypto accessible via $App.connection.pki()\r\n\t * Usage sample:\r\n\t *\r\n\t        var file = fileInputEl.dom.files[0];\r\n\t        $App.connection.pki().then(function(pki){\r\n\t            return pki.readPK().then(function(){\r\n\t                return {pki: pki, b64File: UB.base64fromAny(file)}\r\n\t            }).then(function(params) {\r\n\t                return params.pki.signData(params.b64File);\r\n\t            }).then(function(signature){\r\n\t                console.log('Base64 p7s file representation:', signature);\r\n\t            });\r\n\t\t});\r\n\t\r\n\t * @constructor\r\n\t * Construct new Cryptography service\r\n\t * @param {Object} [config] initial parameters\r\n\t * @param {Number} [config.waitTimeout=180000] Default timeout for cryptographic operation (in ms)\r\n\t */\n\tfunction UBNativeIITCrypto(config) {\n\t  var crypto = Object.create(UBNativeIITCrypto.prototype),\n\t      nm,\n\t      initialized = false;\n\t\n\t  nm = new UBNativeMessage('iit');\n\t  /**\r\n\t   * Native messages nm instance\r\n\t   * @property {UBNativeMessage} nm\r\n\t   * @protected\r\n\t   */\n\t  crypto.nm = nm;\n\t  crypto.nm.callTimeOut = config && config.waitTimeout || 180000;\n\t\n\t  /**\r\n\t   * Initialize encryption\r\n\t   * @return {Promise<UBNativeIITCrypto>} resolved to self\r\n\t   */\n\t  crypto.init = function () {\n\t    if (initialized) {\n\t      return Promise.resolve(crypto);\n\t    } else {\n\t      return nm.connect().then(function (nm) {\n\t        return nm.invoke('init', null).then(function () {\n\t          initialized = true;\n\t          return crypto;\n\t        });\n\t      });\n\t    }\n\t  };\n\t  /**\r\n\t   * for IIT try load pk on error select cert and set it in store\r\n\t   * @param {UBConnection} connection\r\n\t   * @returns {Promise}\r\n\t   */\n\t  crypto.readPK = function (connection) {\n\t    var me = this,\n\t        promise;\n\t\n\t    promise = me.nm.invoke('getPrivateKeyReaded').then(function (keyIsReaded) {\n\t      if (keyIsReaded) {\n\t        return true;\n\t      } else {\n\t        return me.nm.invoke('CheckSettings').then(function (settingsOk) {\n\t          if (settingsOk) {\n\t            return me.nm.invoke('readPK', [], 300000).then(function (pkResult) {\n\t              switch (parseInt(pkResult.result, 10)) {\n\t                case 0:\n\t                  // everything is OK\n\t                  return pkResult.result;\n\t                case 12:\n\t                  // read of private key is canceled by user\n\t                  throw new ubUtils.UBAbortError('readPKCanceled');\n\t                case 51:\n\t                  // certificate not found - either user certificate not in certificate store, or root certificates not loaded to certificate store\n\t                  return me.nm.invoke('loadCertDialog', [], 300000).then(function () {\n\t                    // download root certs\n\t                    return connection.get('downloads/cert/CertList.json');\n\t                  }).then(loadCerts).then(function () {\n\t                    return me.nm.invoke('readPK', [], 300000).then(function (pkResult) {\n\t                      if (parseInt(pkResult.result, 10) === 51) {\n\t                        throw new ubUtils.UBError('invalidPrivateKeyCertificate', pkResult.lastError);\n\t                      } else {\n\t                        return pkResult.result;\n\t                      }\n\t                    });\n\t                  });\n\t                default:\n\t                  // unknown result\n\t                  if (pkResult.lastError) {\n\t                    throw new ubUtils.UBError(pkResult.lastError, pkResult.result);\n\t                  } else {\n\t                    throw new Error(pkResult.result);\n\t                  }\n\t              }\n\t            });\n\t          } else {\n\t            return Promise.reject({ errMsg: 'nm.CheckSettings() fail' });\n\t          }\n\t        });\n\t      }\n\t    });\n\t\n\t    // here private key is readed\n\t    return promise.then(function () {\n\t      var certificateInfo = {};\n\t\n\t      return me.nm.invoke('getOwnCert').then(function (ownIITCer) {\n\t        certificateInfo.ownIITCert = ownIITCer;\n\t        if (!certificateInfo.ownIITCert || certificateInfo.ownIITCert === '') {\n\t          throw new Error('getOwnCertFail');\n\t        }\n\t        return me.nm.invoke('getOwnCertEncrypt').then(function (ownIITEncryptCert) {\n\t          certificateInfo.ownIITEncryptCert = ownIITEncryptCert;\n\t          return me.nm.invoke('getOwnCertEncryptSignature').then(function (ownIITEncryptSignature) {\n\t            certificateInfo.ownIITEncryptSignature = ownIITEncryptSignature;\n\t            return certificateInfo;\n\t          });\n\t        });\n\t      });\n\t    }, function (rejection) {\n\t      me.nm.invoke('closePK');\n\t      throw rejection;\n\t    });\n\t\n\t    function loadCerts(certListResult) {\n\t      var certificates = certListResult.data,\n\t          reqArr = [],\n\t          req;\n\t      _.forEach(certificates, function (certName) {\n\t        req = connection.get('downloads/cert/' + certName, {\n\t          responseType: 'arraybuffer'\n\t        }).then(function (cert) {\n\t          return ubUtils.base64FromAny(cert.data);\n\t        }).then(function (base64Data) {\n\t          return me.nm.invoke('AddCert', base64Data);\n\t        });\n\t        reqArr.push(req);\n\t      });\n\t      return Promise.all(reqArr);\n\t    }\n\t  };\n\t\n\t  /**\r\n\t   * Set server side certificate\r\n\t   * @deprecated Due to wrong name this function is deprecated since UB 4.0. Use setRecipientCertificate instead.\r\n\t   * @param {String} base64encodedCert\r\n\t   */\n\t  crypto.setServerCertificate = function (base64encodedCert) {\n\t    return this.nm.invoke('setServerCert', base64encodedCert);\n\t  };\n\t\n\t  /**\r\n\t   * Set recipient certificate for use in encryption operations\r\n\t   * @param {String} base64encodedCert\r\n\t   */\n\t  crypto.setRecipientCertificate = function (base64encodedCert) {\n\t    return this.nm.invoke('setServerCert', base64encodedCert);\n\t  };\n\t\n\t  /**\r\n\t   * Decrypt envelope to string using client private key.\r\n\t   * {@link UBNativeIITCrypto#readPK} must be called before\r\n\t   * @param {String} envelope base64 encoded envelope\r\n\t   * @param {Boolean} resultAsBase64\r\n\t   * @method\r\n\t   * @returns {Promise}\r\n\t   */\n\t  crypto.decryptEnvelope = function (envelope, resultAsBase64) {\n\t    return this.nm.invoke('decryptEnvelope', { data: envelope, toBase64: resultAsBase64 });\n\t  };\n\t\n\t  /**\r\n\t   * Encrypt string to envelope using the public key, previously loaded by {@link UBNativeIITCrypto#setRecipientCertificate}\r\n\t   * @param {String} base64string\r\n\t   * @param {Boolean} resultAsBase64\r\n\t   * @method\r\n\t   * @returns {Promise}\r\n\t   */\n\t  crypto.encryptEnvelope = function (base64string, resultAsBase64) {\n\t    return this.nm.invoke('encryptEnvelope', { data: base64string, isBase64: resultAsBase64 });\n\t  };\n\t\n\t  /**\r\n\t   * Close previously opened private key.\r\n\t   * @returns {Promise}\r\n\t   */\n\t  crypto.closePK = function () {\n\t    return this.nm.invoke('closePK');\n\t  };\n\t\n\t  /**\r\n\t   * Sign data and return base 64 encoded signature of it. Data can be either base64 encoded binary data or string\r\n\t   * @param {String} data\r\n\t   * @param {Boolean} [dataIsBase64=true]\r\n\t   * @returns {Promise} Resolved to base64 encoded <a href=\"http://habrahabr.ru/post/256367/\">p7s</a> data signature\r\n\t   */\n\t  crypto.signData = function (data, dataIsBase64) {\n\t    return this.nm.invoke('IITSignData', { data: data, isBase64: typeof dataIsBase64 === 'undefined' ? true : dataIsBase64 });\n\t  };\n\t\n\t  /**\r\n\t   * Verify data signature. If successfully - return promise, resolved to signature info, else - reject with reason\r\n\t   * @param {String} data\r\n\t   * @param {String} signature Base64 encoded data signature\r\n\t   * @param {Boolean} [dataIsBase64=true]\r\n\t   * @returns {Promise}\r\n\t   */\n\t  crypto.verifySignature = function (data, signature, dataIsBase64) {\n\t    return this.nm.invoke('IITVerifyData', { data: data, signature: signature, isBase64: typeof dataIsBase64 === 'undefined' ? true : dataIsBase64 });\n\t  };\n\t  //\n\t  //        /**\n\t  //         * Encrypt data and return result as array buffer\n\t  //         * @method\n\t  //         * @param {String} data\n\t  //         * @param {Boolean} isBase64\n\t  //         * @param {Boolean} [compress=false] (Optional)\n\t  //         * @returns {Promise} ArrayBuffer\n\t  //         */\n\t  //        crypto.encryptToArray = function(data, isBase64, compress){\n\t  //            return nm.invoke('encrypt', {data: data, isBase64: isBase64, compress: compress || false}).then(function(base64encrypted){\n\t  //                return UB.base64toArrayBuffer(base64encrypted);\n\t  //            });\n\t  //        };\n\t  //\n\t  //        /**\n\t  //         * Decrypt array buffer data\n\t  //         * @method\n\t  //         * @param {ArrayBuffer} data\n\t  //         * @param {Boolean} toBase64\n\t  //         * @param {Boolean} [isCompressed=false] (Optional)\n\t  //         * @returns {Promise} as Base64\n\t  //         */\n\t  //        crypto.decryptArr = function(data, toBase64, isCompressed){\n\t  //            var base64str;\n\t  //\n\t  //            if (!data){\n\t  //                throw new Error('Do not call decryptArr method with empty value');\n\t  //            }\n\t  //            base64str = UB.base64fromArrayBuffer(data);\n\t  //            return nm.invoke('decrypt', {data: base64str, toBase64: toBase64, isCompressed: isCompressed});\n\t  //        };\n\t  //\n\t  //        /**\n\t  //         * Creating an envelope with an encryption key.\n\t  //         * @returns {Promise} resolver to encryption key envelope\n\t  //         */\n\t  //        crypto.getEnvelopeWithKey = function(){\n\t  //            return nm.invoke('getEnvelopeWithKey');\n\t  //        };\n\t\n\t  return crypto;\n\t}\n\t\n\tmodule.exports = UBNativeIITCrypto;\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/*\r\n\t * Created by pavel.mash on 14.03.2016.\r\n\t */\n\tvar _ = __webpack_require__(2);\n\tvar EventEmitter = __webpack_require__(5);\n\t\n\tvar WS_PROTOCOL = 'ubNotifier';\n\tvar MAX_BUFFERED_COMMANDS = 100;\n\t\n\t/**\r\n\t * @classdesc\r\n\t *\r\n\t * WebSocket connection to UnityBase server using ubNotifier protocol.\r\n\t * The property `supported` indicate `ubNotifier` protocol is supported by server.\r\n\t * Class mixes an EventEmitter. After got a command from a server the event with command code\r\n\t * is fired.\r\n\t *\r\n\t * The event flow are:\r\n\t *\r\n\t *  - just after webSocket connection is established `connected` event are fired, when\r\n\t *  - after server accept (verify a user credential) `accepted` are fired - here you can got\r\n\t *    a connectionID of a current connection\r\n\t *  - next is a series of protocol events ( `test_command` for example )\r\n\t *  - in case of protocol error `error` are fired\r\n\t *  - when WebSocket connection are closed `disconnected` event are fired\r\n\t *\r\n\t * You do not need to **connect** or **reconnect** a WebSocket manually - UBNotifierWSProtocol recreate\r\n\t * a WebSocket automatically just after corresponding UBConnection fires a `authorized` event.\r\n\t *\r\n\t * For `adminUI` instance of this class is accessible from $App.ubNotifier just after $App.launch\r\n\t *\r\n\t * Usage sample:\r\n\t *\r\n\t *      // Server side\r\n\t *      const WebSockets = require('WebSockets');\r\n\t *      var notifier = WebSockets.getWSNotifier();\r\n\t *      if (notifier) {\r\n\t *          notifier.broadcast('test_command', {name: 'Homer', like: 'donuts'});\r\n\t *      }\r\n\t *\r\n\t *      // Client side\r\n\t *      // Will output 'Homer like donuts' after got a `test_command` from server\r\n\t *      $App.ubNotifier.on('test_command', function(params}{\r\n\t *          console.debug(params.name, 'like', params.like)\r\n\t *      }\r\n\t *\r\n\t * @class\r\n\t * @mixes EventEmitter\r\n\t * @param {UBConnection} connection Warning - only one instance of UBNotifierWSProtocol for a connection is valid.\r\n\t */\n\tfunction UBNotifierWSProtocol(connection) {\n\t  var notifier = this;\n\t  var supported = connection.supportedWSProtocols.indexOf(WS_PROTOCOL) !== -1;\n\t  /**\r\n\t   * Indicate `ubNotifier` protocol is supported by server.\r\n\t   * If not supported all calls to send() will be ignored.\r\n\t   * @type {boolean}\r\n\t   */\n\t  this.supported = supported;\n\t\n\t  EventEmitter.call(this);\n\t  _.assign(this, EventEmitter.prototype);\n\t\n\t  var doDebug = function doDebug() {},\n\t      inDebug = false;\n\t  /**\r\n\t   * Enable output all webSocket interaction to console\r\n\t   * @property {boolean} debugMode\r\n\t   */\n\t  Object.defineProperty(notifier, 'debugMode', {\n\t    get: function get() {\n\t      return inDebug;\n\t    },\n\t    set: function set(newValue) {\n\t      if (inDebug !== newValue) {\n\t        inDebug = newValue;\n\t        doDebug = inDebug ? console.debug.bind(console, 'ubNotifier') : function () {};\n\t      }\n\t    },\n\t    enumerable: true,\n\t    configurable: true\n\t  });\n\t\n\t  var wsURL = 'ws' + connection.serverUrl.slice(4) + 'ws'; // remove http part, so in case http://.. we got ws://.., in case https://.. -> wss://..\n\t  var $ws = null;\n\t  var isConnectionAccepted = false;\n\t  var bufferedCommands = [];\n\t\n\t  function _createWSConnection(session) {\n\t    if (supported) {\n\t      $ws = new WebSocket(wsURL + '?SESSION_SIGNATURE=' + session.signature(), 'ubNotifier');\n\t\n\t      $ws.onopen = function (e) {\n\t        doDebug('connected to', e.target.url, 'protocol:', e.target.protocol);\n\t        /**\r\n\t         * Emitted for {@link UBNotifierWSProtocol} just after WS connection is established, but before it accepted by server.\r\n\t         * Params: url, protocol\r\n\t         * @event connected\r\n\t         */\n\t        notifier.emit('connected', e.target.url, e.target.protocol);\n\t      };\n\t\n\t      $ws.onmessage = function (e) {\n\t        var msg;\n\t        doDebug('Got a raw data', e.data);\n\t        try {\n\t          msg = JSON.parse(e.data);\n\t        } catch (err) {\n\t          console.error('ubNotifier: Invalid command from server:', e.data);\n\t        }\n\t        var command = msg.command,\n\t            params = msg.params,\n\t            delayedCmd;\n\t\n\t        doDebug('Got a command', command, 'with params', params);\n\t        switch (command) {\n\t          case 'accepted':\n\t            // send a buffered request if any\n\t            isConnectionAccepted = true;\n\t            while ((delayedCmd = bufferedCommands.shift()) && isConnectionAccepted) {\n\t              notifier.sendCommand(delayedCmd.command, delayedCmd.params);\n\t            }\n\t            bufferedCommands = [];\n\t            /**\r\n\t             * If server accept a ubNotifier WS connection this event will be emitted for {@link UBNotifierWSProtocol} with `connectionID` parameter\r\n\t             * @event accepted\r\n\t             */\n\t            notifier.emit('accepted', params.connectionID);\n\t            break;\n\t          case 'error':\n\t            doDebug('Got an error from server', params);\n\t            notifier.emit('error', params);\n\t            break;\n\t          default:\n\t            doDebug('Emit event ', command, 'with params', params);\n\t            notifier.emit(command, params);\n\t            break;\n\t        }\n\t      };\n\t\n\t      $ws.onclose = function (e) {\n\t        isConnectionAccepted = false;\n\t        doDebug('Connection closed. Code:', e.code, 'Reason:', e.reason);\n\t        notifier.emit('disconnected', e.code, e.reason);\n\t      };\n\t    }\n\t  }\n\t\n\t  /**\r\n\t   * Sand a command to server\r\n\t   *\r\n\t   *  - if WS connection is not accepted yet will buffer the commands and send it just after connection is accepted\r\n\t   *  - if `ubNotifier` protocol not supported by server will do nothing\r\n\t   *\r\n\t   * @method\r\n\t   * @param {string} command\r\n\t   * @param {*} params\r\n\t   */\n\t  this.sendCommand = function (command, params) {\n\t    if (supported) {\n\t      if (isConnectionAccepted) {\n\t        $ws.send(JSON.stringify({ command: command, params: params }));\n\t      } else {\n\t        // add to delayed buffer\n\t        bufferedCommands.push({ command: command, params: params });\n\t        if (bufferedCommands.length > MAX_BUFFERED_COMMANDS) bufferedCommands.shift();\n\t      }\n\t    }\n\t  };\n\t\n\t  function _onUBConnectionAuthorized(ubConnection, session, authParams) {\n\t    isConnectionAccepted = false;\n\t    if (connection.supportedWSProtocols.indexOf(WS_PROTOCOL) !== -1) {\n\t      _createWSConnection(session);\n\t    } else {\n\t      console.warn('ubNotifier: protocol not supported');\n\t    }\n\t  }\n\t  connection.on('authorized', _onUBConnectionAuthorized);\n\t}\n\tmodule.exports = UBNotifierWSProtocol;\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar __loadedScript = {};\n\tvar __head = document.getElementsByTagName('head')[0];\n\t\n\t/**\r\n\t * Inject external script or css to DOM and return a promise to be resolved when script is loaded.\r\n\t *\r\n\t * Implement single load mode (if script successfully loaded using inject it not loaded anymore.\r\n\t *\r\n\t * @example\r\n\t *\r\n\t //Load script.js:\r\n\t UB.inject('jslibs/script.js')\r\n\t\r\n\t //Load several script at once and error handling:\r\n\t Promise.all([UB.inject('jslibs/script.js'), UB.inject('script2.js')])\r\n\t .catch(function(err){\r\n\t   console.log('Oh! error occurred: ' + err)\r\n\t });\r\n\t\r\n\t //Load one script and then load other\r\n\t UB.inject('jslibs/js_beautify.js')\r\n\t .then(function(){\r\n\t     console.log('first script loaded. Continue to load second')\r\n\t     return UB.inject('jslibs/js_beautify1.js')\r\n\t });\r\n\t\r\n\t //Load couple of resources:\r\n\t Promise.all([UB.inject('css/first.css'), UB.inject('css/second.css')])\r\n\t\r\n\t * @param {String} url either *js* or *css* resource to load\r\n\t * @param {String} [charset]\r\n\t * @return {Promise}\r\n\t */\n\tfunction inject(url, charset) {\n\t  var res = void 0;\n\t  if (__loadedScript[url]) {\n\t    res = __loadedScript[url];\n\t  } else {\n\t    // Create and inject script tag at end of DOM body and load the external script\n\t    // attach event listeners that will trigger the Deferred.\n\t    res = __loadedScript[url] = new Promise(function (resolve, reject) {\n\t      var elm = null;\n\t      var isCSS = /\\.css(?:\\?|$)/.test(url);\n\t      if (isCSS) {\n\t        elm = document.createElement('link');\n\t        elm.rel = 'stylesheet';\n\t        elm.async = true;\n\t      } else {\n\t        elm = document.createElement('script');\n\t        elm.type = 'text/javascript';\n\t        if (charset) {\n\t          elm.charset = charset;\n\t        }\n\t        elm.async = true;\n\t      }\n\t      elm.onerror = function (oError) {\n\t        var reason = 'Required ' + (oError.target.href || oError.target.src) + ' is not accessible';\n\t        delete __loadedScript[url];\n\t        elm.onerror = elm.onload = elm.onreadystatechange = null;\n\t        reject(new Error(reason));\n\t      };\n\t\n\t      elm.onload = function () {\n\t        elm.onerror = elm.onload = elm.onreadystatechange = null;\n\t        setTimeout(function () {\n\t          // script must evaluate first\n\t          var _elm = elm;\n\t          resolve();\n\t          // Remove the script (do not remove CSS) ???\n\t          if (_elm.parentNode && !_elm.rel) {\n\t            _elm.parentNode.removeChild(elm);\n\t            elm = null;\n\t          }\n\t        }, 0);\n\t      };\n\t      // if ('readyState' in elm) {   // for <IE9 Compatability\n\t      //   elm.onreadystatechange = function () {\n\t      //     if (this.readyState === 'loaded' || this.readyState === 'complete') {\n\t      //       resultHandler()\n\t      //     }\n\t      //   }\n\t      // }\n\t\n\t      __head.appendChild(elm);\n\t      // src must be set AFTER onload && onerror && appendChild\n\t      if (isCSS) {\n\t        elm.href = addResourceVersion(url);\n\t      } else {\n\t        elm.src = addResourceVersion(url);\n\t      }\n\t    });\n\t  }\n\t  return res;\n\t}\n\t\n\t/**\r\n\t *  In case window contains __ubVersion property {@link addResourceVersion addResourceVersion} will add\r\n\t *  version parameter to scripts inside models.\r\n\t *\r\n\t *  @private\r\n\t */\n\tvar __ubVersion = window.__ubVersion;\n\tvar MODEL_RE = new RegExp('models/(.+?)/'); // speculative search. w/o ? found maximum string length\n\t\n\t/**\r\n\t * Search for resource version in the  window.__ubVersion global const\r\n\t * IF any,  return 'ver=version' else ''\r\n\t * @param {String} uri\r\n\t * @returns {String}\r\n\t */\n\tfunction getResourceVersion(uri) {\n\t  var modelName = MODEL_RE.test(uri) ? MODEL_RE.exec(uri)[1] : '_web';\n\t  return __ubVersion && __ubVersion[modelName] ? '?ubver=' + __ubVersion[modelName] : '';\n\t}\n\t\n\t/**\r\n\t * Append UnityBase model version to the URL\r\n\t * @param {String} uri\r\n\t * @returns {String} uri with added resource version\r\n\t */\n\tfunction addResourceVersion(uri) {\n\t  var ver = getResourceVersion(uri);\n\t  return ver ? uri + ver : uri;\n\t}\n\t\n\tmodule.exports = {\n\t  inject: inject,\n\t  addResourceVersion: addResourceVersion\n\t};\n\n/***/ }\n]);\n\n\n// WEBPACK FOOTER //\n// ub-core.min.js","/**\r\n * Created by pavel.mash on 03.09.2016.\r\n */\r\n\r\nconst localization = require('./i18n')\r\nconst utils = require('./utils')\r\nconst transport = require('./transport')\r\nconst conn = require('./UBConnection')\r\nconst injection = require('./injection')\r\nconst ClientRepository = require('./ClientRepository')\r\nconst SHA256 = require('@unitybase/CryptoJS/sha256')\r\nconst MD5 = require('@unitybase/CryptoJS/md5')\r\n\r\nmodule.exports = {\r\n  i18n: localization.i18n,\r\n  i18nExtend: localization.i18nExtend,\r\n\r\n  format: utils.format,\r\n  apply: utils.apply,\r\n  ns: utils.ns,\r\n  booleanParse: utils.booleanParse,\r\n  iso8601Parse: utils.iso8601Parse,\r\n  iso8601ParseAsDate: utils.iso8601ParseAsDate,\r\n\r\n  base64FromAny: utils.base64FromAny,\r\n  base64toArrayBuffer: utils.base64toArrayBuffer,\r\n\r\n  UBError: utils.UBError,\r\n  UBAbortError: utils.UBAbortError,\r\n\r\n  xhr: transport.xhr,\r\n  get: transport.get,\r\n  post: transport.post,\r\n\r\n  connect: conn.connect,\r\n  ClientRepository: ClientRepository,\r\n\r\n  log: utils.log,\r\n  logError: utils.logError,\r\n  logWarn: utils.logWarn,\r\n  logDebug: utils.logDebug,\r\n\r\n  userAgent: utils.userAgent,\r\n  isChrome: utils.isChrome,\r\n  isWebKit: utils.isWebKit,\r\n  isGecko: utils.isGecko,\r\n  isOpera: utils.isOpera,\r\n  isMac: utils.isMac,\r\n  isSecureBrowser: utils.isSecureBrowser,\r\n\r\n  inject: injection.inject,\r\n  addResourceVersion: injection.addResourceVersion,\r\n\r\n  SHA256: SHA256,\r\n  MD5: MD5\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","/**\r\n * Created by pavel.mash on 01.12.2016.\r\n */\r\n/* global FileReader, Blob */\r\nconst _ = require('lodash')\r\n/**\r\n * Copies all the properties of one or several objectsFrom to the specified objectTo.\r\n * Non-simple type copied by reference!\r\n * @param {Object} objectTo The receiver of the properties\r\n * @param {...Object} objectsFrom The source(s) of the properties\r\n * @return {Object} returns objectTo\r\n */\r\nmodule.exports.apply = function (objectTo, objectsFrom) {\r\n  Array.prototype.forEach.call(arguments, function (obj) {\r\n    if (obj && obj !== objectTo) {\r\n      Object.keys(obj).forEach(function (key) {\r\n        objectTo[key] = obj[key]\r\n      })\r\n    }\r\n  })\r\n  return objectTo\r\n}\r\n\r\nconst FORMAT_RE = /\\{(\\d+)}/g\r\n/**\r\n * Allows you to define a tokenized string and pass an arbitrary number of arguments to replace the tokens.  Each\r\n * token must be unique, and must increment in the format {0}, {1}, etc.  Example usage:\r\n *\r\n *     var s = UB.format('{1}/ext-lang-{0}.js', 'en', 'locale');\r\n *     // s now contains the string: ''locale/ext-lang-en.js''\r\n *\r\n * @param {String} stringToFormat The string to be formatted.\r\n * @param {...*} values The values to replace tokens `{0}`, `{1}`, etc in order.\r\n * @return {String} The formatted string.\r\n */\r\nmodule.exports.format = function (stringToFormat, values) {\r\n  var args = _.toArray(arguments).slice(1)\r\n  return stringToFormat.replace(FORMAT_RE, function (m, i) {\r\n    return args[i]\r\n  })\r\n}\r\n\r\n/**\r\n * Creates namespaces to be used for scoping variables and classes so that they are not global.\r\n * @example\r\n *     UB.ns('DOC.Report');\r\n *\r\n *     DOC.Report.myReport = function() { ... };\r\n *\r\n * @method\r\n * @param {String} namespacePath\r\n * @return {Object} The namespace object.\r\n */\r\nmodule.exports.ns = function (namespacePath) {\r\n  let root = window\r\n  let parts, part, j, subLn\r\n\r\n  parts = namespacePath.split('.')\r\n\r\n  for (j = 0, subLn = parts.length; j < subLn; j++) {\r\n    part = parts[j]\r\n    if (!root[part]) root[part] = {}\r\n    root = root[part]\r\n  }\r\n  return root\r\n}\r\n\r\n/**\r\n * Convert UnityBase server dateTime response to Date object\r\n * @param value\r\n * @returns {Date}\r\n */\r\nmodule.exports.iso8601Parse = function (value) {\r\n  return value ? new Date(value) : null\r\n}\r\n\r\n/**\r\n * Convert UnityBase server date response to Date object.\r\n * date response is a day with 00 time (2015-07-17T00:00Z), to get a real date we must add current timezone shift\r\n * @param value\r\n * @returns {Date}\r\n */\r\nmodule.exports.iso8601ParseAsDate = function (value) {\r\n  let res = value ? new Date(value) : null\r\n  if (res) {\r\n    res.setTime(res.getTime() + res.getTimezoneOffset() * 60 * 1000)\r\n  }\r\n  return res\r\n}\r\n\r\n/**\r\n * Convert UnityBase server Boolean response to Boolean (0 = false & 1 = trhe)\r\n * @param v Value to convert\r\n * @returns {Boolean|null}\r\n */\r\nmodule.exports.booleanParse = function (v) {\r\n  if (typeof v === 'boolean') return v\r\n  if ((v === undefined || v === null || v === '')) return null\r\n  return v === 1\r\n}\r\n\r\n/**\r\n * Fast async transformation of data to base64 string\r\n * @method\r\n * @param {File|ArrayBuffer|String|Blob|Array} data\r\n * @returns {Promise<string>} resolved to data converted to base64 string\r\n */\r\nmodule.exports.base64FromAny = function (data) {\r\n  return new Promise((resolve, reject) => {\r\n    let reader = new FileReader()\r\n    let blob = (data instanceof Blob) ? data : new Blob([data])\r\n    reader.addEventListener('loadend', function () {\r\n      resolve(reader.result.split(',', 2)[1]) // remove data:....;base64, from the beginning of string //TODO -use indexOf\r\n    })\r\n    reader.addEventListener('error', function (event) {\r\n      reject(event)\r\n    })\r\n    reader.readAsDataURL(blob)\r\n  })\r\n}\r\n\r\nconst BASE64STRING = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\nconst BASE64ARR = [];\r\n(function () {\r\n  for (let i = 0, l = BASE64STRING.length - 1; i < l; i++) {\r\n    BASE64ARR.push(BASE64STRING[i])\r\n  }\r\n})()\r\n\r\nconst BASE64DECODELOOKUP = new Uint8Array(256);\r\n(function () {\r\n  for (let i = 0, l = BASE64STRING.length; i < l; i++) {\r\n    BASE64DECODELOOKUP[BASE64STRING[i].charCodeAt(0)] = i\r\n  }\r\n})()\r\n\r\n/**\r\n * Convert base54 encoded string to decoded array buffer\r\n * @param {String} base64\r\n * @returns {ArrayBuffer}\r\n */\r\nmodule.exports.base64toArrayBuffer = function (base64) {\r\n  let bufferLength = base64.length * 0.75\r\n  let len = base64.length\r\n  let p = 0\r\n  let encoded1, encoded2, encoded3, encoded4\r\n\r\n  if (base64[ base64.length - 1 ] === '=') {\r\n    bufferLength--\r\n    if (base64[ base64.length - 2 ] === '=') bufferLength--\r\n  }\r\n\r\n  let arrayBuffer = new ArrayBuffer(bufferLength)\r\n  let bytes = new Uint8Array(arrayBuffer)\r\n\r\n  for (let i = 0; i < len; i += 4) {\r\n    encoded1 = BASE64DECODELOOKUP[ base64.charCodeAt(i) ]\r\n    encoded2 = BASE64DECODELOOKUP[ base64.charCodeAt(i + 1) ]\r\n    encoded3 = BASE64DECODELOOKUP[ base64.charCodeAt(i + 2) ]\r\n    encoded4 = BASE64DECODELOOKUP[ base64.charCodeAt(i + 3) ]\r\n\r\n    bytes[ p++ ] = (encoded1 << 2) | (encoded2 >> 4)\r\n    bytes[ p++ ] = ((encoded2 & 15) << 4) | (encoded3 >> 2)\r\n    bytes[ p++ ] = ((encoded3 & 3) << 6) | (encoded4 & 63)\r\n  }\r\n\r\n  return arrayBuffer\r\n}\r\n\r\n/**\r\n * UnityBase client-side exception.\r\n * Such exceptions are will not be showed as unknown error in {@link UB#showErrorWindow}\r\n *\r\n * message Can be either localized message or locale identifier - in this case UB#showErrorWindow translate message using {@link UB#i18n}\r\n *\r\n *      @example\r\n *      throw new UB.UBError('lockedBy'); // will show message box \"Record was locked by other user. It\\'s read-only for you now\"\r\n *\r\n * @param {String} message Message\r\n * @param {String} [detail] Error details\r\n * @param {Number} [code] Error code (for server-side errors)\r\n * @extends {Error}\r\n */\r\nfunction UBError (message, detail, code) {\r\n  this.name = 'UBError'\r\n  this.detail = detail\r\n  this.code = code\r\n  this.message = message || 'UBError'\r\n  if (Error.captureStackTrace) {\r\n    Error.captureStackTrace(this, UBError)\r\n  } else {\r\n    this.stack = (new Error()).stack\r\n  }\r\n}\r\nUBError.prototype = new Error()\r\nUBError.prototype.constructor = UBError\r\n\r\nmodule.exports.UBError = UBError\r\n\r\n/**\r\n * UnityBase still error. Global error handler does not show this error for user. Use it for still reject promise.\r\n * @param {String} [message] Message\r\n * @param {String} [detail] Error details\r\n * @extends {Error}\r\n */\r\nfunction UBAbortError (message, detail) {\r\n  this.name = 'UBAbortError'\r\n  this.detail = detail\r\n  this.code = 'UBAbortError'\r\n  this.message = message || 'UBAbortError'\r\n  if (Error.captureStackTrace) {\r\n    Error.captureStackTrace(this, UBAbortError)\r\n  } else {\r\n    this.stack = (new Error()).stack\r\n  }\r\n}\r\nUBAbortError.prototype = new Error()\r\nUBAbortError.prototype.constructor = UBAbortError\r\n\r\nmodule.exports.UBAbortError = UBAbortError\r\n\r\n/**\r\n * Log message to console (if console available)\r\n * @method\r\n * @param {...*} msg\r\n */\r\nmodule.exports.log = function log (msg) {\r\n  if (console) console.log.apply(console, arguments)\r\n}\r\n\r\n/**\r\n * Log error message to console (if console available)\r\n * @method\r\n * @param {...*} msg\r\n */\r\nmodule.exports.logError = function logError (msg) {\r\n  if (console) {\r\n    console.error.apply(console, arguments)\r\n  }\r\n}\r\n\r\n/**\r\n * Log warning message to console (if console available)\r\n * @method\r\n * @param {...*} msg\r\n */\r\nmodule.exports.logWarn = function logWarn (msg) {\r\n  if (console) {\r\n    console.warn.apply(console, arguments)\r\n  }\r\n}\r\n\r\n/**\r\n * Log debug message to console.\r\n * Since it binded to console, can also be used to debug Promise resolving in this way:\r\n *\r\n *      UB.get('timeStamp').then(UB.logDebug);\r\n *\r\n * @method\r\n * @param {...*} msg\r\n */\r\nmodule.exports.logDebug = console.info.bind(console)\r\n\r\nconst userAgent = (navigator && navigator.userAgent) ? navigator.userAgent.toLowerCase() : ''\r\n/** @type {String} */\r\nmodule.exports.userAgent = navigator.userAgent.toLowerCase()\r\n/** @type {Boolean} */\r\nmodule.exports.isChrome = /\\bchrome\\b/.test(userAgent)\r\n/** @type {Boolean} */\r\nmodule.exports.isWebKit = /webkit/.test(userAgent)\r\n/** @type {Boolean} */\r\nmodule.exports.isGecko = !/webkit/.test(userAgent) && /gecko/.test(userAgent)\r\n/** @type {Boolean} */\r\nmodule.exports.isOpera = /opr|opera/.test(userAgent)\r\n/** @type {Boolean} */\r\nmodule.exports.isMac = /macintosh|mac os x/.test(userAgent)\r\n/** @type {Boolean} */\r\nmodule.exports.isSecureBrowser = /\\belectron\\b/.test(userAgent)\r\n\n\n\n// WEBPACK FOOTER //\n// ./utils.js",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory();\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\troot.CryptoJS = factory();\n\t}\n}(this, function () {\n\n\t/**\n\t * CryptoJS core components.\n\t */\n\tvar CryptoJS = CryptoJS || (function (Math, undefined) {\n\t    /**\n\t     * CryptoJS namespace.\n\t     */\n\t    var C = {};\n\n\t    /**\n\t     * Library namespace.\n\t     */\n\t    var C_lib = C.lib = {};\n\n\t    /**\n\t     * Base object for prototypal inheritance.\n\t     */\n\t    var Base = C_lib.Base = (function () {\n\t        function F() {}\n\n\t        return {\n\t            /**\n\t             * Creates a new object that inherits from this object.\n\t             *\n\t             * @param {Object} overrides Properties to copy into the new object.\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         field: 'value',\n\t             *\n\t             *         method: function () {\n\t             *         }\n\t             *     });\n\t             */\n\t            extend: function (overrides) {\n\t                // Spawn\n\t                F.prototype = this;\n\t                var subtype = new F();\n\n\t                // Augment\n\t                if (overrides) {\n\t                    subtype.mixIn(overrides);\n\t                }\n\n\t                // Create default initializer\n\t                if (!subtype.hasOwnProperty('init')) {\n\t                    subtype.init = function () {\n\t                        subtype.$super.init.apply(this, arguments);\n\t                    };\n\t                }\n\n\t                // Initializer's prototype is the subtype object\n\t                subtype.init.prototype = subtype;\n\n\t                // Reference supertype\n\t                subtype.$super = this;\n\n\t                return subtype;\n\t            },\n\n\t            /**\n\t             * Extends this object and runs the init method.\n\t             * Arguments to create() will be passed to init().\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var instance = MyType.create();\n\t             */\n\t            create: function () {\n\t                var instance = this.extend();\n\t                instance.init.apply(instance, arguments);\n\n\t                return instance;\n\t            },\n\n\t            /**\n\t             * Initializes a newly created object.\n\t             * Override this method to add some logic when your objects are created.\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         init: function () {\n\t             *             // ...\n\t             *         }\n\t             *     });\n\t             */\n\t            init: function () {\n\t            },\n\n\t            /**\n\t             * Copies properties into this object.\n\t             *\n\t             * @param {Object} properties The properties to mix in.\n\t             *\n\t             * @example\n\t             *\n\t             *     MyType.mixIn({\n\t             *         field: 'value'\n\t             *     });\n\t             */\n\t            mixIn: function (properties) {\n\t                for (var propertyName in properties) {\n\t                    if (properties.hasOwnProperty(propertyName)) {\n\t                        this[propertyName] = properties[propertyName];\n\t                    }\n\t                }\n\n\t                // IE won't copy toString using the loop above\n\t                if (properties.hasOwnProperty('toString')) {\n\t                    this.toString = properties.toString;\n\t                }\n\t            },\n\n\t            /**\n\t             * Creates a copy of this object.\n\t             *\n\t             * @return {Object} The clone.\n\t             *\n\t             * @example\n\t             *\n\t             *     var clone = instance.clone();\n\t             */\n\t            clone: function () {\n\t                return this.init.prototype.extend(this);\n\t            }\n\t        };\n\t    }());\n\n\t    /**\n\t     * An array of 32-bit words.\n\t     *\n\t     * @property {Array} words The array of 32-bit words.\n\t     * @property {number} sigBytes The number of significant bytes in this word array.\n\t     */\n\t    var WordArray = C_lib.WordArray = Base.extend({\n\t        /**\n\t         * Initializes a newly created word array.\n\t         *\n\t         * @param {Array} words (Optional) An array of 32-bit words.\n\t         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.create();\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n\t         */\n\t        init: function (words, sigBytes) {\n\t            words = this.words = words || [];\n\n\t            if (sigBytes != undefined) {\n\t                this.sigBytes = sigBytes;\n\t            } else {\n\t                this.sigBytes = words.length * 4;\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts this word array to a string.\n\t         *\n\t         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n\t         *\n\t         * @return {string} The stringified word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     var string = wordArray + '';\n\t         *     var string = wordArray.toString();\n\t         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n\t         */\n\t        toString: function (encoder) {\n\t            return (encoder || Hex).stringify(this);\n\t        },\n\n\t        /**\n\t         * Concatenates a word array to this word array.\n\t         *\n\t         * @param {WordArray} wordArray The word array to append.\n\t         *\n\t         * @return {WordArray} This word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray1.concat(wordArray2);\n\t         */\n\t        concat: function (wordArray) {\n\t            // Shortcuts\n\t            var thisWords = this.words;\n\t            var thatWords = wordArray.words;\n\t            var thisSigBytes = this.sigBytes;\n\t            var thatSigBytes = wordArray.sigBytes;\n\n\t            // Clamp excess bits\n\t            this.clamp();\n\n\t            // Concat\n\t            if (thisSigBytes % 4) {\n\t                // Copy one byte at a time\n\t                for (var i = 0; i < thatSigBytes; i++) {\n\t                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n\t                }\n\t            } else if (thatWords.length > 0xffff) {\n\t                // Copy one word at a time\n\t                for (var i = 0; i < thatSigBytes; i += 4) {\n\t                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n\t                }\n\t            } else {\n\t                // Copy all words at once\n\t                thisWords.push.apply(thisWords, thatWords);\n\t            }\n\t            this.sigBytes += thatSigBytes;\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Removes insignificant bits.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray.clamp();\n\t         */\n\t        clamp: function () {\n\t            // Shortcuts\n\t            var words = this.words;\n\t            var sigBytes = this.sigBytes;\n\n\t            // Clamp\n\t            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n\t            words.length = Math.ceil(sigBytes / 4);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this word array.\n\t         *\n\t         * @return {WordArray} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = wordArray.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone.words = this.words.slice(0);\n\n\t            return clone;\n\t        },\n\n\t        /**\n\t         * Creates a word array filled with random bytes.\n\t         *\n\t         * @param {number} nBytes The number of random bytes to generate.\n\t         *\n\t         * @return {WordArray} The random word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n\t         */\n\t        random: function (nBytes) {\n\t            var words = [];\n\n\t            var r = (function (m_w) {\n\t                var m_w = m_w;\n\t                var m_z = 0x3ade68b1;\n\t                var mask = 0xffffffff;\n\n\t                return function () {\n\t                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;\n\t                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;\n\t                    var result = ((m_z << 0x10) + m_w) & mask;\n\t                    result /= 0x100000000;\n\t                    result += 0.5;\n\t                    return result * (Math.random() > .5 ? 1 : -1);\n\t                }\n\t            });\n\n\t            for (var i = 0, rcache; i < nBytes; i += 4) {\n\t                var _r = r((rcache || Math.random()) * 0x100000000);\n\n\t                rcache = _r() * 0x3ade67b7;\n\t                words.push((_r() * 0x100000000) | 0);\n\t            }\n\n\t            return new WordArray.init(words, nBytes);\n\t        }\n\t    });\n\n\t    /**\n\t     * Encoder namespace.\n\t     */\n\t    var C_enc = C.enc = {};\n\n\t    /**\n\t     * Hex encoding strategy.\n\t     */\n\t    var Hex = C_enc.Hex = {\n\t        /**\n\t         * Converts a word array to a hex string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The hex string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var hexChars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                hexChars.push((bite >>> 4).toString(16));\n\t                hexChars.push((bite & 0x0f).toString(16));\n\t            }\n\n\t            return hexChars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a hex string to a word array.\n\t         *\n\t         * @param {string} hexStr The hex string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n\t         */\n\t        parse: function (hexStr) {\n\t            // Shortcut\n\t            var hexStrLength = hexStr.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < hexStrLength; i += 2) {\n\t                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n\t            }\n\n\t            return new WordArray.init(words, hexStrLength / 2);\n\t        }\n\t    };\n\n\t    /**\n\t     * Latin1 encoding strategy.\n\t     */\n\t    var Latin1 = C_enc.Latin1 = {\n\t        /**\n\t         * Converts a word array to a Latin1 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Latin1 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var latin1Chars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                latin1Chars.push(String.fromCharCode(bite));\n\t            }\n\n\t            return latin1Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Latin1 string to a word array.\n\t         *\n\t         * @param {string} latin1Str The Latin1 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n\t         */\n\t        parse: function (latin1Str) {\n\t            // Shortcut\n\t            var latin1StrLength = latin1Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < latin1StrLength; i++) {\n\t                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n\t            }\n\n\t            return new WordArray.init(words, latin1StrLength);\n\t        }\n\t    };\n\n\t    /**\n\t     * UTF-8 encoding strategy.\n\t     */\n\t    var Utf8 = C_enc.Utf8 = {\n\t        /**\n\t         * Converts a word array to a UTF-8 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-8 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            try {\n\t                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n\t            } catch (e) {\n\t                throw new Error('Malformed UTF-8 data');\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts a UTF-8 string to a word array.\n\t         *\n\t         * @param {string} utf8Str The UTF-8 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n\t         */\n\t        parse: function (utf8Str) {\n\t            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n\t        }\n\t    };\n\n\t    /**\n\t     * Abstract buffered block algorithm template.\n\t     *\n\t     * The property blockSize must be implemented in a concrete subtype.\n\t     *\n\t     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n\t     */\n\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n\t        /**\n\t         * Resets this block algorithm's data buffer to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm.reset();\n\t         */\n\t        reset: function () {\n\t            // Initial values\n\t            this._data = new WordArray.init();\n\t            this._nDataBytes = 0;\n\t        },\n\n\t        /**\n\t         * Adds new data to this block algorithm's buffer.\n\t         *\n\t         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm._append('data');\n\t         *     bufferedBlockAlgorithm._append(wordArray);\n\t         */\n\t        _append: function (data) {\n\t            // Convert string to WordArray, else assume WordArray already\n\t            if (typeof data == 'string') {\n\t                data = Utf8.parse(data);\n\t            }\n\n\t            // Append\n\t            this._data.concat(data);\n\t            this._nDataBytes += data.sigBytes;\n\t        },\n\n\t        /**\n\t         * Processes available data blocks.\n\t         *\n\t         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n\t         *\n\t         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n\t         *\n\t         * @return {WordArray} The processed data.\n\t         *\n\t         * @example\n\t         *\n\t         *     var processedData = bufferedBlockAlgorithm._process();\n\t         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n\t         */\n\t        _process: function (doFlush) {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\t            var dataSigBytes = data.sigBytes;\n\t            var blockSize = this.blockSize;\n\t            var blockSizeBytes = blockSize * 4;\n\n\t            // Count blocks ready\n\t            var nBlocksReady = dataSigBytes / blockSizeBytes;\n\t            if (doFlush) {\n\t                // Round up to include partial blocks\n\t                nBlocksReady = Math.ceil(nBlocksReady);\n\t            } else {\n\t                // Round down to include only full blocks,\n\t                // less the number of blocks that must remain in the buffer\n\t                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n\t            }\n\n\t            // Count words ready\n\t            var nWordsReady = nBlocksReady * blockSize;\n\n\t            // Count bytes ready\n\t            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n\t            // Process blocks\n\t            if (nWordsReady) {\n\t                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n\t                    // Perform concrete-algorithm logic\n\t                    this._doProcessBlock(dataWords, offset);\n\t                }\n\n\t                // Remove processed words\n\t                var processedWords = dataWords.splice(0, nWordsReady);\n\t                data.sigBytes -= nBytesReady;\n\t            }\n\n\t            // Return processed words\n\t            return new WordArray.init(processedWords, nBytesReady);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this object.\n\t         *\n\t         * @return {Object} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = bufferedBlockAlgorithm.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone._data = this._data.clone();\n\n\t            return clone;\n\t        },\n\n\t        _minBufferSize: 0\n\t    });\n\n\t    /**\n\t     * Abstract hasher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n\t     */\n\t    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n\t        /**\n\t         * Configuration options.\n\t         */\n\t        cfg: Base.extend(),\n\n\t        /**\n\t         * Initializes a newly created hasher.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hasher = CryptoJS.algo.SHA256.create();\n\t         */\n\t        init: function (cfg) {\n\t            // Apply config defaults\n\t            this.cfg = this.cfg.extend(cfg);\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this hasher to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.reset();\n\t         */\n\t        reset: function () {\n\t            // Reset data buffer\n\t            BufferedBlockAlgorithm.reset.call(this);\n\n\t            // Perform concrete-hasher logic\n\t            this._doReset();\n\t        },\n\n\t        /**\n\t         * Updates this hasher with a message.\n\t         *\n\t         * @param {WordArray|string} messageUpdate The message to append.\n\t         *\n\t         * @return {Hasher} This hasher.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.update('message');\n\t         *     hasher.update(wordArray);\n\t         */\n\t        update: function (messageUpdate) {\n\t            // Append\n\t            this._append(messageUpdate);\n\n\t            // Update the hash\n\t            this._process();\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Finalizes the hash computation.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n\t         *\n\t         * @return {WordArray} The hash.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hash = hasher.finalize();\n\t         *     var hash = hasher.finalize('message');\n\t         *     var hash = hasher.finalize(wordArray);\n\t         */\n\t        finalize: function (messageUpdate) {\n\t            // Final message update\n\t            if (messageUpdate) {\n\t                this._append(messageUpdate);\n\t            }\n\n\t            // Perform concrete-hasher logic\n\t            var hash = this._doFinalize();\n\n\t            return hash;\n\t        },\n\n\t        blockSize: 512/32,\n\n\t        /**\n\t         * Creates a shortcut function to a hasher's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to create a helper for.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHelper: function (hasher) {\n\t            return function (message, cfg) {\n\t                return new hasher.init(cfg).finalize(message);\n\t            };\n\t        },\n\n\t        /**\n\t         * Creates a shortcut function to the HMAC's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHmacHelper: function (hasher) {\n\t            return function (message, key) {\n\t                return new C_algo.HMAC.init(hasher, key).finalize(message);\n\t            };\n\t        }\n\t    });\n\n\t    /**\n\t     * Algorithm namespace.\n\t     */\n\t    var C_algo = C.algo = {};\n\n\t    return C;\n\t}(Math));\n\n\n\treturn CryptoJS;\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@unitybase/CryptoJS/core.js\n// module id = 4\n// module chunks = 1","/*\n @author pavel.mash\n */\n\n// ***********   !!!!WARNING!!!!! **********************\n// This module is a modified copy of server-side EventEmitter\n// to prevent conflicts in case on modification\n// modify both file - this and \\modules\\events.js\n\n/**\n * NodeJS like EventEmitter for Browser usage. See also <a href=\"http://nodejs.org/api/events.html\">NodeJS events documentation</a>\n *\n * To add event emitting ability to any object:\n *\n\n     var myObject = {},\n     var EventEmitter = UB.EventEmitter;\n     // add EventEmitter to myObject\n     EventEmitter.call(myObject);\n     _.assign(myObject, EventEmitter.prototype);\n\n * In case object created via constructor function\n\n     var EventEmitter = UB.EventEmitter;\n     function MyObject() {\n        EventEmitter.call(this);\n     }\n     MyObject.prototype = _.create(EventEmitter.prototype);\n     var myObject = new MyObject();\n     myObject instanceof UB.EventEmitter; //true\n\n * Usage:\n\n     myObject.on('myEvent', function(num, str){console.log(num, str) });\n\n     myObject.emit('myEvent', 1, 'two'); // output: 1 \"two\"\n\n *\n * @class EventEmitter\n * @mixin\n */\n\nfunction EventEmitter () {\n  EventEmitter.init.call(this)\n}\n\n/**\n * Private collection of events.\n * @private\n */\nEventEmitter.prototype._events = undefined\n/**\n * Use set/get MaxListeners instead direct access\n * @private\n */\nEventEmitter.prototype._maxListeners = undefined\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10\n\n/**\n * @private\n */\nEventEmitter.init = function () {\n  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = {}\n    this._eventsCount = 0\n  }\n\n  this._maxListeners = this._maxListeners || undefined\n}\n\n/**\n * Obviously not all Emitters should be limited to 10. This function allows\n * that to be increased. Set to zero for unlimited.\n * @param {Number} n\n */\nEventEmitter.prototype.setMaxListeners = function setMaxListeners (n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n))\n    { throw new TypeError('n must be a positive number') }\n  this._maxListeners = n\n  return this\n}\n\nfunction $getMaxListeners (that) {\n  if (that._maxListeners === undefined)\n    { return EventEmitter.defaultMaxListeners }\n  return that._maxListeners\n}\n\n/**\n *\n * @return {Number}\n */\nEventEmitter.prototype.getMaxListeners = function getMaxListeners () {\n  return $getMaxListeners(this)\n}\n\n// These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\nfunction emitNone (handler, isFn, self) {\n  if (isFn)\n    { handler.call(self) }\n  else {\n    var len = handler.length\n    var listeners = arrayClone(handler, len)\n    for (var i = 0; i < len; ++i)\n      { listeners[i].call(self) }\n  }\n}\nfunction emitOne (handler, isFn, self, arg1) {\n  if (isFn)\n    { handler.call(self, arg1) }\n  else {\n    var len = handler.length\n    var listeners = arrayClone(handler, len)\n    for (var i = 0; i < len; ++i)\n      { listeners[i].call(self, arg1) }\n  }\n}\nfunction emitTwo (handler, isFn, self, arg1, arg2) {\n  if (isFn)\n    { handler.call(self, arg1, arg2) }\n  else {\n    var len = handler.length\n    var listeners = arrayClone(handler, len)\n    for (var i = 0; i < len; ++i)\n      { listeners[i].call(self, arg1, arg2) }\n  }\n}\nfunction emitThree (handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn)\n    { handler.call(self, arg1, arg2, arg3) }\n  else {\n    var len = handler.length\n    var listeners = arrayClone(handler, len)\n    for (var i = 0; i < len; ++i)\n      { listeners[i].call(self, arg1, arg2, arg3) }\n  }\n}\n\nfunction emitMany (handler, isFn, self, args) {\n  if (isFn)\n    { handler.apply(self, args) }\n  else {\n    var len = handler.length\n    var listeners = arrayClone(handler, len)\n    for (var i = 0; i < len; ++i)\n      { listeners[i].apply(self, args) }\n  }\n}\n\n/**\n * Execute each of the listeners in order with the supplied arguments.\n * Returns true if event had listeners, false otherwise.\n *\n * @param {String} type Event name\n * @param {...*} eventArgs Arguments, passed to listeners\n * @return {boolean}\n */\nEventEmitter.prototype.emit = function emit (type) {\n  var er, handler, len, args, i, events/* UB domain */\n  // UB var needDomainExit = false;\n  var doError = (type === 'error')\n\n  events = this._events\n  if (events)\n    { doError = (doError && events.error == null) }\n  else if (!doError)\n    { return false }\n\n    // UB domain = this.domain;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    er = arguments[1]\n    if (er instanceof Error) {\n      throw er // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')')\n      err.context = er\n      throw err\n    }\n  }\n\n  handler = events[type]\n\n  if (!handler)\n    { return false }\n\n  var isFn = typeof handler === 'function'\n  len = arguments.length\n  switch (len) {\n    // fast cases\n    case 1:\n      emitNone(handler, isFn, this)\n      break\n    case 2:\n      emitOne(handler, isFn, this, arguments[1])\n      break\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2])\n      break\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3])\n      break\n    // slower\n    default:\n      args = new Array(len - 1)\n      for (i = 1; i < len; i++)\n        { args[i - 1] = arguments[i] }\n      emitMany(handler, isFn, this, args)\n  }\n\n  return true\n}\n\n/**\n * Adds a listener to the end of the listeners array for the specified event.\n * Will emit `newListener` event on success.\n *\n * Usage sample:\n *\n *      Session.on('login', function () {\n *          console.log('someone connected!');\n *      });\n *\n * Returns emitter, so calls can be chained.\n *\n * @param {String} type Event name\n * @param {Function} listener\n * @return {EventEmitter}\n */\nEventEmitter.prototype.addListener = function addListener (type, listener) {\n  var m\n  var events\n  var existing\n\n  if (typeof listener !== 'function')\n    { throw new TypeError('listener must be a function') }\n\n  events = this._events\n  if (!events) {\n    events = this._events = {}\n    this._eventsCount = 0\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      /** @event  newListener */\n      this.emit('newListener', type,\n                listener.listener ? listener.listener : listener)\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = this._events\n    }\n    existing = events[type]\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener\n    ++this._eventsCount\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = [existing, listener]\n    } else {\n      // If we've already got an array, just append.\n      existing.push(listener)\n    }\n\n    // Check for listener leak\n    if (!existing.warned) {\n      m = $getMaxListeners(this)\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d %s listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      existing.length, type)\n        console.trace()\n      }\n    }\n  }\n\n  return this\n}\n\n/**\n * Alias for {@link EventEmitter#addListener addListener}\n * @param {String} type Event name\n * @param {Function} listener\n * @return {EventEmitter}\n */\nEventEmitter.prototype.on = EventEmitter.prototype.addListener\n\n/**\n * Adds a one time listener for the event. This listener is invoked only the next time the event is fired, after which it is removed.\n * @param {String} type Event name\n * @param {Function} listener\n * @return {EventEmitter}\n */\nEventEmitter.prototype.once = function once (type, listener) {\n  if (typeof listener !== 'function')\n    { throw new TypeError('listener must be a function') }\n\n  var fired = false\n\n  function g () {\n    this.removeListener(type, g)\n\n    if (!fired) {\n      fired = true\n      listener.apply(this, arguments)\n    }\n  }\n\n  g.listener = listener\n  this.on(type, g)\n\n  return this\n}\n\n/**\n * Remove a listener from the listener array for the specified event.\n * Caution: changes array indices in the listener array behind the listener.\n * Emits a 'removeListener' event if the listener was removed.\n *\n * @param {String} type Event name\n * @param {Function} listener\n */\nEventEmitter.prototype.removeListener =\n    function removeListener (type, listener) {\n      var list, events, position, i\n\n      if (typeof listener !== 'function')\n        { throw new TypeError('listener must be a function') }\n\n      events = this._events\n      if (!events)\n        { return this }\n\n      list = events[type]\n      if (!list)\n        { return this }\n\n      if (list === listener || (list.listener && list.listener === listener)) {\n        if (--this._eventsCount === 0)\n          { this._events = {} }\n        else {\n          delete events[type]\n          if (events.removeListener)\n            /** @event removeListener */\n            { this.emit('removeListener', type, listener) }\n        }\n      } else if (typeof list !== 'function') {\n        position = -1\n\n        for (i = list.length; i-- > 0;) {\n          if (list[i] === listener ||\n              (list[i].listener && list[i].listener === listener)) {\n            position = i\n            break\n          }\n        }\n\n        if (position < 0)\n          { return this }\n\n        if (list.length === 1) {\n          list[0] = undefined\n          if (--this._eventsCount === 0) {\n            this._events = {}\n            return this\n          } else {\n            delete events[type]\n          }\n        } else {\n          spliceOne(list, position)\n        }\n\n        if (events.removeListener)\n          { this.emit('removeListener', type, listener) }\n      }\n\n      return this\n    }\n\n/**\n * Removes all listeners, or those of the specified event.\n * It's not a good idea to remove listeners that were added elsewhere in the code,\n * especially when it's on an emitter that you didn't create (e.g. sockets or file streams).\n *\n * Returns emitter, so calls can be chained.\n * @param {String} type Event name\n * @return {EventEmitter}\n */\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners (type) {\n      var listeners, events\n\n      events = this._events\n      if (!events)\n        { return this }\n\n      // not listening for removeListener, no need to emit\n      if (!events.removeListener) {\n        if (arguments.length === 0) {\n          this._events = {}\n          this._eventsCount = 0\n        } else if (events[type]) {\n          if (--this._eventsCount === 0)\n            { this._events = {} }\n          else\n            { delete events[type] }\n        }\n        return this\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events)\n        for (var i = 0, key; i < keys.length; ++i) {\n          key = keys[i]\n          if (key === 'removeListener') continue\n          this.removeAllListeners(key)\n        }\n        this.removeAllListeners('removeListener')\n        this._events = {}\n        this._eventsCount = 0\n        return this\n      }\n\n      listeners = events[type]\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners)\n      } else if (listeners) {\n        // LIFO order\n        do {\n          this.removeListener(type, listeners[listeners.length - 1])\n        } while (listeners[0])\n      }\n\n      return this\n    }\n\n/**\n * Returns an array of listeners for the specified event.\n * @param {String} type Event name\n * @return {Array.<Function>}\n */\nEventEmitter.prototype.listeners = function listeners (type) {\n  var evlistener\n  var ret\n  var events = this._events\n\n  if (!events)\n    { ret = [] }\n  else {\n    evlistener = events[type]\n    if (!evlistener)\n      { ret = [] }\n    else if (typeof evlistener === 'function')\n      { ret = [evlistener] }\n    else\n      { ret = arrayClone(evlistener, evlistener.length) }\n  }\n\n  return ret\n}\n\n/**\n * Return the number of listeners for a given event.\n * @param {EventEmitter} emitter\n * @param {String} type\n * @return {Number}\n */\nEventEmitter.listenerCount = function (emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type)\n  } else {\n    return listenerCount.call(emitter, type)\n  }\n}\n\nEventEmitter.prototype.listenerCount = listenerCount\nfunction listenerCount (type) {\n  var events = this._events\n\n  if (events) {\n    var evlistener = events[type]\n\n    if (typeof evlistener === 'function') {\n      return 1\n    } else if (evlistener) {\n      return evlistener.length\n    }\n  }\n\n  return 0\n}\n\n// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne (list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n    { list[i] = list[k] }\n  list.pop()\n}\n\nfunction arrayClone (arr, i) {\n  var copy = new Array(i)\n  while (i--)\n    { copy[i] = arr[i] }\n  return copy\n}\n\nmodule.exports = EventEmitter\n\n\n\n// WEBPACK FOOTER //\n// ./events.js","/**\r\n * Created by pavel.mash on 01.12.2016.\r\n */\r\n\r\nconst _ = require('lodash')\r\n\r\nconst __i18n = {\r\n  monkeyRequestsDetected: 'Your request has been processed, but we found that it is repeated several times. Maybe you key fuse?'\r\n}\r\n\r\n/**\r\n * Return locale-specific resource from it identifier.\r\n * localeString must be previously defined dy call to {i18nExtend}\r\n * @param {String} localeString\r\n * @returns {*}\r\n */\r\nfunction i18n (localeString) {\r\n  return __i18n[localeString] || localeString\r\n}\r\n\r\n/**\r\n * Merge localizationObject to UB.i18n. Usually called form modelPublic/locale/lang-*.js scripts\r\n * @param {Object} localizationObject\r\n */\r\nfunction i18nExtend (localizationObject) {\r\n  _.merge(__i18n, localizationObject)\r\n}\r\n\r\nmodule.exports = {\r\n  i18n,\r\n  i18nExtend\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./i18n.js",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Constants table\n\t    var T = [];\n\n\t    // Compute constants\n\t    (function () {\n\t        for (var i = 0; i < 64; i++) {\n\t            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;\n\t        }\n\t    }());\n\n\t    /**\n\t     * MD5 hash algorithm.\n\t     */\n\t    var MD5 = C_algo.MD5 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init([\n\t                0x67452301, 0xefcdab89,\n\t                0x98badcfe, 0x10325476\n\t            ]);\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Swap endian\n\t            for (var i = 0; i < 16; i++) {\n\t                // Shortcuts\n\t                var offset_i = offset + i;\n\t                var M_offset_i = M[offset_i];\n\n\t                M[offset_i] = (\n\t                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |\n\t                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)\n\t                );\n\t            }\n\n\t            // Shortcuts\n\t            var H = this._hash.words;\n\n\t            var M_offset_0  = M[offset + 0];\n\t            var M_offset_1  = M[offset + 1];\n\t            var M_offset_2  = M[offset + 2];\n\t            var M_offset_3  = M[offset + 3];\n\t            var M_offset_4  = M[offset + 4];\n\t            var M_offset_5  = M[offset + 5];\n\t            var M_offset_6  = M[offset + 6];\n\t            var M_offset_7  = M[offset + 7];\n\t            var M_offset_8  = M[offset + 8];\n\t            var M_offset_9  = M[offset + 9];\n\t            var M_offset_10 = M[offset + 10];\n\t            var M_offset_11 = M[offset + 11];\n\t            var M_offset_12 = M[offset + 12];\n\t            var M_offset_13 = M[offset + 13];\n\t            var M_offset_14 = M[offset + 14];\n\t            var M_offset_15 = M[offset + 15];\n\n\t            // Working varialbes\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\n\t            // Computation\n\t            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);\n\t            d = FF(d, a, b, c, M_offset_1,  12, T[1]);\n\t            c = FF(c, d, a, b, M_offset_2,  17, T[2]);\n\t            b = FF(b, c, d, a, M_offset_3,  22, T[3]);\n\t            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);\n\t            d = FF(d, a, b, c, M_offset_5,  12, T[5]);\n\t            c = FF(c, d, a, b, M_offset_6,  17, T[6]);\n\t            b = FF(b, c, d, a, M_offset_7,  22, T[7]);\n\t            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);\n\t            d = FF(d, a, b, c, M_offset_9,  12, T[9]);\n\t            c = FF(c, d, a, b, M_offset_10, 17, T[10]);\n\t            b = FF(b, c, d, a, M_offset_11, 22, T[11]);\n\t            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);\n\t            d = FF(d, a, b, c, M_offset_13, 12, T[13]);\n\t            c = FF(c, d, a, b, M_offset_14, 17, T[14]);\n\t            b = FF(b, c, d, a, M_offset_15, 22, T[15]);\n\n\t            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);\n\t            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);\n\t            c = GG(c, d, a, b, M_offset_11, 14, T[18]);\n\t            b = GG(b, c, d, a, M_offset_0,  20, T[19]);\n\t            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);\n\t            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);\n\t            c = GG(c, d, a, b, M_offset_15, 14, T[22]);\n\t            b = GG(b, c, d, a, M_offset_4,  20, T[23]);\n\t            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);\n\t            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);\n\t            c = GG(c, d, a, b, M_offset_3,  14, T[26]);\n\t            b = GG(b, c, d, a, M_offset_8,  20, T[27]);\n\t            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);\n\t            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);\n\t            c = GG(c, d, a, b, M_offset_7,  14, T[30]);\n\t            b = GG(b, c, d, a, M_offset_12, 20, T[31]);\n\n\t            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);\n\t            d = HH(d, a, b, c, M_offset_8,  11, T[33]);\n\t            c = HH(c, d, a, b, M_offset_11, 16, T[34]);\n\t            b = HH(b, c, d, a, M_offset_14, 23, T[35]);\n\t            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);\n\t            d = HH(d, a, b, c, M_offset_4,  11, T[37]);\n\t            c = HH(c, d, a, b, M_offset_7,  16, T[38]);\n\t            b = HH(b, c, d, a, M_offset_10, 23, T[39]);\n\t            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);\n\t            d = HH(d, a, b, c, M_offset_0,  11, T[41]);\n\t            c = HH(c, d, a, b, M_offset_3,  16, T[42]);\n\t            b = HH(b, c, d, a, M_offset_6,  23, T[43]);\n\t            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);\n\t            d = HH(d, a, b, c, M_offset_12, 11, T[45]);\n\t            c = HH(c, d, a, b, M_offset_15, 16, T[46]);\n\t            b = HH(b, c, d, a, M_offset_2,  23, T[47]);\n\n\t            a = II(a, b, c, d, M_offset_0,  6,  T[48]);\n\t            d = II(d, a, b, c, M_offset_7,  10, T[49]);\n\t            c = II(c, d, a, b, M_offset_14, 15, T[50]);\n\t            b = II(b, c, d, a, M_offset_5,  21, T[51]);\n\t            a = II(a, b, c, d, M_offset_12, 6,  T[52]);\n\t            d = II(d, a, b, c, M_offset_3,  10, T[53]);\n\t            c = II(c, d, a, b, M_offset_10, 15, T[54]);\n\t            b = II(b, c, d, a, M_offset_1,  21, T[55]);\n\t            a = II(a, b, c, d, M_offset_8,  6,  T[56]);\n\t            d = II(d, a, b, c, M_offset_15, 10, T[57]);\n\t            c = II(c, d, a, b, M_offset_6,  15, T[58]);\n\t            b = II(b, c, d, a, M_offset_13, 21, T[59]);\n\t            a = II(a, b, c, d, M_offset_4,  6,  T[60]);\n\t            d = II(d, a, b, c, M_offset_11, 10, T[61]);\n\t            c = II(c, d, a, b, M_offset_2,  15, T[62]);\n\t            b = II(b, c, d, a, M_offset_9,  21, T[63]);\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\n\t            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\n\t            var nBitsTotalL = nBitsTotal;\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (\n\t                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |\n\t                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)\n\t            );\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n\t                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |\n\t                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)\n\t            );\n\n\t            data.sigBytes = (dataWords.length + 1) * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Shortcuts\n\t            var hash = this._hash;\n\t            var H = hash.words;\n\n\t            // Swap endian\n\t            for (var i = 0; i < 4; i++) {\n\t                // Shortcut\n\t                var H_i = H[i];\n\n\t                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |\n\t                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);\n\t            }\n\n\t            // Return final computed hash\n\t            return hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    function FF(a, b, c, d, x, s, t) {\n\t        var n = a + ((b & c) | (~b & d)) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    function GG(a, b, c, d, x, s, t) {\n\t        var n = a + ((b & d) | (c & ~d)) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    function HH(a, b, c, d, x, s, t) {\n\t        var n = a + (b ^ c ^ d) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    function II(a, b, c, d, x, s, t) {\n\t        var n = a + (c ^ (b | ~d)) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.MD5('message');\n\t     *     var hash = CryptoJS.MD5(wordArray);\n\t     */\n\t    C.MD5 = Hasher._createHelper(MD5);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacMD5(message, key);\n\t     */\n\t    C.HmacMD5 = Hasher._createHmacHelper(MD5);\n\t}(Math));\n\n\n\treturn CryptoJS.MD5;\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@unitybase/CryptoJS/md5.js\n// module id = 7\n// module chunks = 1",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Initialization and round constants tables\n\t    var H = [];\n\t    var K = [];\n\n\t    // Compute constants\n\t    (function () {\n\t        function isPrime(n) {\n\t            var sqrtN = Math.sqrt(n);\n\t            for (var factor = 2; factor <= sqrtN; factor++) {\n\t                if (!(n % factor)) {\n\t                    return false;\n\t                }\n\t            }\n\n\t            return true;\n\t        }\n\n\t        function getFractionalBits(n) {\n\t            return ((n - (n | 0)) * 0x100000000) | 0;\n\t        }\n\n\t        var n = 2;\n\t        var nPrime = 0;\n\t        while (nPrime < 64) {\n\t            if (isPrime(n)) {\n\t                if (nPrime < 8) {\n\t                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n\t                }\n\t                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\n\t                nPrime++;\n\t            }\n\n\t            n++;\n\t        }\n\t    }());\n\n\t    // Reusable object\n\t    var W = [];\n\n\t    /**\n\t     * SHA-256 hash algorithm.\n\t     */\n\t    var SHA256 = C_algo.SHA256 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init(H.slice(0));\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var H = this._hash.words;\n\n\t            // Working variables\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\t            var e = H[4];\n\t            var f = H[5];\n\t            var g = H[6];\n\t            var h = H[7];\n\n\t            // Computation\n\t            for (var i = 0; i < 64; i++) {\n\t                if (i < 16) {\n\t                    W[i] = M[offset + i] | 0;\n\t                } else {\n\t                    var gamma0x = W[i - 15];\n\t                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n\t                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n\t                                   (gamma0x >>> 3);\n\n\t                    var gamma1x = W[i - 2];\n\t                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n\t                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n\t                                   (gamma1x >>> 10);\n\n\t                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n\t                }\n\n\t                var ch  = (e & f) ^ (~e & g);\n\t                var maj = (a & b) ^ (a & c) ^ (b & c);\n\n\t                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n\t                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n\t                var t1 = h + sigma1 + ch + K[i] + W[i];\n\t                var t2 = sigma0 + maj;\n\n\t                h = g;\n\t                g = f;\n\t                f = e;\n\t                e = (d + t1) | 0;\n\t                d = c;\n\t                c = b;\n\t                b = a;\n\t                a = (t1 + t2) | 0;\n\t            }\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t            H[4] = (H[4] + e) | 0;\n\t            H[5] = (H[5] + f) | 0;\n\t            H[6] = (H[6] + g) | 0;\n\t            H[7] = (H[7] + h) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Return final computed hash\n\t            return this._hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA256('message');\n\t     *     var hash = CryptoJS.SHA256(wordArray);\n\t     */\n\t    C.SHA256 = Hasher._createHelper(SHA256);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA256(message, key);\n\t     */\n\t    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n\t}(Math));\n\n\n\treturn CryptoJS.SHA256;\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@unitybase/CryptoJS/sha256.js\n// module id = 8\n// module chunks = 1","/**\r\n * Helper class for manipulation with data, stored locally in ({@link TubCachedData} format).\r\n *\r\n * This module shared between client & server. In case of server we use it together with {@link dataLoader},\r\n * in case of client - inside {@link UBConnection#select} to handle operations with entity data cached in IndexedDB.\r\n *\r\n * For server-side samples see ubm_forms.doSelect method implementation.\r\n *\r\n * Client-side sample:\r\n *\r\n *         $App.connection.run({\r\n                entity: 'tst_IDMapping',\r\n                method: 'addnew',\r\n                fieldList: ['ID', 'code']\r\n           }).done(function(result){\r\n                // here result in array-of-array format: [{\"entity\":\"tst_IDMapping\",\"method\":\"addnew\",\"fieldList\":[\"ID\",\"code\"],\"__fieldListExternal\":[\"ID\",\"code\"],\"resultData\":{\"fields\":[\"ID\",\"code\"],\"rowCount\": 1, \"data\":[[3500000016003,null]]}}]\r\n                var objArray = UB.LocalDataStore.selectResultToArrayOfObjects(result); // transform array-of-array result representation to array-of-object\r\n                console.log(objArray); // now result in more simple array-of-object format: [{ID: 12312312312, code: null}]\r\n           });\r\n\r\n * @module @unitybase/base/LocalDataStore\r\n */\r\n/*\r\n @author pavel.mash\r\n */\r\n\r\n// ***********   !!!!WARNING!!!!! **********************\r\n// Module shared between server and client code\r\n\r\nconst _ = require('lodash')\r\n/**\r\n * Format for UBQ select request\r\n * @typedef {Object} TubSelectRequest\r\n * @property {Array<String>} fieldList Array of entity attribute names\r\n * @property {Object} whereList Where clauses\r\n * @property {Object} orderList Order clauses\r\n * @property {Object} options Options\r\n * @property {Number} ID ID\r\n */\r\n\r\n/**\r\n * Format for data, stored in client-side cache\r\n * @typedef {Object} TubCachedData\r\n * @property {Array<Array>} data\r\n * @property {Array<String>} fields\r\n * @property {Number} rowCount\r\n */\r\n\r\n/**\r\n * Perform local filtration and sorting of data array according to ubRequest whereList & order list\r\n * @param {TubCachedData} cachedData Data, retrieved from cache\r\n * @param {TubSelectRequest} ubRequest Initial server request\r\n * @returns {*} new filtered & sorted array\r\n */\r\nmodule.exports.doFilterAndSort = function (cachedData, ubRequest) {\r\n  let rangeStart\r\n\r\n  let filteredData = this.doFiltration(cachedData, ubRequest)\r\n  let totalLength = filteredData.length\r\n  this.doSorting(filteredData, cachedData, ubRequest)\r\n    // apply options start & limit\r\n  if (ubRequest.options) {\r\n    rangeStart = ubRequest.options.start || 0\r\n    if (ubRequest.options.limit) {\r\n      filteredData = filteredData.slice(rangeStart, rangeStart + ubRequest.options.limit)\r\n    } else {\r\n      filteredData = filteredData.slice(rangeStart)\r\n    }\r\n  }\r\n  return {\r\n    resultData: {\r\n      data: filteredData,\r\n      fields: cachedData.fields\r\n    },\r\n    total: totalLength\r\n  }\r\n}\r\n\r\n/**\r\n * Just a helper for search cached data by row ID\r\n * @param {TubCachedData} cachedData Data, retrieved from cache\r\n * @param {Number} IDValue row ID.\r\n */\r\nmodule.exports.byID = function (cachedData, IDValue) {\r\n  return this.doFilterAndSort(cachedData, {ID: IDValue})\r\n}\r\n\r\n/**\r\n * Apply ubRequest.whereList to data array and return new array contain filtered data\r\n * @protected\r\n * @param {TubCachedData} cachedData Data, retrieved from cache\r\n * @param {TubSelectRequest} ubRequest\r\n * @returns {Array.<Array>}\r\n */\r\nmodule.exports.doFiltration = function (cachedData, ubRequest) {\r\n  let f, isAcceptable\r\n  let rawDataArray = cachedData.data\r\n  let byPrimaryKey = Boolean(ubRequest.ID)\r\n\r\n  let filterFabric = whereListToFunctions(ubRequest, cachedData.fields)\r\n  let filterCount = filterFabric.length\r\n\r\n  if (filterCount === 0) {\r\n    return rawDataArray\r\n  }\r\n\r\n  let result = []\r\n  let l = rawDataArray.length\r\n  let i = -1\r\n  while (++i < l) { // for each data\r\n    isAcceptable = true; f = -1\r\n    while (++f < filterCount && isAcceptable === true) {\r\n      isAcceptable = filterFabric[f](rawDataArray[i])\r\n    }\r\n    if (isAcceptable) {\r\n      result.push(rawDataArray[i])\r\n      if (byPrimaryKey) {\r\n        return result\r\n      }\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * Apply ubRequest.orderList to inputArray (inputArray is modified)\r\n * @protected\r\n * @param {Array.<Array>} filteredArray\r\n * @param {TubCachedData} cachedData\r\n * @param {Object} ubRequest\r\n */\r\nmodule.exports.doSorting = function (filteredArray, cachedData, ubRequest) {\r\n  let preparedOrder = []\r\n  if (ubRequest.orderList) {\r\n    _.each(ubRequest.orderList, function (orderItem) {\r\n      let attrIdx = cachedData.fields.indexOf(orderItem.expression)\r\n      if (attrIdx < 0) {\r\n        throw new Error('Ordering by ' + orderItem.expression + ' attribute that don\\'t present in fieldList not allowed')\r\n      }\r\n      preparedOrder.push({\r\n        idx: attrIdx,\r\n        modifier: (orderItem.order === 'desc') ? -1 : 1\r\n      })\r\n    })\r\n    let orderLen = preparedOrder.length\r\n    if (orderLen) {\r\n      let compareFn = function (v1, v2) {\r\n        let res = 0\r\n        let idx = -1\r\n        while (++idx < orderLen && res === 0) {\r\n          let colNum = preparedOrder[idx].idx\r\n          if (v1[colNum] !== v2[colNum]) {\r\n            if (v1[colNum] === null && v2[colNum] !== null) {\r\n              res = 1\r\n            } else if (v2[colNum] === null && v1[colNum] !== null) {\r\n              res = -1\r\n            } else if (v2[colNum] === null && v1[colNum] === null) {\r\n              res = 0\r\n            } else if (v1[colNum] > v2[colNum]) {\r\n              res = 1\r\n            } else {\r\n              res = -1\r\n            }\r\n            res = res * preparedOrder[idx].modifier\r\n          }\r\n        }\r\n        return res\r\n      }\r\n      filteredArray.sort(compareFn)\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Transform whereList to array of function\r\n * @private\r\n * @param {TubSelectRequest} request\r\n * @param {Array.<String>} fieldList\r\n * @returns {Array}\r\n */\r\nfunction whereListToFunctions (request, fieldList) {\r\n  let propIdx, fValue, filterFabricFn\r\n  let filters = []\r\n  let escapeForRegexp = function (text) {  // TODO - do we need this?\r\n    return text && typeof text === 'string' ? text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&') : ''\r\n  }\r\n  let whereList = request.whereList\r\n\r\n  filterFabricFn = function (propertyIdx, condition, value) {\r\n    let regExpFilter\r\n\r\n    switch (condition) {\r\n      case 'like':\r\n        regExpFilter = new RegExp(escapeForRegexp(value), 'i')\r\n        return function (record) {\r\n          let val = record[propertyIdx]\r\n          return val && regExpFilter.test(val)\r\n        }\r\n      case 'equal':\r\n        return function (record) {\r\n          return record[propertyIdx] === value\r\n        }\r\n      case 'notEqual':\r\n        return function (record) {\r\n          return record[propertyIdx] !== value\r\n        }\r\n      case 'more':\r\n        return function (record) {\r\n          return record[propertyIdx] > value\r\n        }\r\n      case 'moreEqual':\r\n        return function (record) {\r\n          return record[propertyIdx] >= value\r\n        }\r\n      case 'less':\r\n        return function (record) {\r\n          return record[propertyIdx] < value\r\n        }\r\n      case 'lessEqual':\r\n        return function (record) {\r\n          return record[propertyIdx] <= value\r\n        }\r\n      case 'isNull':\r\n        return function (record) {\r\n          return record[propertyIdx] === null\r\n        }\r\n      case 'notIsNull':\r\n        return function (record) {\r\n          return record[propertyIdx] !== null\r\n        }\r\n      case 'notLike':\r\n        regExpFilter = new RegExp(escapeForRegexp(value), 'i')\r\n        return function (record) {\r\n          let val = record[propertyIdx]\r\n          return val && !regExpFilter.test(val)\r\n        }\r\n      case 'startWith':\r\n        return function (record) {\r\n          let str = record[propertyIdx]\r\n          return (str && str.indexOf(value) === 0)\r\n        }\r\n      case 'notStartWith':\r\n        return function (record) {\r\n          let str = record[propertyIdx]\r\n          return str && str.indexOf(value) !== 0\r\n        }\r\n      case 'in':\r\n        return function (record) {\r\n          let str = record[propertyIdx]\r\n          return str && value.indexOf(str) >= 0\r\n        }\r\n      case 'notIn':\r\n        return function (record) {\r\n          let str = record[propertyIdx]\r\n          return str && value.indexOf(str) < 0\r\n        }\r\n      default:\r\n        throw new Error('Unknown whereList condition')\r\n    }\r\n  }\r\n\r\n  function transformClause (clause) {\r\n    let property = clause.expression || ''\r\n\r\n    if (clause.condition === 'custom') {\r\n      throw new Error('Condition \"custom\" is not supported for cached instances.')\r\n    }\r\n    property = (property.replace(/(\\[)|(])/ig, '') || '').trim()\r\n    propIdx = fieldList.indexOf(property)\r\n    if (propIdx === -1) {\r\n      throw new Error('Filtering by field ' + property + ' is not allowed, because it is not pressing in fieldList')\r\n    }\r\n\r\n    fValue = _.values(clause.values)[0]\r\n    filters.push(filterFabricFn(propIdx, clause.condition, fValue))\r\n  }\r\n    // check for top level ID  - in this case add condition for filter by ID\r\n  if (request.ID) {\r\n    transformClause({expression: '[ID]', condition: 'equal', values: {ID: request.ID}})\r\n  }\r\n  _.forEach(whereList, transformClause)\r\n  return filters\r\n}\r\n\r\n/**\r\n * Transform result of {@link UBConnection#select} response\r\n * from Array of Array representation to Array of Object.\r\n *\r\n *      LocalDataStore.selectResultToArrayOfObjects({resultData: {\r\n *          data: [['row1_attr1Val', 1], ['row2_attr2Val', 22]],\r\n *          fields: ['attrID.name', 'attr2']}\r\n *      });\r\n *      // result is:\r\n *      // [{\"attrID.name\": \"row1_attr1Val\", attr2: 1},\r\n *      //  {\"attrID.name\": \"row2_attr2Val\", attr2: 22}\r\n *      // ]\r\n *\r\n *      // object keys simplify by passing fieldAliases\r\n *      LocalDataStore.selectResultToArrayOfObjects({resultData: {\r\n *          data: [['row1_attr1Val', 1], ['row2_attr2Val', 22]],\r\n *          fields: ['attrID.name', 'attr2']}\r\n *      }, {'attrID.name': 'attr1Name'});\r\n *      // result is:\r\n *      // [{attr1Name: \"row1_attr1Val\", attr2: 1},\r\n *      //  {attr1Name: \"row2_attr2Val\", attr2: 22}\r\n *      // ]\r\n *\r\n * @param {{resultData: TubCachedData}} selectResult\r\n * @param {Object<string, string>} [fieldAlias] Optional object to change attribute names during transform array to object. Keys are original names, values - new names\r\n * @returns {Array.<*>}\r\n */\r\nmodule.exports.selectResultToArrayOfObjects = function (selectResult, fieldAlias) {\r\n  let inData = selectResult.resultData.data\r\n  let inAttributes = selectResult.resultData.fields\r\n  let inDataLength = inData.length\r\n  let result = inDataLength ? new Array(inDataLength) : []\r\n  if (fieldAlias) {\r\n    _.forEach(fieldAlias, function (alias, field) {\r\n      let idx = inAttributes.indexOf(field)\r\n      if (idx >= 0) {\r\n        inAttributes[idx] = alias\r\n      }\r\n    })\r\n  }\r\n  for (let i = 0; i < inDataLength; i++) {\r\n    result[i] = _.zipObject(inAttributes, inData[i])\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * Flatten cached data (or result of {@link LocalDataStore#doFilterAndSort}.resultData )\r\n * to Object expected by TubDataStore.initialize Flatten format (faster than [{}..] format).\r\n *\r\n        //consider we have cached data in variable filteredData.resultData\r\n        // to initialize dataStore with cached data:\r\n        mySelectMethod = function(ctxt){\r\n            var fieldList = ctxt.mParams.fieldList;\r\n            resp = LocalDataStore.flatten(fieldList, filteredData.resultData);\r\n            ctxt.dataStore.initFromJSON(resp);\r\n        }\r\n *\r\n * cachedData may contain more field or field in order not in requestedFieldList - in this case we use expectedFieldList\r\n * @param {Array.<string>} requestedFieldList Array of attributes to transform to. Can be ['*'] - in this case we return all cached attributes\r\n * @param {TubCachedData} cachedData\r\n * @result {{fieldCount: number, rowCount: number, values: array.<*>}}\r\n */\r\nmodule.exports.flatten = function (requestedFieldList, cachedData) {\r\n  let fldIdxArr = []\r\n  let cachedFields = cachedData.fields\r\n  let rowIdx = -1\r\n  let col = -1\r\n  let pos = 0\r\n  let resultData = []\r\n  let rowCount = cachedData.data.length\r\n  let idx, row, fieldCount\r\n\r\n  if (!requestedFieldList || !requestedFieldList.length) {\r\n    throw new Error('fieldList not exist or empty')\r\n  }\r\n\r\n    // client ask for all attributes\r\n  if (requestedFieldList.length === 1 && requestedFieldList[0] === '*') {\r\n    requestedFieldList = cachedData.fields\r\n  }\r\n\r\n  requestedFieldList.forEach(function (field) {\r\n    idx = cachedFields.indexOf(field)\r\n    if (idx !== -1) {\r\n      fldIdxArr.push(idx)\r\n    } else {\r\n      throw new Error('Invalid field list. Attribute ' + field + ' not found in local data store')\r\n    }\r\n  })\r\n  fieldCount = requestedFieldList.length\r\n  resultData.length = rowCount * (fieldCount + 1) // reserve fieldCount for field names\r\n  while (++col < fieldCount) {\r\n    resultData[pos] = requestedFieldList[pos]; pos++\r\n  }\r\n  while (++rowIdx < rowCount) {\r\n    col = -1; row = cachedData.data[rowIdx]\r\n    while (++col < fieldCount) {\r\n      resultData[pos++] = row[ fldIdxArr[col] ]\r\n    }\r\n  }\r\n  return {fieldCount: fieldCount, rowCount: rowCount, values: resultData}\r\n}\r\n\r\n/**\r\n * Reverse conversion to {@link LocalDataStore#selectResultToArrayOfObjects}\r\n * Transform array of object to array of array using passed attributes array\r\n *\r\n *      LocalDataStore.arrayOfObjectsToSelectResult([{a: 1, b: 'as'}, {b: 'other', a: 12}], ['a', 'b']);\r\n *      // result is: [[1,\"as\"],[12,\"other\"]]\r\n *\r\n * @param {Array.<Object>} arrayOfObject\r\n * @param {Array.<String>} attributeNames\r\n * @returns {Array.<Array>}\r\n */\r\nmodule.exports.arrayOfObjectsToSelectResult = function (arrayOfObject, attributeNames) {\r\n  let result = []\r\n  arrayOfObject.forEach(function (obj) {\r\n    let row = []\r\n    attributeNames.forEach(function (attribute) {\r\n      row.push(obj[attribute])\r\n    })\r\n    result.push(row)\r\n  })\r\n  return result\r\n}\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// ./../base/LocalDataStore.js","var LocalDataStore = require('@unitybase/base/LocalDataStore')\r\nvar CustomRepository = require('@unitybase/base/CustomRepository')\r\n\r\n/**\r\n * Repository for client-side data retrieve.\r\n * Implement:\r\n *\r\n *  - {@link ClientRepository#select} method able to return `array of object` representation of server entity\r\n *  - {@link ClientRepository#selectAsArray} method able to return `array of object` representation of server entity\r\n *  - {@link ClientRepository#selectAsStore} method able to return {UB.ux.data.UBStore} (applicable only for Ext-based client types)\r\n *\r\n * Usually created using {@link UB#Repository UB.Repository} fabric function. Example:\r\n *\r\n *      var store = UB.Repository('my_entity').attrs(['ID', 'code'])\r\n *       .where('code', 'includes', ['1', '2', '3'])  // code in ('1', '2', '3')\r\n *       .where('name', 'contains', 'Homer'). // name like '%homer%'\r\n *       .where('birtday', 'geq', new Date()).where('birtday', 'leq', new Date() + 10) //(birtday >= '2012-01-01') AND (birtday <= '2012-01-02')\r\n *       .where('[age] -10', '>=', {age: 15}, 'byAge') // (age + 10 >= 15)\r\n *       .where('', 'match', 'myvalue'). // for condition match expression not need\r\n *       .logic('(byStrfType OR bySrfKindID)AND(dasdsa)')\r\n *       .select().then(function(response){\r\n *          // here response is in [{ID: 10, code: 'value1'}, .... {}] format\r\n *       });;\r\n *\r\n *\r\n * @class ClientRepository\r\n * @extends CustomRepository\r\n * @author pavel.mash 23.09.2014\r\n */\r\n\r\n/**\r\n * Create a new CustomRepository\r\n * @constructor\r\n * @param {UBConnection} connection\r\n * @param {String} entityName name of Entity we create for\r\n */\r\nfunction ClientRepository (connection, entityName) {\r\n    // noinspection JSUnresolvedFunction\r\n  CustomRepository.call(this, entityName)\r\n  this.connection = connection\r\n}\r\nClientRepository.prototype = Object.create(CustomRepository.prototype)\r\nClientRepository.prototype.constructor = ClientRepository\r\n\r\n/**\r\n * Asynchronously run request, constructed by Repository. Return promise, resolved to `array of object` representation of response.\r\n *\r\n *      UB.Repository('ubm_navshortcut').attrs(['ID', 'code'])\r\n *      .where('code', 'in', ['uba_user', 'uba_auditTrail'])\r\n *      .selectAsObj().then(function(store){\r\n *          console.log(store); // output is [{\"ID\":3000000000004,\"code\":\"uba_user\"},{\"ID\":3000000000039,\"code\":\"ubs_audit\"}]\r\n *      });\r\n *\r\n *  Optionally can rename attributes in the resulting object:\r\n *\r\n *      UB.Repository('investment')\r\n *      .attrs(['ID', 'product', 'product.name', 'product.provider.name'])\r\n *      .selectAsObject({\r\n            'product.name': 'productName',\r\n            'product.provider.name': 'productProviderName'\r\n        }).then(function(result){\r\n            console.log(result); // output [{\"ID\": 1, \"productName\": \"My product\", \"productProviderName\": \"My provider\"}, ...]\r\n        });\r\n *\r\n * @param {Object<string, string>} [fieldAliases] Optional object to change attribute names during transform array to object\r\n * @return {Promise}\r\n */\r\nClientRepository.prototype.selectAsObject = function (fieldAliases) {\r\n  return this.connection.select(this.ubql()).then(function (res) {\r\n    return LocalDataStore.selectResultToArrayOfObjects(res, fieldAliases)\r\n  })\r\n}\r\n\r\n/**\r\n * Asynchronously run request, constructed by Repository. Return promise, resolved to `array of array` representation of response.\r\n * Actual data is placed to `resultData` response property.\r\n *\r\n *      UB.Repository('ubm_navshortcut').attrs(['ID', 'code'])\r\n *      .where('code', 'in', ['uba_user', 'ubs_audit'])\r\n *      .select().then(UB.logDebug);\r\n *      // output is {\"resultData\":{\"data\":[[3000000000004,\"uba_user\"],[3000000000039,\"ubs_audit\"]],\"fields\":[\"ID\",\"code\"]},\"total\":2}\r\n *\r\n * Response MAY (but may not even for the same request) contain other variables, returned by server in case data retrieved not from cache\r\n *\r\n *      UB.Repository('uba_user').attrs(['ID', 'name', 'ID.name']) // since uba_user have `unity` mixin it ID property point us to parent (`uba_subject` in this case)\r\n *      .selectAsArray().then(UB.logDebug);\r\n *      // {\"entity\":\"uba_user\",\"fieldList\":[\"ID\",\"name\",\"ID.name\"],\"method\":\"select\",\"resultData\":{\"fields\":[\"ID\",\"name\",\"ID.name\"],\"rowCount\":1,\"data\":[[10,\"admin\",\"admin\"]]},\"total\":1}\r\n *\r\n * But resultData is always present\r\n *\r\n * @return {Promise}\r\n */\r\nClientRepository.prototype.selectAsArray = function () {\r\n  return this.connection.select(this.ubql())\r\n}\r\n\r\n/**\r\n * For core module (without Ext) - do the same as {ClientRepository.selectAsObj}\r\n *\r\n * For EntJS based client (actual implementation in {UB.ux.data.UBStore}) - create store based on request, constructed by Repository.\r\n * Return promise resolved to loaded {UB.ux.data.UBStore} instance.\r\n *\r\n *      UB.Repository('ubm_navshortcut').attrs(['ID', 'code']).where('code', 'in', ['uba_user', 'ubs_audit'])\r\n *      .selectAsStore().then(function(store){\r\n *          console.log(store.getTotalCount()); // here store is UB.ux.data.UBStore instance\r\n *      });\r\n *\r\n * @param {Object} [storeConfig] optional config passed to store constructor\r\n * @return {Promise}\r\n */\r\nClientRepository.prototype.selectAsStore = ClientRepository.prototype.selectAsObject\r\n\r\n/**\r\n * Alias to {ClientRepository.selectAsObject}\r\n */\r\nClientRepository.prototype.select = ClientRepository.prototype.selectAsObject\r\n\r\n/**\r\n * Select a single row. If ubql result is empty - return {undefined}.\r\n *\r\n * WARNING method do not check repository contains the single row and always return a first row from result.\r\n * @param {{field: alias}} [fieldAliases] Optional object to change attribute names during transform array to object\r\n * @return {Promise} Promise, resolved to {Object|undefined}\r\n */\r\nClientRepository.prototype.selectSingle = function (fieldAliases) {\r\n  return this.selectAsObject(fieldAliases).then(function (row) {\r\n    return row[0]\r\n  })\r\n}\r\n\r\n/**\r\n * Perform select and return a value of the first attribute from the first row\r\n *\r\n * WARNING method do not check repository contains the single row\r\n * @return {Promise} Promise, resolved to {Object|undefined}\r\n */\r\nClientRepository.prototype.selectScalar = function () {\r\n  return this.selectAsArray().then(function (result) {\r\n    return (result.resultData.rowCount > 0) ? result.resultData.data[0][0] : undefined\r\n  })\r\n}\r\n\r\n/**\r\n * Select a single row by ID. If ubql result is empty - return {undefined}.\r\n *\r\n * @param {Number} ID Row identifier\r\n * @param {{field: alias}} [fieldAliases] Optional object to change attribute names during transform result to object\r\n * @return {Promise} Promise, resolved to {Object|undefined}\r\n */\r\nClientRepository.prototype.selectById = function (ID, fieldAliases) {\r\n  return this.where('[ID]', '=', ID).selectSingle()\r\n}\r\n\r\nmodule.exports = ClientRepository\r\n\n\n\n// WEBPACK FOOTER //\n// ./ClientRepository.js","/*\r\n @author xmax, mpv\r\n */\r\n\r\nconst ubUtils = require('./utils')\r\nconst i18n = require('./i18n').i18n\r\nconst EventEmitter = require('./events')\r\n/**\r\n * Registered features.\r\n * @type {Object}\r\n */\r\nUBNativeMessage.features = {\r\n  extension: {\r\n    host: 'none', UIName: 'NMUBExtension', minVersion: '1.0.0', installer: 'pgffhmifenmomiabibdpnceahangimdi' // downloads/UBBrowserNativeMessagesHostApp.exe\r\n  },\r\n  dstu: {\r\n    host: 'com.inbase.dstu', UIName: 'NMFeatureDSTU', minVersion: '1.0.0.5', installer: 'models/DSTU/ub-extension/UBHostDSTUIITSetup{0}.exe', libraryName: 'UBHostDSTU.dll'\r\n  },\r\n  iit: {\r\n    host: 'com.inbase.iit', UIName: 'NMFeatureIIT', minVersion: '1.0.0.5', installer: 'models/DSTU/ub-extension/UBHostDSTUIITSetup{0}.exe', libraryName: 'UBHostIIT.dll'\r\n  },\r\n  pdfsigner: {\r\n    host: 'com.inbase.pdfsigner', UIName: 'NMFeaturePDFSigner', minVersion: '1.0.0.3', installer: 'models/PDF/ub-extension/UBHostPdfSignSetup{0}.' + (ubUtils.isMac ? 'pkg' : 'exe'), libraryName: 'SET _LIB_NAME_IN_UBNATIVENMESSAGES.dll'\r\n  },\r\n  scanner: {\r\n    host: 'com.inbase.scanner', UIName: 'NMFeatureScanner', minVersion: '1.0.0.4', installer: 'models/PDF/ub-extension/UBHostScannerSetup{0}.exe', libraryName: 'UBHostScanner.dll'\r\n  },\r\n  docedit: {\r\n    host: 'com.inbase.docedit', UIName: 'NMFeatureDocEdit', minVersion: '1.0.0.1', installer: 'models/UB/ub-extension/UBHostDocEditSetup{0}.exe', libraryName: 'UBHostDocEdit.dll'\r\n  }\r\n}\r\n\r\nUBNativeMessage.features.iit.minVersion = UBNativeMessage.features.dstu.minVersion\r\n\r\n/**\r\n * @classdesc\r\n * Class for communicate with native messages plugin `content script`.\r\n * DOM element with `id=\"ubExtensionPageMessageObj\"` must be present on the target page.\r\n *\r\n * If target page is loaded into iframe then parent (iframe owner) page must contains a DOM element with `id=\"ubExtensionPageMessageObj\"`.\r\n *\r\n * The preferred way to communicate with native messages plugin feature is a  UBNativeMessage descendants, for example {@link UBNativeScanner} for scanning etc.\r\n *\r\n * Usage:\r\n *\r\n *      var nm = new UBNativeMessage('scanner');\r\n *      nm.connect().then(UB.logDebug);\r\n *      nm.connect.then(function(nm){\r\n *          UB.logDebug('connected to feature version', nm.featureVersion);\r\n *          return nm.invoke('methodName', {a: 10, b: 20})\r\n *      }).then(UB.logDebug).then(nm.disconnect.bind(nm));\r\n *\r\n *\r\n *      var nm = new UBNativeMessage();\r\n *      nm.onMessage = function(message){\r\n *         console.log(message);\r\n *      };\r\n *      nm.onDisconnected = function(sender){\r\n *         console.log('disconnected');\r\n *      };\r\n *      nm.connect(5000).then( function(nm){\r\n *          nm.sendMessage({text: 'Message : Hello!'});\r\n *      });\r\n *\r\n * @constructor\r\n * @param {String} [feature] Feature we want from plugin. Feature<->application decoding is accessible via {@link UBNativeMessage#features} object\r\n */\r\nfunction UBNativeMessage (feature) {\r\n  var\r\n    me = this,\r\n    __messageCounter = 0\r\n\r\n  me.getMessageId = function () {\r\n    return 'm' + (++__messageCounter)\r\n  }\r\n\r\n  ++UBNativeMessage.prototype.idCounter\r\n  me.id = 'UBPlugin' + UBNativeMessage.prototype.idCounter\r\n\r\n  me.pendingMessages = {}\r\n    /**\r\n     * @readonly\r\n     * @property {String} Feature native messages registered for\r\n     */\r\n  me.feature = feature || 'extension'\r\n    /**\r\n     * Name of plugin interface in host application.\r\n     * @type {string}\r\n     */\r\n  me.pluginName = feature\r\n  me.hostAppName = UBNativeMessage.features[feature].host\r\n  if (!me.hostAppName) {\r\n    throw new Error('unknown feature ' + feature + ' for UBNativeMessage')\r\n  }\r\n\r\n    /**\r\n     * Feature version. Defined after success connect() call.\r\n     * @property {string} featureVersion\r\n     */\r\n  me.featureVersion = ''\r\n    /**\r\n     * Default operation timeout\r\n     * @property {number} callTimeOut\r\n     */\r\n  me.callTimeOut = 30000\r\n  if (ubUtils.isSecureBrowser) {\r\n    me.eventElm = {}\r\n    EventEmitter.call(me.eventElm)\r\n    _.assign(me.eventElm, EventEmitter.prototype)\r\n    me.eventElm.addEventListener = me.eventElm.addListener\r\n  } else {\r\n    me.eventElm = document.getElementById('ubExtensionPageMessageObj')\r\n\r\n    if (!me.eventElm && (!window.parent || (window.parent === window))) {\r\n      throw new Error('Message exchange element with id=\"ubExtensionPageMessageObj\" not found')\r\n    }\r\n  }\r\n\r\n    // must be defined inside constructor for removeEventListener work properly\r\n  me.onContentMessage = function (event) {\r\n    var msg, pending, messageID, msgType, totalParts, currentPart, data\r\n    msg = event.detail\r\n    if (!msg || !msg.hasOwnProperty('msgType') || !msg.hasOwnProperty('messageID') || !msg.hasOwnProperty('clientID')) {\r\n      console.error('Empty or invalid content message')\r\n    }\r\n    if (msg.clientID !== me.id) { // this is message to another UBNativeMessage instance\r\n      return\r\n    }\r\n\r\n    messageID = msg['messageID']\r\n    msgType = msg['msgType']\r\n    data = msg['data']\r\n    pending = me.pendingMessages[messageID]\r\n    if (pending) {\r\n      clearTimeout(pending.timerID)\r\n    }\r\n    if (msgType === 'disconnected') {\r\n      if (pending) { // disconnect is sended from this\r\n        delete me.pendingMessages[messageID]\r\n        pending.deffer.resolve(data)\r\n      }\r\n      me.doOnDisconnect(data)\r\n    } else {\r\n      if (msgType === 'notify') {\r\n        if (!pending && me.onMessage) { // notification from plugin without messageID\r\n          me.onMessage.call(me, data)\r\n        } else { // notification to request. Increase timeout\r\n          pending.timerID = setTimeout(function () { me.onMsgTimeOut(messageID) }, pending.timeoutValue)\r\n          pending.deffer.notify(data)\r\n        }\r\n      } else if (!pending) {\r\n        console.error('UBNativeMessage. unknown messageID:' + messageID)\r\n      } else if (msgType === 'resolve') {\r\n        if (msg.hasOwnProperty('part') && msg.hasOwnProperty('totalParts')) { // partial response\r\n          totalParts = msg['totalParts']; currentPart = msg['part']\r\n          if (!pending.partials) {\r\n            if (totalParts > 100) { // 100 Mb limit\r\n              pending.deffer.reject(new ubUtils.UBError('unknownError', 'UBNativeMessage. Result exceed 100Mb limit'))\r\n              delete me.pendingMessages[messageID]\r\n              throw new Error(new ubUtils.UBError('unknownError', 'UBNativeMessage. Result exceed 100Mb limit'))\r\n            }\r\n            pending.partials = new Array(totalParts)\r\n          } else {\r\n            if ((totalParts !== pending.partials.length) || (currentPart >= totalParts)) {\r\n              pending.deffer.reject('Invalid part count')\r\n              delete me.pendingMessages[messageID]\r\n              throw new Error('Invalid part count')\r\n            }\r\n          }\r\n          pending.partials[currentPart] = data\r\n          if (_.indexOf(pending.partials, undefined) === -1) { // all parts come - ready to resolve. lodash using is important here - Array.indexOf not wok with `undefined`\r\n            data = pending.partials.join('')\r\n            delete me.pendingMessages[messageID]\r\n            if ((data.charAt(0) === '{') || (data.charAt(0) === '[')) { // data is JSON\r\n              data = JSON.parse(data)\r\n            }\r\n            pending.deffer.resolve(data)\r\n          } else {\r\n            pending.timerID = setTimeout(function () { me.onMsgTimeOut(messageID) }, pending.timeoutValue)\r\n          }\r\n        } else {\r\n          delete me.pendingMessages[messageID]\r\n          pending.deffer.resolve(data)\r\n        }\r\n      } else if (msgType === 'reject') {\r\n        delete me.pendingMessages[messageID]\r\n        var isUserMessage = false, err\r\n        if (/<<<.*>>>/.test(data)) {\r\n          data = data.match(/<<<(.*)>>>/)[1]\r\n          isUserMessage = true\r\n        }\r\n        if (isUserMessage) {\r\n          err = new ubUtils.UBError(data)\r\n        } else {\r\n          err = new ubUtils.UBError('unknownError', data)\r\n        }\r\n//                pending.deffer.reject(new Error(data));\r\n        pending.deffer.reject(err)\r\n      } else {\r\n        throw new Error('UBNativeMessage. Invalid msgType type in: ' + msg)\r\n      }\r\n    }\r\n  }\r\n  me.eventElm.addEventListener('UBExtensionMsg', me.onContentMessage)\r\n    /**\r\n     * Called when disconnecting the plugin.\r\n     * @property {Function} onDisconnected\r\n     */\r\n  me.onDisconnected = null\r\n    /**\r\n     * Called when receive new `notify` message from host application not to invoked method.\r\n     * @property {Function} onMessage\r\n     */\r\n  me.onMessage = null\r\n}\r\n\r\nUBNativeMessage.versionToNumber = function (versionStr) {\r\n  var\r\n        arr = versionStr.split('.'), mutliplier = 1, i, l = arr.length, res = 0\r\n  if (arr.length > 4) {\r\n    throw new Error('Invalid version number ' + versionStr)\r\n  }\r\n  for (i = l - 1; i >= 0; i--) {\r\n    res += parseInt(arr[i], 10) * mutliplier; mutliplier *= (i === l - 1) ? 10000 : 1000 // last number may be 4 digit 1.2.3.1234\r\n  }\r\n  return res\r\n}\r\n\r\n/**\r\n * Invoke feature method with optional params\r\n * @param {String} methodName\r\n * @param {Object} [methodParams] Do not pass empty object {} here!\r\n * @param {Number} [timeout] operation timeout. Default to {@link UBNativeMessage#callTimeOut}\r\n * @return {Promise}\r\n */\r\nUBNativeMessage.prototype.invoke = function (methodName, methodParams, timeout) {\r\n  var me = this,\r\n    msgID = me.getMessageId(),\r\n    messageToSend\r\n\r\n  if (!me.connected && methodName.substr(0, 2) !== '__') { // allow pseudo methods\r\n    return Promise.reject(new ubUtils.UBError('unknownError', 'UBNativeMessage. Not connected. call connect() first'))\r\n  }\r\n\r\n    // methodParams = methodParams || null;\r\n  timeout = timeout || me.callTimeOut\r\n\r\n  messageToSend = {clientID: me.id, messageID: msgID, method: methodName, params: methodParams}\r\n  return new Promise((resolve, reject) => {\r\n    let pendingRequest = {\r\n      request: null, // MPV - do not store - we do not need it!  messageToSend,\r\n      deffer: {resolve, reject},\r\n      timerID: setTimeout(function () { me.onMsgTimeOut(msgID) }, timeout),\r\n      partials: null,\r\n      timeoutValue: timeout || me.callTimeOut,\r\n      stTime: (new Date()).getTime()\r\n    }\r\n    me.pendingMessages[msgID] = pendingRequest\r\n    // if (UB.isSecureBrowser) {\r\n    //     if (methodName === '__extensionVersion') {\r\n    //         me.eventElm.emit('UBExtensionMsg', {\r\n    //             detail: {\r\n    //                 clientID: me.id,\r\n    //                 messageID: msgID,\r\n    //                 msgType: 'resolve',\r\n    //                 data: UBNativeMessage.features.extension.minVersion\r\n    //             }\r\n    //         });\r\n    //     } else if (methodName === '__connect') {\r\n    //         var path = require('path'),\r\n    //             ffi =require(path.join(path.parse(process.execPath).dir, '..', 'ffi')),\r\n    //             Library = ffi.Library;\r\n    //\r\n    //         me.doInvoke = new Library(\r\n    //             path.join(path.parse(process.execPath).dir, UBNativeMessage.features[me.feature].libraryName),\r\n    //             {'invoke': ['void', ['string', 'pointer'], { async: true }]}\r\n    //         ).invoke;\r\n    //         me.funcPtr = ffi.Callback('void', [ 'string' ],\r\n    //             function(param) {\r\n    //                 var detail = JSON.parse(param);\r\n    //                 me.eventElm.emit('UBExtensionMsg', {\r\n    //                     detail: detail\r\n    //                 });\r\n    //             }\r\n    //         );\r\n    //         messageToSend.method = 'getVersion';\r\n    //         me.doInvoke(JSON.stringify(messageToSend), me.funcPtr, function(){});\r\n    //     } else {\r\n    //         me.doInvoke(JSON.stringify(messageToSend), me.funcPtr, function(){});\r\n    //     }\r\n    // } else\r\n    if (me.iFarmeMode) {\r\n      window.parent.postMessage({detail: messageToSend, messageType: 'UBPageMsg'}, '*')\r\n    } else {\r\n      me.eventElm.dispatchEvent(new CustomEvent('UBPageMsg', {detail: messageToSend}))\r\n    }\r\n  })\r\n}\r\n\r\n/**\r\n * Return true if browser extension was installed\r\n * @returns {boolean}\r\n */\r\nUBNativeMessage.extensionExists = function () {\r\n  if (ubUtils.isSecureBrowser) return true\r\n\r\n  var e\r\n  e = document.getElementById('ubExtensionPageMessageObj')\r\n  if (window.parent && (window.parent !== window)) {\r\n    return true // check in connect\r\n\t\t// e = window.parent.document.getElementById('ubExtensionPageMessageObj');\r\n  }\r\n\r\n  return !!e && (e.getAttribute('data-extensionAttached') === 'YES')\r\n}\r\n\r\nUBNativeMessage.prototype.doOnDisconnect = function (reason) {\r\n  var me = this,\r\n    rejections = me.pendingMessages\r\n  me.pendingMessages = {} // prevent several rejection\r\n  me.connected = false\r\n  if (rejections) {\r\n    _.forEach(rejections, function (pendingRequest) {\r\n      if (pendingRequest && pendingRequest.deffer) {\r\n        pendingRequest.deffer.reject(reason)\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nUBNativeMessage.prototype.onParentWinMessage = function (event) {\r\n  if (!event.data || (event.data.messageType !== 'UBExtensionMsg')) {\r\n    return\r\n  }\r\n  this.onContentMessage(event.data)\r\n}\r\n\r\n/**\r\n * Connect to native messages host. Check extension & host is installed and up to date (according to UBNativeMessage.features).\r\n * @param {Number} [timeOut] Connection timeOut in millisecond. Default to UBNativeMessage.callTimeOut\r\n * @returns {Promise<UBNativeMessage>} resolved to UBNativeMessage or rejected to installation/upgrade message\r\n */\r\nUBNativeMessage.prototype.connect = function (timeOut) {\r\n  let me = this\r\n  let promise\r\n  if (me.connected) {\r\n    return Promise.resolve(me)\r\n  } else {\r\n    if (!UBNativeMessage.extensionExists()) {\r\n      return Promise.reject(new ubUtils.UBError(UBNativeMessage.createFeatureUpdateMsg('extension', '-', false)))\r\n    } else {\r\n      if (window.parent && (window.parent !== window)) { // in iframe\r\n        promise = new Promise((resolve, reject) => {\r\n          let timeId\r\n          let onMessage = function (event) {\r\n            if (!event.data || (event.data.messageType !== 'initUbExtensionParent')) {\r\n              return event\r\n            }\r\n            clearTimeout(timeId)\r\n            if (event.data.detail !== 'initUbExtensionReady') {\r\n              reject(new ubUtils.UBError(UBNativeMessage.createFeatureUpdateMsg('extension', '-', false)))\r\n              return event\r\n            }\r\n            me.iFarmeMode = true\r\n            window.removeEventListener('message', onMessage)\r\n            window.addEventListener('message', me.onParentWinMessage.bind(me), false)\r\n            resolve(true)\r\n          }\r\n          window.addEventListener('message', onMessage, false)\r\n          window.parent.postMessage({messageType: 'initUbExtension'}, '*')\r\n          timeId = setTimeout(function () {\r\n            reject(new ubUtils.UBError(UBNativeMessage.createFeatureUpdateMsg('extension', '-', false)))\r\n          }, 1500)\r\n        })\r\n      } else {\r\n        promise = Promise.resolve(true)\r\n      }\r\n      return promise.then(function () {\r\n        return me.invoke('__extensionVersion')\r\n      }).then(function (extensionVersion) {\r\n        let versionNum = UBNativeMessage.versionToNumber(extensionVersion)\r\n        if (versionNum < UBNativeMessage.versionToNumber(UBNativeMessage.features.extension.minVersion)) {\r\n          ubUtils.logDebug('browser extension version', extensionVersion, 'is smaller when required', UBNativeMessage.features.extension.minVersion)\r\n          throw new ubUtils.UBError(UBNativeMessage.createFeatureUpdateMsg('extension', extensionVersion, true))\r\n        } else {\r\n          if (versionNum !== UBNativeMessage.versionToNumber(UBNativeMessage.features.extension.minVersion)) {\r\n            ubUtils.logDebug('Current version of extension', extensionVersion, 'is more than required', UBNativeMessage.features.extension.minVersion)\r\n          }\r\n          return true\r\n        }\r\n      }).then(function () {\r\n        return me.invoke('__connect', {hostAppName: me.hostAppName}, timeOut).then(function (featureVersion) {\r\n          let requiredVersion = UBNativeMessage.features[me.feature].minVersion\r\n          me.connected = true\r\n          me.featureVersion = featureVersion\r\n          if (UBNativeMessage.versionToNumber(featureVersion) < UBNativeMessage.versionToNumber(requiredVersion)) {\r\n            throw new ubUtils.UBError(UBNativeMessage.createFeatureUpdateMsg(me.feature, featureVersion, true))\r\n          } else if (featureVersion !== requiredVersion) {\r\n            ubUtils.logDebug('Current version of feature', me.feature, featureVersion, 'is more than required', requiredVersion)\r\n          }\r\n          return me\r\n        }, function (reason) {\r\n          ubUtils.logError(reason)\r\n          throw new ubUtils.UBError(UBNativeMessage.createFeatureUpdateMsg(me.feature, '-', false))\r\n        })\r\n      }).catch(function (reason) {\r\n        me.disconnect()\r\n        throw reason\r\n      })\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Disconnect from native\r\n * @return {*}\r\n */\r\nUBNativeMessage.prototype.disconnect = function () {\r\n  let me = this\r\n  if (!me.connected) {\r\n    return Promise.resolve(true)\r\n  }\r\n  return me.invoke('__disconnect').then(function (message) {\r\n    ubUtils.logDebug('UBNativeMessage. Disconnected with message', message)\r\n    me.connected = false\r\n    if (me.eventElm) {\r\n      me.eventElm.removeEventListener('UBExtensionMsg', me.onContentMessage)\r\n    }\r\n    return true\r\n  })\r\n}\r\n\r\nUBNativeMessage.prototype.onMsgTimeOut = function (msgID) {\r\n  var me = this,\r\n    pending\r\n  pending = me.pendingMessages[msgID]\r\n  if (pending) {\r\n    pending.timerID = null\r\n    delete me.pendingMessages[msgID]\r\n    pending.deffer.reject(new ubUtils.UBError('unknownError', 'pluginMethodCallTimedOut'))\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n * @type {number}\r\n */\r\nUBNativeMessage.prototype.idCounter = 0\r\n\r\nUBNativeMessage.createFeatureUpdateMsg = function (featureName, currentVersion, isUpdate) {\r\n  var\r\n    featureInfo = UBNativeMessage.features[featureName],\r\n    res, msg,\r\n    installer = ubUtils.format(featureInfo.installer, featureInfo.minVersion /* .replace(/\\./g, '_') */)\r\n\r\n  msg = 'NM' + (isUpdate ? 'Update' : 'Install') + ((featureName === 'extension') ? 'Extension' + (ubUtils.isOpera ? 'Opera' : 'Chrome') : 'Feature')\r\n  res = ubUtils.format(i18n(msg), i18n(featureInfo.UIName), featureInfo.minVersion, currentVersion, installer)\r\n  return res\r\n}\r\n\r\nmodule.exports = UBNativeMessage\r\n\n\n\n// WEBPACK FOOTER //\n// ./UBNativeMessage.js","/**\r\n * Created by pavel.mash on 01.12.2016.\r\n */\r\n\r\n/* global XMLHttpRequest */\r\n\r\nconst ubUtils = require('./utils')\r\n\r\nfunction lowercase (str) {\r\n  return (str || '').toLowerCase()\r\n}\r\n\r\nfunction parseHeaders (headers) {\r\n  let parsed = {}\r\n  let key, val, i\r\n\r\n  if (!headers) {\r\n    return parsed\r\n  }\r\n\r\n  headers.split('\\n').forEach(function (line) {\r\n    i = line.indexOf(':')\r\n    key = lowercase(line.substr(0, i).trim())\r\n    val = line.substr(i + 1).trim()\r\n\r\n    if (key) {\r\n      if (parsed[key]) {\r\n        parsed[key] += ', ' + val\r\n      } else {\r\n        parsed[key] = val\r\n      }\r\n    }\r\n  })\r\n\r\n  return parsed\r\n}\r\n\r\nfunction headersGetter (headers) {\r\n  let headersObj = typeof headers === 'object' ? headers : undefined\r\n  return function (name) {\r\n    if (!headersObj) {\r\n      headersObj = parseHeaders(headers)\r\n    }\r\n    if (name) {\r\n      return headersObj[lowercase(name)]\r\n    }\r\n    return headersObj\r\n  }\r\n}\r\n\r\nfunction transformData (data, headers, fns) {\r\n  if (typeof fns === 'function') {\r\n    return fns(data, headers)\r\n  }\r\n  fns.forEach(function (fn) {\r\n    data = fn(data, headers)\r\n  })\r\n  return data\r\n}\r\n\r\nfunction transformDataPromise (data, headers, fns) {\r\n  let rPromise = Promise.resolve(data)\r\n  if (typeof fns === 'function') {\r\n    return rPromise.then(function (data) {\r\n      return fns(data, headers)\r\n    })\r\n  }\r\n  fns.forEach(function (fn) {\r\n    rPromise = rPromise.then(function (data) {\r\n      return fn(data, headers)\r\n    })\r\n  })\r\n  return rPromise\r\n}\r\n\r\nfunction isSuccess (status) {\r\n  return status >= 200 && status < 300\r\n}\r\n\r\nfunction forEach (obj, iterator, context) {\r\n  let keys = Object.keys(obj)\r\n  keys.forEach(function (key) {\r\n    iterator.call(context, obj[key], key)\r\n  })\r\n  return keys\r\n}\r\n\r\nfunction forEachSorted (obj, iterator, context) {\r\n  let keys = Object.keys(obj).sort()\r\n  keys.forEach(function (key) {\r\n    iterator.call(context, obj[key], key)\r\n  })\r\n  return keys\r\n}\r\n\r\nfunction buildUrl (url, params) {\r\n  if (!params) return url\r\n  let parts = []\r\n  forEachSorted(params, function (value, key) {\r\n    if (value == null) { // jshint ignore:line\r\n      return\r\n    }\r\n    if (!Array.isArray(value)) {\r\n      value = [value]\r\n    }\r\n\r\n    value.forEach(function (v) {\r\n      if (typeof v === 'object') {\r\n        v = JSON.stringify(v)\r\n      }\r\n      parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(v))\r\n    })\r\n  })\r\n  return url + ((url.indexOf('?') === -1) ? '?' : '&') + parts.join('&')\r\n}\r\n\r\nlet __lastRequestData\r\nlet __lastRequestTime = new Date().getTime()\r\nlet __lastRequestURL\r\n\r\n/**\r\n * Promise of perform an asynchronous HTTP request\r\n * Returns a {Promise} object with the\r\n *   standard Promise methods (<a href=\"https://github.com/kriskowal/q/wiki/Coming-from-jQuery#reference\">reference</a>).\r\n *   The `then` method takes two arguments a success and an error callback which will be called with a\r\n *   response object. The arguments passed into these functions are destructured representation of the response object passed into the\r\n *   `then` method. The response object has these properties:\r\n *\r\n *   - **data** – `{string|Object}` – The response body transformed with the transform\r\n *     functions. Default transform check response content-type is application/json and if so - convert data to Object\r\n *   - **status** – `{number}` – HTTP status code of the response.\r\n *   - **headers** – `{function([headerName])}` – Header getter function.\r\n *   - **config** – `{Object}` – The configuration object that was used to generate the request.\r\n *\r\n *  @example\r\n *\r\n *      //Get some data from server:\r\n *      UB.xhr({url: 'getAppInfo'}).then(function(resp) {\r\n *          console.log('this is appInfo: %o', resp.data)\r\n *      });\r\n *\r\n *      //The same, but in more short form via {@link UB#get UB.get} shorthand:\r\n *      UB.get('getAppInfo').then(function(resp) {\r\n *          console.log('this is appInfo: %o', resp.data)\r\n *      });\r\n *\r\n *      //Run POST method:\r\n *      UB.post('ubql', [\r\n *          {entity: 'uba_user', method: 'select', fieldList: ['*']}\r\n *      ]).then(function(resp) {\r\n *          console.log('success!');\r\n *      }, function(resp) {\r\n *          console.log('request failed with status' + resp.status);\r\n *      });\r\n *\r\n *      //retrieve binary data as ArrayBuffer\r\n *      UB.get('downloads/cert/ACSK(old).cer', {responseType: 'arraybuffer'})\r\n *      .then(function(res){\r\n *          console.log('Got Arrray of %d length', res.data.byteLength);\r\n *      });\r\n *\r\n * @method\r\n * @param {Object} requestConfig Object describing the request to be made and how it should be\r\n *    processed. The object has following properties:\r\n * @param {String} requestConfig.url  Absolute or relative URL of the resource that is being requested\r\n * @param {String} [requestConfig.method] HTTP method (e.g. 'GET', 'POST', etc). Default is GET\r\n * @param {Object.<string|Object>} [requestConfig.params] Map of strings or objects which will be turned\r\n *      to `?key1=value1&key2=value2` after the url. If the value is not a string, it will be JSONified\r\n * @param {String|Object} [requestConfig.data] Data to be sent as the request message data\r\n * @param {Object} [requestConfig.headers]  Map of strings or functions which return strings representing\r\n *      HTTP headers to send to the server. If the return value of a function is null, the\r\n *      header will not be sent. Merged with {@link UB#xhrDefaults UB.xhrDefaults.headers}\r\n * @param {function(data, function)|Array.<function(data, function)>} [requestConfig.transformRequest]\r\n *      Transform function or an array of such functions. The transform function takes the http\r\n *      request body and headers and returns its transformed (typically serialized) version.\r\n * @param {function(data, function)|Array.<function(data, function)>} [requestConfig.transformResponse]\r\n *      Transform function or an array of such functions. The transform function takes the http\r\n *      response body and headers and returns its transformed (typically deserialized) version.\r\n * @param  {Number|Promise} [requestConfig.timeout] timeout in milliseconds, or {@link Q promise}\r\n *      that should abort the request when resolved. Default to {UB.xhrDefaults.timeout}\r\n * @param  {Boolean} [requestConfig.withCredentials] whether to to set the `withCredentials` flag on the\r\n *      XHR object. See <a href=\"https://developer.mozilla.org/en/http_access_control#section_5\">requests with credentials</a>\r\n *      for more information.\r\n * @param  {String} [requestConfig.responseType] see <a href=\"https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType\">responseType</a>.\r\n * @param {Function} [requestConfig.onProgress] XHR onProgress callback, see <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ProgressEvent\">ProgressEvent</url> for details.\r\n *      To be user instead obsolete Q Promise.progress()\r\n * @returns {Promise}\r\n */\r\nfunction xhr (requestConfig) {\r\n  let defaults = xhrDefaults\r\n  let config = {\r\n    transformRequest: defaults.transformRequest,\r\n    transformResponse: defaults.transformResponse\r\n  }\r\n  let mergeHeaders = function (config) {\r\n    let defHeaders = defaults.headers\r\n    let reqHeaders = ubUtils.apply({}, config.headers)\r\n    let defHeaderName, lowercaseDefHeaderName, reqHeaderName\r\n\r\n    let execHeaders = function (headers) {\r\n      forEach(headers, function (headerFn, header) {\r\n        if (typeof headerFn === 'function') {\r\n          let headerContent = headerFn()\r\n          if (headerContent) {\r\n            headers[header] = headerContent\r\n          } else {\r\n            delete headers[header]\r\n          }\r\n        }\r\n      })\r\n    }\r\n\r\n    defHeaders = ubUtils.apply({}, defHeaders.common, defHeaders[lowercase(config.method)])\r\n\r\n    // execute if header value is function\r\n    execHeaders(defHeaders)\r\n    execHeaders(reqHeaders)\r\n\r\n    // using for-in instead of forEach to avoid unecessary iteration after header has been found\r\n    // noinspection Eslint\r\n    defaultHeadersIteration:\r\n      for (defHeaderName in defHeaders) {\r\n        lowercaseDefHeaderName = lowercase(defHeaderName)\r\n        for (reqHeaderName in reqHeaders) {\r\n          if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {\r\n            // noinspection Eslint\r\n            continue defaultHeadersIteration\r\n          }\r\n        }\r\n        reqHeaders[defHeaderName] = defHeaders[defHeaderName]\r\n      }\r\n    return reqHeaders\r\n  }\r\n  let headers = mergeHeaders(requestConfig)\r\n\r\n  ubUtils.apply(config, requestConfig)\r\n  config.headers = headers\r\n  config.method = config.method ? config.method.toUpperCase() : 'GET'\r\n\r\n  let transformResponse, serverRequest, promise\r\n\r\n  transformResponse = function (response) {\r\n    return transformDataPromise(response.data, response.headers, config.transformResponse)\r\n      .then(function (trdData) {\r\n        response.data = trdData\r\n        return isSuccess(response.status) ? response : Promise.reject(response)\r\n      })\r\n  }\r\n\r\n  serverRequest = function (config) {\r\n    headers = config.headers\r\n    let reqData = transformData(config.data, headersGetter(headers), config.transformRequest)\r\n    let prevReqTime = __lastRequestTime\r\n    __lastRequestTime = new Date().getTime()\r\n    // strip content-type if data is undefined\r\n    if (!config.data) {\r\n      forEach(headers, function (value, header) {\r\n        if (lowercase(header) === 'content-type') {\r\n          delete headers[header]\r\n        }\r\n      })\r\n    } else {\r\n      // prevent reiteration sending of the same request\r\n      // for example if HTML button on the form got a focus and `space` pressed\r\n      // in case button not disabled inside `onclick` handler we got a many-many same requests\r\n      if ((__lastRequestURL === config.url) && (typeof reqData === 'string') && (__lastRequestData === reqData) && (__lastRequestTime - prevReqTime < 100)) {\r\n        throw new ubUtils.UBError('monkeyRequestsDetected')\r\n      } else {\r\n        __lastRequestData = reqData\r\n        __lastRequestURL = config.url\r\n      }\r\n    }\r\n\r\n    if (!config.withCredentials && defaults.withCredentials) {\r\n      config.withCredentials = defaults.withCredentials\r\n    }\r\n    if (!config.timeout && defaults.timeout) {\r\n      config.timeout = defaults.timeout\r\n    }\r\n\r\n    // send request\r\n    return sendReq(config, reqData, headers).then(transformResponse, transformResponse)\r\n  }\r\n\r\n  promise = Promise.resolve(config)\r\n\r\n  // build a promise chain with request interceptors first, then the request, and response interceptors\r\n  interceptors.filter(function (interceptor) {\r\n    return !!interceptor.request || !!interceptor.requestError\r\n  }).map(function (interceptor) {\r\n    return { success: interceptor.request, failure: interceptor.requestError }\r\n  })\r\n  .concat({ success: serverRequest })\r\n  .concat(interceptors.filter(function (interceptor) {\r\n    return !!interceptor.response || !!interceptor.responseError\r\n  }).map(function (interceptor) {\r\n    return { success: interceptor.response, failure: interceptor.responseError }\r\n  })\r\n  ).forEach(function (then) {\r\n    promise = promise.then(then.success, then.failure)\r\n  })\r\n\r\n  return promise\r\n}\r\n\r\n/**\r\n * Allow Request reiteration, for example in case of request are repeated after re-auth\r\n */\r\nxhr.allowRequestReiteration = function () {\r\n  __lastRequestData = null\r\n}\r\n\r\nconst CONTENT_TYPE_APPLICATION_JSON = { 'Content-Type': 'application/json;charset=utf-8' }\r\n\r\n/**\r\n * The default HTTP parameters for {xhr}\r\n * @property {Object} xhrDefaults\r\n * @property {Array<Function>} xhrDefaults.transformRequest request transformations\r\n * @property {Array<Function>} xhrDefaults.transformResponse response transformations\r\n * @property {Object} xhrDefaults.headers Default headers to apply to request (depending of method)\r\n * @property {Number} xhrDefaults.timeout Default timeout to apply to request\r\n */\r\nlet xhrDefaults = {\r\n  transformRequest: [function (data) {\r\n    return !!data && typeof data === 'object' && data.toString() !== '[object File]' && data.toString() !== '[object ArrayBuffer]'\r\n      ? JSON.stringify(data) : data\r\n  }],\r\n  transformResponse: [function (data, headers) {\r\n    if (typeof data === 'string' && (headers('content-type') || '').indexOf('json') >= 0) {\r\n      data = JSON.parse(data)\r\n    }\r\n    return data\r\n  }],\r\n  headers: {\r\n    common: { 'Accept': 'application/json, text/plain, */*' },\r\n    post: CONTENT_TYPE_APPLICATION_JSON,\r\n    put: CONTENT_TYPE_APPLICATION_JSON,\r\n    patch: CONTENT_TYPE_APPLICATION_JSON\r\n  },\r\n  timeout: 120000\r\n}\r\n\r\n/**\r\n * Interceptors array\r\n * @type {Array.<Object>}\r\n * @protected\r\n */\r\nconst interceptors = []\r\n\r\n/**\r\n * Array of config objects for currently pending requests. This is primarily meant to be used for debugging purposes.\r\n * @type {Array.<Object>}\r\n * @protected\r\n */\r\nconst pendingRequests = []\r\n\r\nconst XHR = XMLHttpRequest\r\nfunction sendReq (config, reqData, reqHeaders) {\r\n  let url = buildUrl(config.url, config.params)\r\n  let promise = new Promise(function (resolve, reject) {\r\n    let xhr = new XHR()\r\n    let aborted = -1\r\n    let status, timeoutId\r\n\r\n    pendingRequests.push(config)\r\n\r\n    xhr.open(config.method, url, true)\r\n    forEach(reqHeaders /* MPV config.headers */, function (value, key) {\r\n      if (value) {\r\n        xhr.setRequestHeader(key, value)\r\n      }\r\n    })\r\n\r\n    xhr.onreadystatechange = function () {\r\n      if (xhr.readyState === 4) {\r\n        let response, responseHeaders\r\n        if (status !== aborted) {\r\n          responseHeaders = xhr.getAllResponseHeaders()\r\n          // responseText is the old-school way of retrieving response (supported by IE8 & 9)\r\n          // response/responseType properties were introduced in XHR Level2 spec (supported by IE10)\r\n          response = xhr.responseType ? xhr.response : xhr.responseText\r\n        }\r\n\r\n        // cancel timeout and subsequent timeout promise resolution\r\n        if (timeoutId) {\r\n          clearTimeout(timeoutId)\r\n        }\r\n        status = status || xhr.status\r\n        xhr = null\r\n\r\n        // normalize status, including accounting for IE bug (http://bugs.jquery.com/ticket/1450)\r\n        status = Math.max(status === 1223 ? 204 : status, 0)\r\n\r\n        let idx = pendingRequests.indexOf(config)\r\n        if (idx !== -1) {\r\n          pendingRequests.splice(idx, 1)\r\n        }\r\n\r\n        (isSuccess(status) ? resolve : reject)({\r\n          data: response,\r\n          status: status,\r\n          headers: headersGetter(responseHeaders),\r\n          config: config\r\n        })\r\n      }\r\n    }\r\n\r\n    if (config.onProgress) {\r\n      if (xhr.upload) {\r\n        xhr.upload.onprogress = config.onProgress\r\n      } else {\r\n        xhr.onprogress = config.onProgress\r\n      }\r\n    }\r\n\r\n    if (config.withCredentials) {\r\n      xhr.withCredentials = true\r\n    }\r\n\r\n    if (config.responseType) {\r\n      xhr.responseType = config.responseType\r\n    }\r\n\r\n    xhr.send(reqData || null)\r\n\r\n    if (config.timeout > 0) {\r\n      timeoutId = setTimeout(function () {\r\n        status = aborted\r\n        if (xhr) {\r\n          xhr.abort()\r\n        }\r\n      }, config.timeout)\r\n    }\r\n  })\r\n\r\n  return promise\r\n}\r\n\r\n/**\r\n * Shortcut for {@link UB.xhr} to perform a `GET` request.\r\n * @method\r\n * @param {string} url Relative or absolute URL specifying the destination of the request\r\n * @param {Object=} [config] Optional configuration object as in {@link UB#xhr UB.xhr}\r\n * @returns {Promise} Future object\r\n */\r\nfunction get (url, config) {\r\n  return xhr(ubUtils.apply(config || {}, {\r\n    method: 'GET',\r\n    url: url\r\n  }))\r\n}\r\n\r\n/**\r\n * Shortcut for {@link UB.xhr} to perform a `POST` request.\r\n * @method\r\n * @param {string} url Relative or absolute URL specifying the destination of the request\r\n * @param {*} data Request content\r\n * @param {Object=} [config] Optional configuration object as in {@link UB#xhr UB.xhr}\r\n * @returns {Promise} Future object\r\n */\r\nfunction post (url, data, config) {\r\n  return xhr(ubUtils.apply(config || {}, {\r\n    method: 'POST',\r\n    url: url,\r\n    data: data\r\n  }))\r\n}\r\n\r\n// TODO - move to adminUI\r\n// var reLetters = /[A-Za-zА-Яа-яЁёіІїЇґҐ]/,\r\n//   reEn = /[A-Za-z]/,\r\n//   reCaps = /[A-ZА-ЯЁІЇҐ]/\r\n//\r\n// UB.passwordKeyUpHandler = function (textfield) {\r\n//   var t, n, s = textfield.getValue() || ''\r\n//   if (!s) {\r\n//     textfield.removeCls('ub-pwd-keyboard-caps')\r\n//     textfield.removeCls('ub-pwd-keyboard-en')\r\n//   } else {\r\n//     n = s.length\r\n//     t = s.substr(n - 1, 1)\r\n//     if (reLetters.test(t)) {\r\n//       if (reEn.test(t)) {\r\n//         textfield.addClass('ub-pwd-keyboard-en')\r\n//       } else {\r\n//         textfield.removeCls('ub-pwd-keyboard-en')\r\n//       }\r\n//       if (reCaps.test(t)) {\r\n//         textfield.addClass('ub-pwd-keyboard-caps')\r\n//       } else {\r\n//         textfield.removeCls('ub-pwd-keyboard-caps')\r\n//       }\r\n//     }\r\n//   }\r\n// }\r\n\r\nmodule.exports = {\r\n  interceptors,\r\n  pendingRequests,\r\n  xhrDefaults,\r\n  xhr,\r\n  get,\r\n  post\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./transport.js","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 13\n// module chunks = 1","/**\r\n * Repository for server-side data retrieve\r\n *\r\n * @module @unitybase/base/CustomRepository\r\n * @author pavel.mash 23.09.2014\r\n */\r\n\r\n// ***********   !!!!WARNING!!!!! **********************\r\n// Module shared between server and client code\r\nconst _ = require('lodash')\r\nconst bracketsRe = /\\[.*]/\r\n// in case values for where is null we transform condition to allowed null comparison with warning.\r\n// If condition not in conditionInCaseValueIsNull object keys we raise error\r\nconst conditionInCaseValueIsNull = {equal: 'isNull', notEqual: 'notIsNull', custom: 'custom'}\r\n\r\n/**\r\n * Base data access class for server-side, client(browser)-side and client(console) side Repositories.\r\n * Usually used via UB.Repository fabric function.\r\n *\r\n * Do not use it directly, use UB.Repository instead.\r\n */\r\nclass CustomRepository {\r\n  /**\r\n   * @param {String} entityName name of Entity we create for\r\n   */\r\n  constructor (entityName) {\r\n    /**\r\n     * @private\r\n     * @type {Array}\r\n     */\r\n    this.fieldList = []\r\n    /**\r\n     * @private\r\n     * @type {Array}\r\n     */\r\n    this.groupList = []\r\n    /**\r\n     * @private\r\n     * @type {{}}\r\n     */\r\n    this.whereList = {}\r\n    /**\r\n     * @private\r\n     * @type {Array}\r\n     */\r\n    this.logicalPredicates = []\r\n    /**\r\n     * @private\r\n     * @type {Array}\r\n     */\r\n    this.joinAs = []\r\n    /**\r\n     * @private\r\n     * @type {Array}\r\n     */\r\n    this.orderList = []\r\n    /**\r\n     * @type {{}}\r\n     */\r\n    this.options = {}\r\n\r\n    /**\r\n     * Name of entity method used for data retrieve. Default is 'select'. The correct way to set method is `.using('mySelect')`\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    this.method = 'select'\r\n\r\n    /**\r\n     * Retrieved data description for server log in GUI mode. Default is ''.\r\n     * @property {string} __description\r\n     * @private\r\n     */\r\n    this.__description = ''\r\n\r\n    /**\r\n     * Miscellaneous options\r\n     * @property {Object} __misc\r\n     * @private\r\n     */\r\n    this.__misc = {}\r\n\r\n    this.entityName = entityName\r\n  }\r\n  /**\r\n   * Retrieve a data from server using `methodName` entity method.\r\n   * By default `select` method will be used.\r\n   * @param {string} methodName\r\n   */\r\n  using (methodName) {\r\n    this.method = methodName\r\n    return this\r\n  }\r\n\r\n    /**\r\n     * Add fields to collection.\r\n     * Can take one attribute name as string or array of attributes.\r\n     * Duplicate is not checked and in case of duplicate attribute caller got server error.\r\n     *\r\n     *      UB.Repository('tri_srf_reg').attrs('ID').attrs(['code', 'name']).attrs('fullName', 'newCode');\r\n     *\r\n     * Can take expression as a field. In this case entity attribute name must be wrapped into [] brackets.\r\n     * In case of client-side execution the only valid expression is one of:\r\n     *\r\n     * - **'SUM', 'COUNT', 'AVG', 'MAX', 'MIN', 'CAST', 'COALESCE'**\r\n     *\r\n     * Example:\r\n     *\r\n     *      UB.Repository('tri_srf_reg').attrs('SUM([payment])').where('documentID', '=', value); //will calculate sum of document payments\r\n     *\r\n     * If case of server-side execution any valid SQL expression is accepted:\r\n     *\r\n     *      UB.Repository('uba_user').attrs('[ID] / 100 + 1').selectAsArray()\r\n     *\r\n     * @param {String|Array} attr\r\n     * @return {CustomRepository}\r\n     */\r\n  attrs (attr) {\r\n    let fields = _.flatten(Array.prototype.slice.call(arguments))\r\n    this.fieldList = this.fieldList.concat(fields)\r\n    return this\r\n  }\r\n\r\n    /**\r\n     * Add where expression. Fix some known issues:\r\n     *\r\n     *  - if attribute name without brackets is passed to expression parameter then wrap attribute to brackets \"ID\" -> \"[ID]\"\r\n     *\r\n     *  - transform some dummy expressions to more simple form: `in ['one']` -> `equal 'one', `in []` -> `0=1`, `? null` -> `isNull` e.t.c.\r\n     *\r\n     *  - expression may contains this functions: 'SUM', 'COUNT', 'AVG', 'MAX', 'MIN', 'CAST', 'COALESCE',\r\n     *    'LENGTH', 'LOWER', 'UPPER', 'DAY', 'MONTH', 'YEAR', 'ROUND', 'FLOOR', 'CEILING'\r\n     *\r\n     *\r\n     * `In` and 'notIn` conditions can take a sub-repository as a values parameter value. See CustomRepository.exists for a conplex example\r\n     *\r\n     * @example\r\n     *        UB.Repository('my_entity').attrs('id')\r\n     *           .where('code', 'in', ['1', '2', '3'])  // code in ('1', '2', '3')\r\n     *           .where('code', 'in', UB.Repository('my_codes').attr('code').where('ID', '<', 10)  // code in (select code from my_codes where id = 10)\r\n     *           .where('[name]', 'contains', 'Homer'). // name like '%homer%'\r\n     *           .where('[birtday]', 'geq', new Date()).where('birtday', 'leq', new Date() + 10) //(birtday >= '2012-01-01') AND (birtday <= '2012-01-02')\r\n     *           .where('[age] -10', '>=', {age: 15}, 'byAge') // (age + 10 >= 15)\r\n     *           .where('LENGTH([code]), '<', 5)\r\n     *           .where('', 'match', 'myvalue') // for condition match expression not need\r\n     *\r\n     * @param {String} expression   Attribute name (with or without []) or valid expression with attributes in [].\r\n     * @param {WhereCondition|String} condition    Any value from WhereCondition list.\r\n     * @param {*} [values]          Condition value. In case expression is complex can take {Object} as value.\r\n     *                              In case values === undefined no values property passed to where list\r\n     * @param {String} [clauseName] Optional clause name to be used in {CustomRepository.logicalPredicates}. If not passed where will generate unique clause named 'c1', 'c2', ......\r\n     * @return {CustomRepository}\r\n     */\r\n  where (expression, condition, values, clauseName) {\r\n    let subQueryType\r\n    if (!clauseName) { // generate unique clause name\r\n      clauseName = 'c' + Object.keys(this.whereList).length + 1\r\n      while (this.whereList[clauseName]) {\r\n        clauseName += '_'\r\n      }\r\n    }\r\n    let originalCondition = condition\r\n    const WhereCondition = CustomRepository.prototype.WhereCondition\r\n    condition = WhereCondition[condition]\r\n    if (expression && condition !== 'custom' && !bracketsRe.test(expression)) {\r\n      expression = '[' + expression + ']'\r\n    }\r\n    if (!condition) {\r\n      throw new Error('Unknown conditions')\r\n    }\r\n    if (((condition === 'in') || (condition === 'notIn')) && (values instanceof CustomRepository)) { // subquery\r\n      subQueryType = condition // remember sub-query type\r\n      condition = 'subquery'\r\n      values = values.ubql() // get a subquery definition from a sub-repository\r\n    } else if (condition === 'subquery') {\r\n      subQueryType = originalCondition\r\n      if (values instanceof CustomRepository) {\r\n        values = values.ubql() // get a subquery definition from a sub-repository\r\n      }\r\n    } else if (condition === 'in' && (!Array.isArray(values))) {\r\n      console.debug('Condition \"in\" is passed to CustomRepository.where but values is not an array -> condition transformed to equal. Check your logic')\r\n      condition = WhereCondition.equal\r\n    } else if (condition === 'in' && (!values || !values.length)) {\r\n      console.warn('Condition \"in\" is passed to CustomRepository.where but value is empty array -> condition transformed to \"0=1\". Check your logic')\r\n      expression = '0'\r\n      condition = WhereCondition.equal\r\n      values = {a: 1}\r\n    } else if (condition === 'notIn' && (!values || !values.length)) {\r\n      console.warn('Condition \"notIn\" is passed to CustomRepository.where but value is empty array -> condition transformed to \"1=1\". Check your logic')\r\n      expression = '1'\r\n      condition = WhereCondition.equal\r\n      values = {a: 1}\r\n    } else if (values === null && (condition !== 'isNull' || condition !== 'notIsNull')) {\r\n      let wrongCondition = condition\r\n      values = undefined\r\n      condition = conditionInCaseValueIsNull[wrongCondition]\r\n      if (condition) {\r\n        console.warn('Condition ' + wrongCondition + 'is passed to CustomRepository.where but value is null -> condition transformed to ' + condition + '. Check your logic')\r\n      } else {\r\n        throw new Error('Condition ' + wrongCondition + 'is passed to CustomRepository.where but value is null')\r\n      }\r\n    }\r\n    if (condition === 'in' && (values.length === 1)) {\r\n      // console.warn('Condition \"in\" is passed to CustomRepository.where but value is an array on ONE item -> condition transformed to \"equal\". Check your logic')\r\n      condition = WhereCondition.equal\r\n      values = values[0]\r\n    }\r\n    if (values !== undefined && (typeof (values) !== 'object' || Array.isArray(values) || _.isDate(values))) {\r\n      let obj = {}\r\n      obj[clauseName] = values\r\n      values = obj\r\n    }\r\n    let whereItem = {\r\n      expression: expression,\r\n      condition: condition\r\n    }\r\n    if (condition === 'subquery') {\r\n      whereItem.subQueryType = subQueryType\r\n    }\r\n    if (values !== undefined) {\r\n      whereItem.values = values\r\n    }\r\n    this.whereList[clauseName] = whereItem\r\n    return this\r\n  }\r\n\r\n    /**\r\n     *  Add an expression with `EXISTS` sub-query. Inside a sub-query there is two macro:\r\n     *\r\n     *  - {master} will be replaced by master entity alias\r\n     *  - {self}  will be replaced by sub-query entity alias\r\n     *\r\n     *      //select users\r\n     *      UB.Repository('uba_user').attrs(['ID', 'name'])\r\n     *        // who are not disabled\r\n     *        .where('disabled', '=', 0)\r\n     *        // which allowed access from Kiev\r\n     *        .where('trustedIP', 'in',\r\n     *          UB.Repository('geo_ip').attrs('IPAddr')\r\n     *            .where('city', '=', 'Kiev')\r\n     *        )\r\n     *        // who do not login during this year\r\n     *        .notExists(\r\n     *          UB.Repository('uba_audit')\r\n     *            .correlation('actionUser', 'name')  // here we link to uba_user.name\r\n     *            .where('actionTime', '>', new Date(2016, 1, 1))\r\n     *            .where('actionType', '=', 'LOGIN')\r\n     *        )\r\n     *        // but modify some data\r\n     *        .exists(\r\n     *          UB.Repository('uba_auditTrail')\r\n     *            .correlation('actionUser', 'ID') // here we link to uba_user.ID\r\n     *            .where('actionTime', '>', new Date(2016, 1, 1))\r\n     *        )\r\n     *        .select()\r\n     *\r\n     * @param {CustomRepository} subRepository  Repository, what represent a sub-query to be execute inside EXISTS statement\r\n     * @param {String} [clauseName] Optional clause name\r\n     * @return {CustomRepository}\r\n     */\r\n  exists (subRepository, clauseName) {\r\n    return this.where('', 'exists', subRepository, clauseName)\r\n  }\r\n\r\n    /**\r\n     * Add an expression with `NOT EXISTS` sub-query. See CustomRepository.exists for sample\r\n     *\r\n     * @param {CustomRepository} subRepository  Repository, what represent a sub-query to be execute inside EXISTS statement\r\n     * @param {String} [clauseName] Optional clause name\r\n     * @return {CustomRepository}\r\n     */\r\n  notExists (subRepository, clauseName) {\r\n    return this.where('', 'notExists', subRepository, clauseName)\r\n  }\r\n\r\n    /**\r\n     * If current repository are used as a sub-query for `exists`, `notExists`, `in` or `notIn` conditions\r\n     * will add a [correlation](https://en.wikipedia.org/wiki/Correlated_subquery) with a master repository\r\n     *\r\n     *\r\n     * @param {String} subQueryAttribute\r\n     * @param {String} masterAttribute\r\n     * @param {WhereCondition|String} [condition=eq] A subset from WhereCondition list applicable for correlation join\r\n     * @param {String} [clauseName] Optional clause name to be used in {CustomRepository.logicalPredicates}. If not passed where will generate unique clause named 'c1', 'c2', ......\r\n     * @return {CustomRepository}\r\n     */\r\n  correlation (subQueryAttribute, masterAttribute, condition, clauseName) {\r\n    if (!bracketsRe.test(subQueryAttribute)) {\r\n      subQueryAttribute = '[' + subQueryAttribute + ']'\r\n    }\r\n    if (!condition) condition = '='\r\n    return this.where(subQueryAttribute + condition + '[{master}.' + masterAttribute + ']', 'custom', undefined, clauseName)\r\n  }\r\n    /**\r\n     * Arrange where expressions in logical order. By default where expressions is joined by AND logical predicate. Here is possible to  join it in custom order.\r\n     *\r\n     *      UB.Repository('my_entity').attrs('id')\r\n     *          .where('code', 'in', ['1', '2', '3'], 'byCode')  // code in ('1', '2', '3')\r\n     *          .where('name', 'contains', 'Homer', 'byName') // name like '%homer%'\r\n     *          .where('birtday', 'geq', new Date()).where('birtday', 'leq', new Date() + 10) //(birtday >= '2012-01-01') AND (birtday <= '2012-01-02')\r\n     *          .where('[age] -10', '>=', {age: 15}, 'byAge') // (age + 10 >= 15)\r\n     *          .logic('(([byCode]) OR ([byName]))') // (byCode OR byName) AND (all where items, not included in logic)\r\n     *\r\n     * @param {String} predicate logical predicate.\r\n     * @return {CustomRepository}\r\n     */\r\n  logic (predicate) {\r\n    this.logicalPredicates.push(predicate)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Force where expressions to be used in join SQL statement instead of where. Applicable only for not cached entities.\r\n   *\r\n   *      // will generate\r\n   *      // SELECT A.ID, B.code FROM tst_document A LEFT JOIN tst_category B ON (B.instanceID = A.ID and B.ubUser = 10)\r\n   *      // instead of\r\n   *      // SELECT A.ID, B.code FROM tst_document A LEFT JOIN tst_category B ON B.instanceID = A.ID WHERE B.ubUser = 10\r\n   *      UB.Repository('tst_document').attrs(['ID', '[caregory.code]'])\r\n   *          .where('[caregory.ubUser]', '=', 10, 'wantInJoin')\r\n   *          .join('wantInJoin')\r\n   *          .selectAsObject().done(UB.logDebug);\r\n   *\r\n   * @param {String} whereItemName name of where item to use in join.\r\n   * @return {CustomRepository}\r\n   */\r\n  join (whereItemName) {\r\n    this.joinAs.push(whereItemName)\r\n    return this\r\n  }\r\n\r\n    /**\r\n     * Add join condition. Fix some known issues\r\n     *\r\n     * @param {String} expression   Attribute name (with or without []) or valid expression with attributes in [].\r\n     * @param {WhereCondition} condition    Any value from WhereCondition list.\r\n     * @param {*} [values]          Condition value. In case expression is complex can take {Object} as value.\r\n     *                              In case values === undefined no values property passed to where list\r\n     * @param {String} [clauseName] Optional clause name to be used in {CustomRepository.logicalPredicates}. If not passed where will generate unique clause named 'c1', 'c2', ......\r\n     * @return {CustomRepository}\r\n     */\r\n  joinCondition (expression, condition, values, clauseName) {\r\n    if (!clauseName) { // generate unique clause name\r\n      clauseName = 'c' + Object.keys(this.whereList).length + 1\r\n      while (this.whereList[clauseName]) {\r\n        clauseName += '_'\r\n      }\r\n    }\r\n    this.where(expression, condition, values, clauseName)\r\n    this.joinAs.push(clauseName)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Add sorting\r\n   *\r\n   *      UB.CustomRepository('my_entity').attrs('ID').orderBy('code')\r\n   *\r\n   * @param attr      Sorted attribute\r\n   * @param [direction='asc'] Sort direction ('asc'|'desc')\r\n   * @return {CustomRepository}\r\n   */\r\n  orderBy (attr, direction) {\r\n    direction = direction || 'asc'\r\n    this.orderList.push({\r\n      expression: attr,\r\n      order: direction\r\n    })\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Add desc sorting. The same as orderBy(attr, 'desc')\r\n   *\r\n   *      UB.Repository('my_entity').attrs('ID').orderBy('code').orderByDesc('date_create') // ORDER BY code, date_create DESC\r\n   *\r\n   * @param {String} attr\r\n   * @return {CustomRepository}\r\n   */\r\n  orderByDesc (attr) {\r\n    this.orderList.push({\r\n      expression: attr,\r\n      order: 'desc'\r\n    })\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Add grouping\r\n   * Can take one attribute name as string or array of attributes name\r\n   *\r\n   *      UB.Repository('my_entity').attrs('ID').groupBy('code')\r\n   *      UB.Repository('uba_user').attrs('disabled').groupBy('disabled').select()\r\n   *      UB.Repository('uba_user').attrs(['disabled','uPassword','COUNT([ID])']).groupBy(['disabled','uPassword']).select()\r\n   *\r\n   * @param attr  Grouped attribute\r\n   * @return {CustomRepository}\r\n   */\r\n  groupBy (attr) {\r\n    if (_.isArray(attr)) {\r\n      this.groupList = this.groupList.concat(attr)\r\n    } else if (_.isString(attr)) {\r\n      this.groupList.push(attr)\r\n    }\r\n    return this\r\n  }\r\n\r\n    /**\r\n     * Add options.start value to retrieve first `start` rows\r\n     *\r\n     *      var store = UB.Repository('my_entity').attrs('id').start(15).limit(10).select() //will return ID's from 15 to 25\r\n     *\r\n     * @param {Number} start\r\n     * @return {CustomRepository}\r\n     */\r\n  start (start) {\r\n    this.options.start = start\r\n    return this\r\n  }\r\n\r\n   /**\r\n   * Add options.limit value. Can be combined with start.\r\n   *\r\n      // will return first two ID's from my_entity\r\n      var store = UB.Repository('my_entity').attrs('id').limit(2).select()\r\n   *\r\n   * @param {number} rowsLimit\r\n   * @return {CustomRepository}\r\n   */\r\n  limit (rowsLimit) {\r\n    this.options.limit = rowsLimit\r\n    return this\r\n  }\r\n\r\n    /**\r\n     * For debug purpose only.\r\n     *\r\n     * If set, in GUI mode will put this description into log before query execution\r\n     *\r\n     *      var store = UB.Repository('my_entity').attrs('ID').describe('Select all record for \"my_entity\"').select()\r\n     *\r\n     * @param {String} value\r\n     * @return {CustomRepository}\r\n     */\r\n  describe (value) {\r\n    this.__description = value\r\n    return this\r\n  }\r\n\r\n    /**\r\n     * Construct a UBQL JSON request. Used in {@link CustomRepository#select}\r\n     *\r\n     *       var repo = UB.Repository('my_entity').attrs('ID').where('code', '=', 'a')\r\n     *       var inst = new TubDataStore(my_entity);\r\n     *       inst.run('select', repo.ubql());\r\n     *\r\n     * @return {Object}\r\n     */\r\n  ubql () {\r\n    let orderCnt = this.orderList.length\r\n    let req = {\r\n      entity: this.entityName,\r\n      method: this.method,\r\n      fieldList: this.fieldList\r\n    }\r\n    if (this.groupList.length > 0) {\r\n      req.groupList = this.groupList\r\n    }\r\n    if (Object.keys(this.whereList).length) {\r\n      req.whereList = this.whereList\r\n    }\r\n    if (orderCnt > 0) {\r\n      req.orderList = {}\r\n      for (let i = 0; i < orderCnt; i++) {\r\n        req.orderList[i] = this.orderList[i]\r\n      }\r\n    }\r\n    if (Object.keys(this.options).length) { // .limit || .start .totalRequired\r\n      req.options = this.options\r\n    }\r\n    if (this.logicalPredicates.length) {\r\n      req.logicalPredicates = this.logicalPredicates\r\n    }\r\n    if (this.joinAs.length) {\r\n      req.joinAs = this.joinAs\r\n    }\r\n    _.defaults(req, this.__misc) // apply misc\r\n\r\n    return req\r\n  }\r\n\r\n    /**\r\n     * Must be implemented in descendants and return (or resolved for async clients)\r\n     * to `array of object` representation of result, like this\r\n     *\r\n     *      [{\"ID\":3000000000004,\"code\":\"uba_user\"},{\"ID\":3000000000039,\"code\":\"uba_auditTrail\"}]\r\n     *\r\n     * @abstract\r\n     */\r\n  selectAsObject () {\r\n    throw new Error('abstract')\r\n  }\r\n    /**\r\n     * Must be implemented in descendants and return (or resolved for async clients)\r\n     * to `array of array` representation of result, like this\r\n     *\r\n     *      {\"resultData\":{\"fields\":[\"ID\",\"name\",\"ID.name\"],\"rowCount\":1,\"data\":[[10,\"admin\",\"admin\"]]},\"total\":1,\"__totalRecCount\": totolRecCountIfWithTotalRequest}\r\n     *\r\n     * @abstract\r\n     */\r\n  selectAsArray () {\r\n    throw new Error('abstract')\r\n  }\r\n\r\n    /**\r\n     * Must be implemented in descendants and return (or resolved for async clients)\r\n     * to `DataSet` class instance, implemented in caller level. It can be:\r\n     *\r\n     *  - {TubDataStore} for in-server context\r\n     *  - {UB.ux.data.UBStore} for UnityBase `adminUI` client\r\n     *  - `array of array` data representation for UnityBase remote connection\r\n     *  - etc.\r\n     *\r\n     * @abstract\r\n     * @param [storeConfig]\r\n     */\r\n  selectAsStore (storeConfig) {\r\n    throw new Error('abstract')\r\n  }\r\n\r\n    /**\r\n     * Must be implemented in descendants as a alias to the most appropriate method\r\n     *\r\n     * @abstract\r\n     * @param [storeConfig]\r\n     */\r\n  select (storeConfig) {\r\n    throw new Error('abstract')\r\n  }\r\n\r\n    /**\r\n     * Select a single row. If ubql result is empty - return {undefined}.\r\n     *\r\n     * WARNING method do not check repository contains the single row and always return a first row from result.\r\n     * @abstract\r\n     * @return {Object|undefined}\r\n     */\r\n  selectSingle () {\r\n    throw new Error('abstract')\r\n  }\r\n\r\n    /**\r\n     * Perform select and return a value of the first attribute from the first row\r\n     *\r\n     * WARNING method do not check repository contains the single row\r\n     * @abstract\r\n     * @return {Object|undefined}\r\n     */\r\n  selectScalar () {\r\n    throw new Error('abstract')\r\n  }\r\n\r\n    /**\r\n     * Select a single row by ID. If ubql result is empty - return {undefined}.\r\n     *\r\n     * @abstract\r\n     * @param {Number} ID Row identifier\r\n     * @return {Object|undefined}\r\n     */\r\n  selectById (ID) {\r\n    throw new Error('abstract')\r\n  }\r\n\r\n    /**\r\n     * Apply miscellaneous options to resulting ubRequest:\r\n     *\r\n     *          // this server-side call will select all currency, including deleted\r\n     *          UB.Repository('cdn_currency').attrs(['ID']).misc({__allowSelectSafeDeleted: true}).selectAsArray();\r\n     *\r\n     * @param {Object} flags\r\n     * @param {Date} [flags.__mip_ondate] Specify date on which to select data for entities with `dataHistory` mixin. Default to Now()\r\n     * @param {Boolean} [flags.__mip_recordhistory=false] Select only record history data for specified ID (for entities with `dataHistory` mixin)\r\n     * @param {Boolean} [flags.__mip_recordhistory_all=false] Ignore __mip_ondate and select all data (acts as select for entities without `dataHistory` mixin)\r\n     * @param {Boolean} [flags.__mip_disablecache=false] For entities with cacheType in [\"Session\", \"SessionEntity\"] not check is data modified and always return result\r\n     * @param {Boolean} [flags.__skipOptimisticLock=false] Skip optimistic lock for entities with `mStorage.simpleAudit = true`\r\n     * @param {Boolean} [flags.__allowSelectSafeDeleted=false] **Server-side only.**\r\n     * @param {Boolean} [flags.__skipSelectAfterUpdate=false] **Server-side only.**\r\n     * @param {Boolean} [flags.__skipSelectAfterInsert=false] **Server-side only.**\r\n     * @param {Boolean} [flags.__skipRls=false] **Server-side only.**\r\n     * @param {Boolean} [flags.__skipAclRls=false] **Server-side only.**\r\n     *\r\n     * @return {CustomRepository}\r\n     */\r\n  misc (flags) {\r\n    _.assign(this.__misc, flags)\r\n    return this\r\n  }\r\n\r\n    /**\r\n     * Calculate total row number. WARNING!! This is VERY slow operation on DB level in case of many record\r\n     *\r\n     * Result of calculation is returned in __totalRecCount parameter value in case `selectAsArray()` client call:\r\n     *\r\n     *          var result = UB.Repository('uba_user').attrs(['ID', 'description']).withTotal().selectAsArray();\r\n                console.log('Total count is:', result.__totalRecCount)\r\n     *\r\n     * Or into TubDataStore.totalRowCount in case of server side `selectAsStore()` call:\r\n     *\r\n     *          var store = UB.Repository('uba_user').attrs(['ID', 'description']).withTotal().selectAsStore();\r\n                console.log('Total count is:', store.totalRowCount);\r\n     *\r\n     * @return {CustomRepository}\r\n     */\r\n  withTotal () {\r\n    this.options.totalRequired = true\r\n    return this\r\n  }\r\n}\r\n\r\n/**\r\n * Alias to {@link CustomRepository#ubql CustomRepository.ubql}\r\n * @memberOf CustomRepository\r\n * @private\r\n * @deprecated Will be removed in UB 2.0. Use .ubql() instead\r\n */\r\nCustomRepository.prototype.getRunListItem = CustomRepository.prototype.ubql\r\n/**\r\n * Alias to {@link CustomRepository#ubql CustomRepository.ubRequest}\r\n * @memberOf CustomRepository\r\n * @protected\r\n * @deprecated Will be removed in UB 2.0. Use .ubql() instead\r\n */\r\nCustomRepository.prototype.ubRequest = CustomRepository.prototype.ubql\r\n\r\n/**\r\n * Enumeration of all condition types. This enumeration defines a set of String values.\r\n * It exists primarily for documentation purposes - in code use the actual string values like '>', don't reference them through this class like WhereCondition.more.\r\n *\r\n * We define several aliases for the same condition. In case of direct HTTP request (without Repository) use only non-aliased values (i.e. `more` instead of '>' or 'gt')\r\n * @memberOf CustomRepository\r\n * @enum {string}\r\n */\r\nCustomRepository.prototype.WhereCondition = {\r\n  'gt': 'more', /** @property {string} gt Alias for `more` */\r\n  '>': 'more',  /** @property {string} _greaterThan This is actually **>** sign - we can't pout it into documentation. Alias for `more` */\r\n  'more': 'more', /** @property {string} more Greater than */\r\n\r\n  'lt': 'less', /** @property {string} lt Alias for `less` */\r\n  '<': 'less', /** @property {string} _lessThan (actually **<** sign). Alias for `less` */\r\n  'less': 'less', /** @property {string} less Less than */\r\n\r\n  'eq': 'equal', /** @property {string} eq Alias for `equal` */\r\n  '=': 'equal', /** @property {string} _eq (actually **=** sign). Alias for `equal` */\r\n  'equal': 'equal', /** @property {string} equal Equal to */\r\n\r\n  'ge': 'moreEqual', /** @property {string} geq Alias for `moreEqual` */\r\n  'geq': 'moreEqual', /** @property {string} geq Alias for `moreEqual` */\r\n  '>=': 'moreEqual', /** @property {string} _geq (actually **>=** sign). Alias for `moreEqual` */\r\n  'moreEqual': 'moreEqual', /** @property {string} moreEqual Greater than or equal */\r\n\r\n  'le': 'lessEqual', /** @property {string} leq Alias for `lessEqual` */\r\n  'leq': 'lessEqual', /** @property {string} leq Alias for `lessEqual` */\r\n  '<=': 'lessEqual', /** @property {string} _leq (actually **<=** sign). Alias for `lessEqual` */\r\n  'lessEqual': 'lessEqual', /** @property {string} lessEqual Less than or equal */\r\n\r\n  'ne': 'notEqual', /** @property {string} neq Alias for `notEqual` */\r\n  'neq': 'notEqual', /** @property {string} neq Alias for `notEqual` */\r\n  '<>': 'notEqual', /** @property {string} _neq1 (actually **<>** sign). Alias for `notEqual` */\r\n  '!=': 'notEqual', /** @property {string} _neq2 (actually **!=** sign). Alias for `notEqual` */\r\n  '!==': 'notEqual', /** @property {string} _neq3 (actually **!==** sign). Alias for `notEqual` */\r\n  'notEqual': 'notEqual', /** @property {string} notEqual Not equal */\r\n\r\n  'contains': 'like', /** @property {string} contains Alias for `like` */\r\n  'like': 'like', /** @property {string} like Like condition. For `String` type attribute only */\r\n\r\n  'notContains': 'notLike', /** @property {string} notContains Alias for `notLike` */\r\n  'notLike': 'notLike', /** @property {string} notLike Not like condition. For `String` type attribute only */\r\n\r\n  'isNull': 'isNull', /** @property {string} isNull Is null */\r\n  'null': 'isNull', /** @property {string} null Alias for `isNull` */\r\n\r\n  'notNull': 'notIsNull', /** @property {string} notNull Alias for `notIsNull` */\r\n  'notIsNull': 'notIsNull', /** @property {string} notIsNull Not is null */\r\n  'isNotNull': 'notIsNull', /** @property {string} isNotNull Alias for `notIsNull` */\r\n\r\n  'beginWith': 'startWith', /** @property {string} beginWith Alias for `startWith` */\r\n  'startWith': 'startWith', /** @property {string} startWith Start with. For `String` type attribute only */\r\n  'startsWith': 'startWith', /** @property {string} startsWith Alias for `startWith` */\r\n  'startswith': 'startWith', /** @property {string} startwith Alias for `startWith` */\r\n\r\n  'notBeginWith': 'notStartWith', /** @property {string} notBeginWith Alias for `notStartWith` */\r\n  'notStartWith': 'notStartWith', /** @property {string} notStartWith Not start with. For `String` type attribute only */\r\n  'notStartsWith': 'notStartWith', /** @property {string} notStartWith Alias for `notStartWith` */\r\n\r\n  'includes': 'in', /** @property {string} includes Alias for `in` */\r\n  'in': 'in', /** @property {string} in One of. Can accept array of string on array of Int/Int64 as values depending on attribute type. */\r\n\r\n  'notIncludes': 'notIn', /** @property {string} notIncludes Alias for `notIn` */\r\n  'notIn': 'notIn', /** @property {string} notIn Not one of. See WhereCondition.in for details */\r\n\r\n  'match': 'match', /** @property {string} match For entities with FTS mixin enabled. TODO - expand */\r\n\r\n  'subquery': 'subquery', /** @property {string} subquery Execute a sub-query passed in values. Better to use 'in' condition with Repository as a values parameter or a CustomRepository.exists method */\r\n  'exists': 'subquery', /** @property {string} exists Execute a exists(sub-query) passed in values. Better to use CustomRepository.exists method */\r\n  'notExists': 'subquery', /** @property {string} exists Execute a not exists(sub-query) passed in values. Better to use CustomRepository.notExists method */\r\n\r\n  'custom': 'custom' /** @property {string} custom Custom condition. For Server-side call only. For this condition `expression` can be any SQL statement */\r\n}\r\n\r\n/**\r\n * Abstract Custom repository (extended by serverRepository & ClientRepository)\r\n * @type {CustomRepository}\r\n */\r\nmodule.exports = CustomRepository\r\n\n\n\n// WEBPACK FOOTER //\n// ./../base/CustomRepository.js","/**\r\n * UnityBase domain object model.\r\n * The main class {@link UBDomain}:\r\n *\r\n *  - for the server & CLI it is a result of {@link UBConnection.getDomainInfo connection.getDomainInfo} call\r\n *  - for browser side instance of UBDomain is a `domain` property of connection object\r\n *\r\n * Information about domain is used in many aspects of UnityBase:\r\n *\r\n *  - database generation\r\n *  - documentation generation\r\n *  - forms genetarion\r\n *  - views generation etc.\r\n *\r\n * @module @unitybase/base/UBDomain\r\n */\r\n\r\nconst _ = require('lodash')\r\n\r\n/**\r\n * Database connection config (w/o credential)\r\n * @typedef {Object} DBConnectionConfig\r\n * @property {string} name\r\n * @property {string} dialect\r\n * @property {Array<string>} supportLang\r\n * @property {string} advSettings database specific settings\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * UnityBase domain object model.\r\n * Construct new UBDomain instance based on getDomainInfo UB server method result\r\n *\r\n * Usage sample:\r\n *\r\n *     // retrieve a localized caption of uba_user.name attribute\r\n *     domain.get('uba_user').attr('name').caption\r\n *\r\n * @class\r\n * @param {Object} domainInfo getDomainInfo UB server method result\r\n * @param {Object} domainInfo.domain raw entities collection\r\n * @param {Object} domainInfo.entityMethods entities methods access rights for current user\r\n * @param {Object} domainInfo.models information about domain models\r\n * @param {Object} domainInfo.i18n entities localization to current user language\r\n * @param {Object} domainInfo.forceMIMEConvertors list of registered server-side MIME converters for document type attribute content\r\n */\r\nfunction UBDomain (domainInfo) {\r\n  let me = this\r\n  let entityCodes = Object.keys(domainInfo.domain)\r\n  let isV4API = (typeof domainInfo.entityMethods === 'undefined')\r\n    /**\r\n     * Hash of entities. Keys is entity name, value is UBEntity\r\n     * @type {Object<String, UBEntity>}\r\n     */\r\n  this.entities = {}\r\n  /**\r\n   * Connection collection (for extended domain info only).\r\n   * @type {Array<DBConnectionConfig>}\r\n   */\r\n  this.connections = domainInfo['connections']\r\n  entityCodes.forEach(function (entityCode) {\r\n    if (isV4API) {\r\n      let entity = domainInfo.domain[entityCode]\r\n      me.entities[entityCode] = new UBEntity(\r\n                entity,\r\n                entity.entityMethods || {},\r\n                entity.i18n,\r\n                entityCode,\r\n                me\r\n            )\r\n    } else {\r\n      me.entities[entityCode] = new UBEntity(\r\n                domainInfo.domain[entityCode],\r\n                domainInfo.entityMethods[entityCode] || {},\r\n                domainInfo.i18n[entityCode],\r\n                entityCode,\r\n                me\r\n            )\r\n    }\r\n  })\r\n\r\n    /**\r\n     * Models collection\r\n     * @type {Object<String, UBModel>}\r\n     */\r\n  this.models = {}\r\n  let modelCodes = Object.keys(domainInfo.models)\r\n  modelCodes.forEach(function (modelCode) {\r\n    let m = domainInfo.models[modelCode]\r\n    me.models[modelCode] = new UBModel(m.path, m.needInit, m.needLocalize, m.order)\r\n  })\r\n\r\n    /**\r\n     *\r\n     * @type {Object}\r\n     * @readonly\r\n     */\r\n  this.forceMIMEConvertors = domainInfo.forceMIMEConvertors\r\n}\r\n\r\n/**\r\n * Check all provided entity methods are accessible via RLS.\r\n *\r\n * If entity does not exist in domain or at last one of provided methods is not accessible - return false\r\n *\r\n * @param {String} entityCode\r\n * @param {String|Array} methodNames\r\n */\r\nUBDomain.prototype.isEntityMethodsAccessible = function (entityCode, methodNames) {\r\n  let entity = this.entities[entityCode]\r\n  if (!entity) return false\r\n  return Array.isArray(methodNames) ? entity.haveAccessToMethods(methodNames) : entity.haveAccessToMethod(methodNames)\r\n}\r\n/**\r\n * Get entity by code\r\n * @param {String} entityCode\r\n * @param {Boolean} [raiseErrorIfNotExists=true] If `true`(default) and entity does not exists throw error\r\n * @returns {UBEntity}\r\n */\r\nUBDomain.prototype.get = function (entityCode, raiseErrorIfNotExists) {\r\n  let result = this.entities[entityCode]\r\n  if ((raiseErrorIfNotExists !== false) && !result) {\r\n    throw new Error('Entity with code \"' + entityCode + '\" does not exists or not accessible')\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * Check entity present in domain & user has access right for at least one entity method\r\n * @param {String} entityCode\r\n * @returns {Boolean}\r\n */\r\nUBDomain.prototype.has = function (entityCode) {\r\n  return !!this.entities[entityCode]\r\n}\r\n\r\n/**\r\n * Iterates over domain entities and invokes `callBack` for each entity.\r\n * The iteratee is invoked with three arguments: (UBEntity, entityName, UBDomain.entities)\r\n * @param {Function} callBack\r\n */\r\nUBDomain.prototype.eachEntity = function (callBack) {\r\n  return _.forEach(this.entities, callBack)\r\n}\r\n\r\n/**\r\n * Filter entities by properties\r\n * @example\r\n *\r\n *      // sessionCachedEntites contains all entities with property cacheType equal Session\r\n *      var sessionCachedEntites = domain.filterEntities({cacheType: 'Session'});\r\n *\r\n * @param {Object|Function} config\r\n * @returns {Array}\r\n */\r\nUBDomain.prototype.filterEntities = function (config) {\r\n  if (_.isFunction(config)) {\r\n    return _.filter(this.entities, config)\r\n  } else {\r\n    return _.filter(this.entities, function (item) {\r\n      let res = true\r\n      for (let prop in config) {\r\n        if (config.hasOwnProperty(prop)) {\r\n          res = res && (item[prop] === config[prop])\r\n        }\r\n      }\r\n      return res\r\n    })\r\n  }\r\n}\r\n\r\n/**\r\n * UnityBase base attribute data types\r\n * @readonly\r\n * @enum\r\n */\r\nUBDomain.ubDataTypes = {\r\n  /** Small string. MSSQL: NVARCHAR, ORACLE: NVARCHAR2, POSTGRE: VARCHAR */\r\n  String: 'String',\r\n  /** 32-bite Integer. MSSQL: INT, ORACLE: INTEGER, POSTGRE: INTEGER */\r\n  Int: 'Int',\r\n  /** 64-bite Integer. MSSQL: BIGINT, ORACLE: NUMBER(19), POSTGRE: BIGINT */\r\n  BigInt: 'BigInt',\r\n  /** Double. MSSQL: FLOAT, ORACLE: NUMBER(19, 4), POSTGRE: NUMERIC(19, 4) */\r\n  Float: 'Float',\r\n  /** Currency. MSSQL: FLOAT, ORACLE: NUMBER(19, 2), POSTGRE: NUMERIC(19, 2) */\r\n  Currency: 'Currency',\r\n  /** Boolean. MSSQL: TINYINT, ORACLE: NUMBER(1), POSTGRE: SMALLINT */\r\n  Boolean: 'Boolean',\r\n  /** Date + Time in UTC (GMT+0) timezone. MSSQL: DATETIME, OARCLE: DATE, POSTGRE: TIMESTAMP WITH TIME ZONE */\r\n  DateTime: 'DateTime',\r\n  /** Long strint. MSSQL: NVARCHAR(MAX), ORACLE: CLOB, POSTGRE: TEXT */\r\n  Text: 'Text',\r\n  /** Alias for BigInt */\r\n  ID: 'ID',\r\n  /** Reference to enother entity. BigInt */\r\n  Entity: 'Entity',\r\n  /** Store a JSON with information about Document place in blob store */\r\n  Document: 'Document',\r\n  Many: 'Many',\r\n  /**  Seconds since UNIX epoch, Int64. MSSQL: BIGINT, ORACLE: NUMBER(19), POSTGRE: BIGINT */\r\n  TimeLog: 'TimeLog',\r\n  /** Enumertion (see ubm_enum) */\r\n  Enum: 'Enum',\r\n  /** Bynary data. MSSQL: VARBINARY(MAX), ORACLE: BLOB, POSTGRE: BYTEA */\r\n  BLOB: 'BLOB',\r\n  /** Date (without time) in UTC (GMT+0) */\r\n  Date: 'Date'\r\n}\r\n\r\nUBDomain.prototype.ubDataTypes = UBDomain.ubDataTypes\r\n\r\n/**\r\n * Types of expressions in attribute mapping\r\n * @readonly\r\n * @enum\r\n */\r\nUBDomain.ExpressionType = {\r\n  Field: 'Field',\r\n  Expression: 'Expresion'\r\n}\r\n\r\n/**\r\n * UnityBase base mixins\r\n * @readonly\r\n * @enum\r\n */\r\nUBDomain.ubMixins = {\r\n  dataHistory: 'dataHistory',\r\n  mStorage: 'mStorage',\r\n  unity: 'unity',\r\n  treePath: 'treePath'\r\n}\r\n\r\n/**\r\n * Service attribute names\r\n * @readonly\r\n * @enum\r\n */\r\nUBDomain.ubServiceFields = {\r\n  dateFrom: 'mi_datefrom',\r\n  dateTo: 'mi_dateto'\r\n}\r\n\r\n/**\r\n * Entity dataSource types\r\n * @enum {String}\r\n * @readonly\r\n */\r\nUBDomain.EntityDataSourceType = {\r\n  Normal: 'Normal',\r\n  External: 'External',\r\n  System: 'System',\r\n  Virtual: 'Virtual'\r\n}\r\n\r\n/**\r\n * @enum\r\n */\r\nUBDomain.EntityCacheTypes = {\r\n  None: 'None',\r\n  Entity: 'Entity',\r\n  Session: 'Session',\r\n  SessionEntity: 'SessionEntity'\r\n}\r\n\r\n/**\r\n * Priority to apply a mapping of a attributes/entities to the physical tables depending of connection dialect\r\n */\r\nUBDomain.dialectsPriority = {\r\n  MSSQL2012: [ 'MSSQL2012', 'MSSQL', 'AnsiSQL' ],\r\n  MSSQL2008: [ 'MSSQL2008', 'MSSQL', 'AnsiSQL' ],\r\n  MSSQL: [ 'MSSQL', 'AnsiSQL' ],\r\n  Oracle11: [ 'Oracle11', 'Oracle', 'AnsiSQL' ],\r\n  Oracle10: [ 'Oracle10', 'Oracle', 'AnsiSQL' ],\r\n  Oracle9: [ 'Oracle9', 'Oracle', 'AnsiSQL' ],\r\n  Oracle: [ 'Oracle', 'AnsiSQL' ],\r\n  PostgreSQL: [ 'PostgreSQL', 'AnsiSQL' ],\r\n  AnsiSQL: [ 'AnsiSQL' ],\r\n  Firebird: [ 'Firebird', 'AnsiSQL' ],\r\n  SQLite3: [ 'SQLite3', 'AnsiSQL' ]\r\n}\r\n\r\n/**\r\n * Return physical type by UBDataType\r\n * @param {String} dataType\r\n * @return {String}\r\n */\r\nUBDomain.getPhysicalDataType = function (dataType) {\r\n  let ubDataTypes = UBDomain.ubDataTypes\r\n  let typeMap = {}\r\n\r\n  if (!this.physicalTypeMap) {\r\n    typeMap[ubDataTypes.Int] = 'int'\r\n    typeMap[ubDataTypes.Entity] = 'int'\r\n    typeMap[ubDataTypes.ID] = 'int'\r\n    typeMap[ubDataTypes.BigInt] = 'int'\r\n\r\n    typeMap[ubDataTypes.String] = 'string'\r\n    typeMap[ubDataTypes.Text] = 'string'\r\n    typeMap[ubDataTypes.Enum] = 'string'\r\n\r\n    typeMap[ubDataTypes.Float] = 'float'\r\n    typeMap[ubDataTypes.Currency] = 'float'\r\n\r\n    typeMap[ubDataTypes.Boolean] = 'boolean'\r\n\r\n    typeMap[ubDataTypes.Date] = 'date'\r\n    typeMap[ubDataTypes.DateTime] = 'date'\r\n\r\n    this.physicalTypeMap = typeMap\r\n  }\r\n  return this.physicalTypeMap[dataType] || 'auto'\r\n}\r\n\r\n/**\r\n * Model (logical group of entities)\r\n * @class\r\n * @param path\r\n * @param needInit\r\n * @param needLocalize\r\n * @param order\r\n */\r\nfunction UBModel (path, needInit, needLocalize, order) {\r\n  this.path = path\r\n  if (needInit) {\r\n    /**\r\n     * `initModel.js` script is available in the public folder (should be injected by client)\r\n     * @type {boolean}\r\n     */\r\n    this.needInit = needInit\r\n  }\r\n  if (needLocalize) {\r\n    /**\r\n     * `locale-Lang.js` script is available in the public folder (should be injected by client)\r\n     * @type {boolean}\r\n     */\r\n    this.needLocalize = needLocalize\r\n  }\r\n  /**\r\n   * An odred of model initialization (as it is provided in server domain config)\r\n   * @type {number}\r\n   */\r\n  this.order = order\r\n}\r\nUBModel.prototype.needInit = false\r\nUBModel.prototype.needLocalize = false\r\n\r\n/**\r\n * Collection of attributes\r\n * @class\r\n */\r\nfunction UBEntityAttributes () {}\r\n/**\r\n * Return a JSON representation of all entity attributes\r\n * @returns {{}}\r\n */\r\nUBEntityAttributes.prototype.asJSON = function () {\r\n  let result = {}\r\n  _.forEach(this, function (prop, propName) {\r\n    if (prop.asJSON) {\r\n      result[propName] = prop.asJSON()\r\n    } else {\r\n      result[propName] = prop\r\n    }\r\n  })\r\n  return result\r\n}\r\n\r\n/** @class */\r\nfunction UBEntityMapping (maping) {\r\n  /**\r\n   * @type {string}\r\n   */\r\n  this.selectName = maping.selectName || ''\r\n  /** @type {string} */\r\n  this.execName = maping.execName || this.selectName\r\n  /** @type {string} */\r\n  this.pkGenerator = maping.pkGenerator\r\n}\r\n\r\n/**\r\n * @class\r\n * @param {Object} entityInfo\r\n * @param {Object} entityMethods\r\n * @param {Object} i18n\r\n * @param {String} entityCode\r\n * @param {UBDomain} domain\r\n */\r\nfunction UBEntity (entityInfo, entityMethods, i18n, entityCode, domain) {\r\n  let me = this\r\n  let mixinNames, mixinInfo, i18nMixin, dialectProiority\r\n\r\n  if (i18n) {\r\n    _.merge(entityInfo, i18n)\r\n  }\r\n  /**\r\n   * @type {UBDomain}\r\n   * @readonly\r\n   */\r\n  this.domain = domain\r\n\r\n  /**\r\n   * @type {String}\r\n   * @readonly\r\n   */\r\n  this.code = entityCode\r\n  /**\r\n   * Entity model name\r\n   * @type{String}\r\n   * @readonly\r\n   */\r\n  this.modelName = entityInfo.modelName\r\n  /**\r\n   * Entity name\r\n   * @type {String}\r\n   * @readonly\r\n   */\r\n  this.name = entityInfo.name\r\n\r\n  if (entityInfo.caption) this.caption = entityInfo.caption\r\n  if (entityInfo.description) this.description = entityInfo.description\r\n  if (entityInfo.documentation) this.documentation = entityInfo.documentation\r\n  if (entityInfo.descriptionAttribute) this.descriptionAttribute = entityInfo.descriptionAttribute\r\n  if (entityInfo.cacheType) this.cacheType = entityInfo.cacheType\r\n  if (entityInfo.dsType) this.dsType = entityInfo.dsType\r\n\r\n  /**\r\n   * Internal short alias\r\n   * @type {String}\r\n   * @readonly\r\n   */\r\n  this.sqlAlias = entityInfo.sqlAlias\r\n  /**\r\n   * Data source connection name\r\n   * @type {String}\r\n   * @readonly\r\n   */\r\n  this.connectionName = entityInfo.connectionName\r\n  /**\r\n   * This is a Full Text Search entity\r\n   * @type {boolean}\r\n   */\r\n  this.isFTSDataTable = entityInfo.isFTSDataTable === true\r\n\r\n  /**\r\n   * Reference to connection definition (for extended domain only)\r\n   * @type {DBConnectionConfig}\r\n   * @readonly\r\n   */\r\n  this.connectionConfig = (this.connectionName && this.domain.connections) ? _.find(this.domain.connections, {name: this.connectionName}) : undefined\r\n  /**\r\n   * Optional mapping of entity to physical data (for extended domain info only).\r\n   * Calculated from a entity mapping collection in accordance with application connection configuration\r\n   * @type {UBEntityMapping}\r\n   * @readonly\r\n   */\r\n  this.mapping = undefined\r\n\r\n  if (entityInfo.mapping && Object.keys(entityInfo.mapping).length) {\r\n    dialectProiority = UBDomain.dialectsPriority[this.connectionConfig.dialect]\r\n    _.forEach(dialectProiority, function (dialect) {\r\n      if (entityInfo.mapping[dialect]) {\r\n        me.mapping = new UBEntityMapping(entityInfo.mapping[dialect])\r\n        return false\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Optional dbKeys (for extended domain info)\r\n   * @type {Object}\r\n   */\r\n  this.dbKeys = entityInfo.dbKeys && Object.keys(entityInfo.dbKeys).length ? entityInfo.dbKeys : undefined\r\n  /**\r\n   * Optional dbExtensions (for extended domain info)\r\n   * @type {Object}\r\n   */\r\n  this.dbExtensions = entityInfo.dbExtensions && Object.keys(entityInfo.dbExtensions).length ? entityInfo.dbExtensions : undefined\r\n\r\n  /**\r\n   * Entity attributes collection\r\n   * @type {Object<string, UBEntityAttribute>}\r\n   */\r\n  this.attributes = new UBEntityAttributes()\r\n  _.forEach(entityInfo.attributes, function (attributeInfo, attributeCode) {\r\n    me.attributes[attributeCode] = new UBEntityAttribute(attributeInfo, attributeCode, me)\r\n  })\r\n\r\n  mixinNames = Object.keys(entityInfo.mixins || {})\r\n  /**\r\n   * Collection of entity mixins\r\n   * @type {Object<String, UBEntityMixin>}\r\n   */\r\n  this.mixins = {}\r\n  mixinNames.forEach(function (mixinCode) {\r\n    mixinInfo = entityInfo.mixins[mixinCode]\r\n    i18nMixin = (i18n && i18n.mixins ? i18n.mixins[mixinCode] : null)\r\n    switch (mixinCode) {\r\n      case 'mStorage':\r\n        me.mixins[mixinCode] = new UBEntityStoreMixin(mixinInfo, i18nMixin, mixinCode)\r\n        break\r\n      case 'dataHistory':\r\n        me.mixins[mixinCode] = new UBEntityHistoryMixin(mixinInfo, i18nMixin, mixinCode)\r\n        break\r\n      case 'aclRls':\r\n        me.mixins[mixinCode] = new UBEntityAclRlsMixin(mixinInfo, i18nMixin, mixinCode)\r\n        break\r\n      case 'fts':\r\n        me.mixins[mixinCode] = new UBEntityFtsMixin(mixinInfo, i18nMixin, mixinCode)\r\n        break\r\n      case 'als':\r\n        me.mixins[mixinCode] = new UBEntityAlsMixin(mixinInfo, i18nMixin, mixinCode)\r\n        break\r\n      default:\r\n        me.mixins[mixinCode] = new UBEntityMixin(mixinInfo, i18nMixin, mixinCode)\r\n    }\r\n  })\r\n  /**\r\n   * Entity methods, allowed for current logged-in user in format {method1: 1, method2: 1}. 1 mean method is allowed\r\n   * @type {Object<String, Number>}\r\n   * @readOnly\r\n   */\r\n  this.entityMethods = entityMethods || {}\r\n}\r\n\r\n/**\r\n * Entity caption\r\n * @type {string}\r\n */\r\nUBEntity.prototype.caption = ''\r\n/**\r\n * Entity description\r\n * @type {string}\r\n */\r\nUBEntity.prototype.description = ''\r\n/**\r\n * Documentation\r\n * @type {string}\r\n */\r\nUBEntity.prototype.documentation = ''\r\n/**\r\n * Name of attribute witch used as a display value in lookup\r\n * @type {string}\r\n */\r\nUBEntity.prototype.descriptionAttribute = ''\r\n\r\n/**\r\n * Indicate how entity content is cached on the client side.\r\n *\r\n * @type {UBDomain.EntityCacheTypes}\r\n * @readonly\r\n */\r\nUBEntity.prototype.cacheType = 'None'\r\n\r\n/**\r\n *\r\n * @type {UBDomain.EntityDataSourceType}\r\n */\r\nUBEntity.prototype.dsType = 'Normal'\r\n\r\n/**\r\n * Return an entity caption to display on UI\r\n * @returns {string}\r\n */\r\nUBEntity.prototype.getEntityCaption = function () {\r\n  return this.caption || this.description\r\n}\r\n\r\n/**\r\n * Get entity attribute by code. Return undefined if attribute does not found\r\n * @param {String} attributeCode\r\n * @param {Boolean} [simple] Is do not complex attribute name. By default false.\r\n * @returns {UBEntityAttribute}\r\n */\r\nUBEntity.prototype.attr = function (attributeCode, simple) {\r\n  let res = this.attributes[attributeCode]\r\n  if (!res && !simple) {\r\n    res = this.getEntityAttribute(attributeCode)\r\n  }\r\n  return res\r\n}\r\n\r\n/**\r\n * Get entity attribute by code. Throw error if attribute does not found.\r\n * @param attributeCode\r\n * @returns {UBEntityAttribute}\r\n */\r\nUBEntity.prototype.getAttribute = function (attributeCode) {\r\n  let attr = this.attributes[attributeCode]\r\n  if (!attr) {\r\n    throw new Error(`Attribute ${this.code}.${attributeCode} doesn't exist`)\r\n  }\r\n  return attr\r\n}\r\n\r\n/**\r\n * Call callBack function for each attribute.\r\n * @param {Function} callBack\r\n */\r\nUBEntity.prototype.eachAttribute = function (callBack) {\r\n  return _.forEach(this.attributes, callBack)\r\n}\r\n\r\n/**\r\n * Get entity mixin by code. Returns \"undefined\" if the mixin is not found\r\n * @param {String} mixinCode\r\n * @returns {UBEntityMixin}\r\n */\r\nUBEntity.prototype.mixin = function (mixinCode) {\r\n  return this.mixins[mixinCode]\r\n}\r\n\r\n/**\r\n * Check the entity has mixin. Returns `true` if the mixin is exist and enabled\r\n * @param {String} mixinCode\r\n * @returns {Boolean}\r\n */\r\nUBEntity.prototype.hasMixin = function (mixinCode) {\r\n  let mixin = this.mixins[mixinCode]\r\n  if (mixinCode === 'audit') {\r\n    return !mixin || (!!mixin && mixin.enabled)\r\n  }\r\n  return (!!mixin && mixin.enabled)\r\n}\r\n\r\n/**\r\n * Check the entity has mixin. Throw error if mixin dose not exist or not enabled\r\n * @param {String} mixinCode\r\n */\r\nUBEntity.prototype.checkMixin = function (mixinCode) {\r\n  if (!this.hasMixin(mixinCode)) {\r\n    throw new Error('Entity ' + this.code + ' does not have mixin ' + mixinCode)\r\n  }\r\n}\r\n\r\nUBEntity.prototype.asJSON = function () {\r\n  let result = { code: this.code }\r\n  _.forEach(this, function (prop, propName) {\r\n    if (propName === 'domain') {\r\n      return\r\n    }\r\n    if (prop.asJSON) {\r\n      result[propName] = prop.asJSON()\r\n    } else {\r\n      result[propName] = prop\r\n    }\r\n  })\r\n  return result\r\n}\r\n\r\n/**\r\n * Check current user have access to specified entity method\r\n * @param {String} methodCode\r\n * @returns {Boolean}\r\n */\r\nUBEntity.prototype.haveAccessToMethod = function (methodCode) {\r\n  return this.entityMethods[methodCode] === 1\r\n}\r\n\r\n/**\r\n * Filter attributes by properties\r\n * @param {Object|Function} config\r\n * @returns {Array}\r\n * example\r\n *\r\n *      domain.get('uba_user').filterAttribute({dataType: 'Document'});\r\n *\r\n *   return all attributes where property dataType equal Document\r\n */\r\nUBEntity.prototype.filterAttribute = function (config) {\r\n  if (_.isFunction(config)) {\r\n    return _.filter(this.attributes, config)\r\n  } else {\r\n    return _.filter(this.attributes, function (item) {\r\n      let res = true\r\n      for (let prop in config) {\r\n        if (config.hasOwnProperty(prop)) {\r\n          res = res && (item[prop] === config[prop])\r\n        }\r\n      }\r\n      return res\r\n    })\r\n  }\r\n}\r\n\r\n/**\r\n * Check current user have access to AT LAST one of specified methods\r\n * @param {Array} methods\r\n * @returns {boolean}\r\n */\r\nUBEntity.prototype.haveAccessToAnyMethods = function (methods) {\r\n  let me = this\r\n  let fMethods = methods || []\r\n  let result = false\r\n\r\n  fMethods.forEach(function (methodCode) {\r\n    result = result || me.entityMethods[methodCode] === 1\r\n  })\r\n  return result\r\n}\r\n\r\n/**\r\n * Check current user have access to ALL of specified methods\r\n * @param {Array<String>} methods Method names\r\n * @returns {Boolean}\r\n */\r\nUBEntity.prototype.haveAccessToMethods = function (methods) {\r\n  let me = this\r\n  let result = true\r\n  let fMethods = methods || []\r\n\r\n  fMethods.forEach(function (methodCode) {\r\n    result = result && (me.entityMethods[methodCode] === 1)\r\n  })\r\n  return result\r\n}\r\n\r\n/**\r\n * Convert UnityBase server dateTime response to Date object\r\n * @private\r\n * @param value\r\n * @returns {Date}\r\n */\r\nfunction iso8601Parse (value) {\r\n  return value ? new Date(value) : null\r\n}\r\n\r\n/**\r\n * Convert UnityBase server date response to Date object.\r\n * date response is a day with 00 time (2015-07-17T00:00Z), to get a real date we must add current timezone shift\r\n * @private\r\n * @param value\r\n * @returns {Date}\r\n */\r\nfunction iso8601ParseAsDate (value) {\r\n  let res = value ? new Date(value) : null\r\n  if (res) {\r\n    res.setTime(res.getTime() + res.getTimezoneOffset() * 60 * 1000)\r\n  }\r\n  return res\r\n}\r\n\r\n/**\r\n * Convert UnityBase server Boolean response to Boolean (0 = false & 1 = trhe)\r\n * @private\r\n * @param v Value to convert\r\n * @returns {Boolean|null}\r\n */\r\nfunction booleanParse (v) {\r\n  if (typeof v === 'boolean') {\r\n    return v\r\n  }\r\n  if ((v === undefined || v === null || v === '')) {\r\n    return null\r\n  }\r\n  return v === 1\r\n}\r\n\r\n/**\r\n * return array of conversion rules for raw server response data\r\n * @param {Array<String>} fieldList\r\n * @returns {Array<{index: number, convertFn: function}>}\r\n */\r\nUBEntity.prototype.getConvertRules = function (fieldList) {\r\n  let me = this\r\n  let rules = []\r\n  let types = UBDomain.ubDataTypes\r\n\r\n  fieldList.forEach(function (fieldName, index) {\r\n    let attribute = me.attr(fieldName)\r\n    if (attribute) {\r\n      if (attribute.dataType === types.DateTime) {\r\n        rules.push({\r\n          index: index,\r\n          convertFn: iso8601Parse\r\n        })\r\n      } else if (attribute.dataType === types.Date) {\r\n        rules.push({\r\n          index: index,\r\n          convertFn: iso8601ParseAsDate\r\n        })\r\n      } else if (attribute.dataType === types.Boolean) {\r\n        rules.push({\r\n          index: index,\r\n          convertFn: booleanParse\r\n        })\r\n      }\r\n    }\r\n  })\r\n  return rules\r\n}\r\n\r\n/**\r\n * Return description attribute name (`descriptionAttribute` metadata property)\r\n * This property may be empty or valid(validation performed by server)\r\n * If case property is empty - try to get attribute with code `caption`\r\n *\r\n * @return {String}\r\n */\r\nUBEntity.prototype.getDescriptionAttribute = function () {\r\n  let result = this.descriptionAttribute || 'caption'\r\n  if (!this.attr(result)) {\r\n    throw new Error('Missing description attribute for entity ' + this.code)\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * Return information about attribute and attribute entity. Understand complex attributes like firmID.firmType.code\r\n * @param {String} attributeName\r\n * @param {Number} [deep] If 0 - last, -1 - before last, > 0 - root. Default 0.\r\n * @return {{ entity: String, attribute: Object, attributeCode: String }}\r\n */\r\nUBEntity.prototype.getEntityAttributeInfo = function (attributeName, deep) {\r\n  let domainEntity = this\r\n  let attributeNameParts = attributeName.split('.')\r\n  let currentLevel = -(attributeNameParts.length - 1)\r\n  let complexAttr = []\r\n  let currentEntity = this.code\r\n  /** @type UBEntityAttribute */\r\n  let attribute\r\n  let key\r\n\r\n  if (deep && deep > 0) {\r\n    return { entity: currentEntity, attribute: domainEntity.attr(attributeNameParts[0]), attributeCode: attributeNameParts[0] }\r\n  }\r\n\r\n  while (domainEntity && attributeNameParts.length) {\r\n    if (domainEntity && attributeNameParts.length === 1) {\r\n      complexAttr = attributeNameParts[0].split('@')\r\n      if (complexAttr.length > 1) {\r\n        domainEntity = this.domain.get(complexAttr[1]) // real entity is text after @\r\n        attributeName = complexAttr[0]\r\n      }\r\n      return { entity: currentEntity, attribute: domainEntity.attr(attributeName), attributeCode: attributeName }\r\n    }\r\n    key = attributeNameParts.shift()\r\n    complexAttr = key.split('@')\r\n    if (complexAttr.length > 1) {\r\n      currentEntity = complexAttr[1]\r\n      domainEntity = this.domain.get(currentEntity) // real entity is text after @\r\n      key = complexAttr[0]\r\n    }\r\n    attribute = domainEntity.attr(key)\r\n    if (attribute) { // check that attribute exists in domainEntity\r\n      if (currentLevel === (deep || 0)) {\r\n        return { entity: currentEntity, attribute: attribute, attributeCode: key }\r\n      }\r\n      attributeName = attributeNameParts[0]\r\n      if (attribute.dataType === 'Enum' && attributeName === 'name') {\r\n        return { entity: currentEntity, attribute: attribute, attributeCode: key }\r\n      } else {\r\n        currentEntity = attribute.associatedEntity\r\n        domainEntity = attribute.getAssociatedEntity()\r\n      }\r\n    } else {\r\n      return undefined\r\n    }\r\n    currentLevel += 1\r\n  }\r\n  return undefined\r\n}\r\n\r\n/**\r\n * Return Entity attribute. Understand complex attributes like firmID.firmType.code\r\n * @param {String} attributeName\r\n * @param {Number} [deep] If 0 - last, -1 - before last, > 0 - root. Default 0.\r\n * @return {UBEntityAttribute}\r\n */\r\nUBEntity.prototype.getEntityAttribute = function (attributeName, deep) {\r\n  let domainEntity = this\r\n  let attributeNameParts = attributeName.split('.')\r\n  let currentLevel = -(attributeNameParts.length - 1)\r\n  let complexAttr = []\r\n  let attribute\r\n  let key\r\n\r\n  if (deep && deep > 0) {\r\n    return domainEntity.attributes[attributeNameParts[0]]\r\n  }\r\n\r\n    // TODO: Сделать так же для других спец.символов, кроме @\r\n  while (domainEntity && attributeNameParts.length) {\r\n    if (domainEntity && attributeNameParts.length === 1) {\r\n      complexAttr = attributeNameParts[0].split('@')\r\n      if (complexAttr.length > 1) {\r\n        domainEntity = this.domain.get(complexAttr[1]) // real entity is text after @\r\n        attributeName = complexAttr[0]\r\n      }\r\n      return domainEntity.attributes[attributeName]\r\n    }\r\n    key = attributeNameParts.shift()\r\n    complexAttr = key.split('@')\r\n    if (complexAttr.length > 1) {\r\n      domainEntity = this.domain.get(complexAttr[1]) // real entity is text after @\r\n      key = complexAttr[0]\r\n    }\r\n    attribute = domainEntity.attributes[key]\r\n    if (attribute) { // check that attribute exists in domainEntity\r\n      if (currentLevel === (deep || 0)) {\r\n        return attribute\r\n      }\r\n      attributeName = attributeNameParts[0]\r\n      if (attribute.dataType === 'Enum') {\r\n        if (attributeName === 'name') { // WTF?\r\n          return attribute\r\n        } else {\r\n          domainEntity = this.domain.get('ubm_enum')\r\n        }\r\n      } else {\r\n        domainEntity = this.domain.get(attribute.associatedEntity)\r\n      }\r\n    } else {\r\n      return undefined\r\n    }\r\n    currentLevel += 1\r\n  }\r\n  return undefined\r\n}\r\n\r\n/**\r\n * return attributes code list\r\n * @param {Object|Function} [filter]\r\n * @returns String[]\r\n */\r\nUBEntity.prototype.getAttributeNames = function (filter) {\r\n  let attributes = []\r\n  if (filter) {\r\n    _.forEach(this.filterAttribute(filter), function (attr) {\r\n      attributes.push(attr.code)\r\n    })\r\n    return attributes\r\n  } else {\r\n    return Object.keys(this.attributes)\r\n  }\r\n}\r\n\r\n/**\r\n * Return requirements entity code list for field list\r\n * @param {String[]} [fieldList] (optional)\r\n * @return {String[]}\r\n */\r\nUBEntity.prototype.getEntityRequirements = function (fieldList) {\r\n  let result = []\r\n\r\n  fieldList = fieldList || this.getAttributeNames()\r\n\r\n  for (let i = 0, len = fieldList.length; i < len; ++i) {\r\n    let fieldNameParts = fieldList[i].split('.')\r\n\r\n    let attr = this.getEntityAttribute(fieldNameParts[0])\r\n    if (attr.dataType === 'Entity') {\r\n      if (fieldNameParts.length > 1) {\r\n        let tail = [fieldNameParts.slice(1).join('.')]\r\n        result = _.union(result, attr.getAssociatedEntity().getEntityRequirements(tail))\r\n      } else {\r\n        result = _.union(result, [attr.associatedEntity])\r\n      }\r\n    }\r\n  }\r\n\r\n  return result\r\n}\r\n\r\n/**\r\n * Check the entity contains attribute(s) and throw error if not contains\r\n * @param {String|Array<String>} attributeName\r\n * @param {String} contextMessage\r\n */\r\nUBEntity.prototype.checkAttributeExist = function (attributeName, contextMessage) {\r\n  let me = this\r\n  attributeName = !_.isArray(attributeName) ? [attributeName] : attributeName\r\n  _.forEach(attributeName, function (fieldName) {\r\n    if (!me.getEntityAttributeInfo(fieldName)) {\r\n      throw new Error(contextMessage + (contextMessage ? ' ' : '') +\r\n            'The entity \"' + me.code + '\" does not have attribute \"' + fieldName + '\"')\r\n    }\r\n  })\r\n}\r\n\r\n/**\r\n * Return entity description.\r\n * @returns {string}\r\n */\r\nUBEntity.prototype.getEntityDescription = function () {\r\n  return this.description || this.caption\r\n}\r\n\r\n/** @class */\r\nfunction UBEntityAttributeMapping (maping) {\r\n  /**\r\n   * @type {UBDomain.ExpressionType}\r\n   */\r\n  this.expressionType = maping.expressionType\r\n  /** @type {string} */\r\n  this.expression = maping.expression\r\n}\r\n\r\n/**\r\n * @param {Object} attributeInfo\r\n * @param {String} attributeCode\r\n * @param {UBEntity} entity\r\n * @constructor\r\n */\r\nfunction UBEntityAttribute (attributeInfo, attributeCode, entity) {\r\n  // i18n already merged by entity constructor\r\n  /**\r\n   * @type {String}\r\n   * @readonly\r\n   */\r\n  this.code = attributeCode\r\n  /** @type {String}\r\n  * @readonly\r\n  */\r\n  this.name = attributeInfo.name\r\n    /**\r\n     * @type {UBEntity}\r\n     * @readonly\r\n     */\r\n  this.entity = entity\r\n    /**\r\n     * Data type\r\n     * @type {UBDomain.ubDataTypes}\r\n     * @readonly\r\n     */\r\n  this.dataType = attributeInfo.dataType || 'String'\r\n    /**\r\n     * Название сущности, на которую ссылаемся (для adtMany сущность, на которую ссылаемся из AssociationManyData)\r\n     * @type {String}\r\n     * @readonly\r\n     */\r\n  this.associatedEntity = attributeInfo.associatedEntity\r\n    /**\r\n     * @type {String}\r\n     * @readonly\r\n     */\r\n  this.associationAttr = attributeInfo.associationAttr\r\n    /**\r\n     * @type {String}\r\n     * @readonly\r\n     */\r\n  this.caption = attributeInfo.caption || ''\r\n    /**\r\n     * @type {String}\r\n     * @readonly\r\n     */\r\n  this.description = attributeInfo.description || ''\r\n    /**\r\n     * @type {String}\r\n     * @readonly\r\n     */\r\n  this.documentation = attributeInfo.documentation || ''\r\n    /**\r\n     * @property {Number} size\r\n     * size\r\n     * @readonly\r\n     */\r\n  this.size = attributeInfo.size || 0\r\n    /**\r\n     * Attribute value can be empty or null\r\n     * @type {boolean}\r\n     * @readonly\r\n     */\r\n  this.allowNull = (attributeInfo.allowNull !== false)\r\n      /**\r\n     * Allow order by clause by this attribute\r\n     * @type {boolean}\r\n     * @readonly\r\n     */\r\n  this.allowSort = (attributeInfo.allowSort !== false)\r\n    /**\r\n     * @type {boolean}\r\n     * @readonly\r\n     */\r\n  this.isUnique = (attributeInfo.isUnique === true)\r\n    /**\r\n     * @type{String}\r\n     * @readonly\r\n     */\r\n  this.defaultValue = attributeInfo.defaultValue\r\n    /**\r\n     * Allow edit\r\n     * @type {Boolean}\r\n     * @readonly\r\n     */\r\n  this.readOnly = (attributeInfo.readOnly === true)\r\n    /**\r\n     * @property {Boolean}\r\n     * @readonly\r\n     */\r\n  this.isMultiLang = (attributeInfo.isMultiLang === true)\r\n    /**\r\n     * Possible for dataType=Entity - enable cascade delete on application serve level (not on database level)\r\n     * @type {Boolean}\r\n     * @readonly\r\n     */\r\n  this.cascadeDelete = (attributeInfo.cascadeDelete === true)\r\n    /**\r\n     * Required for dataType=Enum - Group code from ubm_enum.eGroup\r\n     * @property {String} enumGroup\r\n     * @readonly\r\n     */\r\n  this.enumGroup = attributeInfo.enumGroup\r\n    /**\r\n     * @type {Object}\r\n     * @readonly\r\n     */\r\n  this.customSettings = attributeInfo.customSettings || {}\r\n    /**\r\n     * Required for dataType=Many - name of the many-to-many table. UB create system entity with this name and generate table during DDL generation\r\n     * @property {String}\r\n     * @readonly\r\n     */\r\n  this.associationManyData = attributeInfo.associationManyData\r\n    /**\r\n     * Applicable to attribute with dataType=Document - name of store from storeConfig application config section. If emtpy - store with isDefault=true will be used\r\n     * @type{String}\r\n     * @readonly\r\n     */\r\n  this.storeName = attributeInfo.storeName\r\n  /**\r\n   * Applicable for dataType=Entity. If false DDL generator will bypass foreign key generation on the database level\r\n   * @type {boolean}\r\n   */\r\n  this.generateFK = attributeInfo.generateFK !== false\r\n\r\n  /**\r\n   * If true - client should shows this attribute in auto-build forms and in '*' select fields\r\n   * @type {boolean}\r\n   */\r\n  this.defaultView = attributeInfo.defaultView !== false\r\n\r\n  /**\r\n   * Optional mapping of atribute to phisical data (for extended domain info only).\r\n   * Calculated from a entity mapping collection in accordance with application connection confiduration\r\n   * @type {UBEntityAttributeMapping}\r\n   * @readonly\r\n   */\r\n  this.mapping = undefined\r\n\r\n  let me = this\r\n  if (attributeInfo.mapping && Object.keys(attributeInfo.mapping).length) {\r\n    let dialectsPriority = UBDomain.dialectsPriority[this.entity.connectionConfig.dialect]\r\n    _.forEach(dialectsPriority, function (dialect) {\r\n      if (attributeInfo.mapping[dialect]) {\r\n        me.mapping = new UBEntityAttributeMapping(attributeInfo.mapping[dialect])\r\n        return false // break loop\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * @property {String} physicalDataType\r\n   * @readonly\r\n   */\r\n  this.physicalDataType = UBDomain.getPhysicalDataType(this.dataType || 'String')\r\n}\r\n\r\n/**\r\n * Return associated entity. Return null if attribute type is not Entity.\r\n * @returns {UBEntity}\r\n */\r\nUBEntityAttribute.prototype.getAssociatedEntity = function () {\r\n  return this.associatedEntity ? this.entity.domain.get(this.associatedEntity) : null\r\n}\r\n\r\nUBEntityAttribute.prototype.asJSON = function () {\r\n  let result = {}\r\n  _.forEach(this, function (prop, propName) {\r\n    if (propName === 'entity') {\r\n      return\r\n    }\r\n    if (prop.asJSON) {\r\n      result[propName] = prop.asJSON()\r\n    } else {\r\n      result[propName] = prop\r\n    }\r\n  })\r\n  return result\r\n}\r\n\r\n/**\r\n * Contains all properties defined in mixin section of a entity metafile\r\n * @class\r\n * @protected\r\n * @param {Object} mixinInfo\r\n * @param {Object} i18n\r\n * @param {String} mixinCode\r\n */\r\nfunction UBEntityMixin (mixinInfo, i18n, mixinCode) {\r\n  /**\r\n   * Mixin code\r\n   * @type {String}\r\n   */\r\n  this.code = mixinCode\r\n  _.assign(this, mixinInfo)\r\n  if (i18n) {\r\n    _.assign(this, i18n)\r\n  }\r\n}\r\n\r\nUBEntityMixin.prototype.enabled = true\r\n\r\n/**\r\n * Mixin for persisting entity to a database\r\n * @class\r\n * @extends UBEntityMixin\r\n * @param mixinInfo\r\n * @param i18n\r\n * @param mixinCode\r\n */\r\nfunction UBEntityStoreMixin (mixinInfo, i18n, mixinCode) {\r\n  UBEntityMixin.apply(this, arguments)\r\n}\r\nUBEntityStoreMixin.prototype = Object.create(UBEntityMixin.prototype)\r\nUBEntityStoreMixin.prototype.constructor = UBEntityStoreMixin\r\n// defaults\r\n/**\r\n * Is `simpleAudit` enabled\r\n * @type {boolean}\r\n */\r\nUBEntityStoreMixin.prototype.simpleAudit = false\r\n/**\r\n * Use a soft delete\r\n * @type {boolean}\r\n */\r\nUBEntityStoreMixin.prototype.safeDelete = false\r\n\r\n/**\r\n * Historical data storage mixin\r\n * @class\r\n * @extends UBEntityMixin\r\n * @param mixinInfo\r\n * @param i18n\r\n * @param mixinCode\r\n * @constructor\r\n */\r\nfunction UBEntityHistoryMixin (mixinInfo, i18n, mixinCode) {\r\n  UBEntityMixin.apply(this, arguments)\r\n}\r\nUBEntityHistoryMixin.prototype = Object.create(UBEntityMixin.prototype)\r\nUBEntityHistoryMixin.prototype.constructor = UBEntityHistoryMixin\r\n/**\r\n * A history storage strategy\r\n * @type {string}\r\n */\r\nUBEntityHistoryMixin.prototype.historyType = 'common'\r\n/**\r\n * Access control list mixin\r\n * @class\r\n * @extends UBEntityMixin\r\n * @param mixinInfo\r\n * @param i18n\r\n * @param mixinCode\r\n */\r\nfunction UBEntityAclRlsMixin (mixinInfo, i18n, mixinCode) {\r\n  UBEntityMixin.apply(this, arguments)\r\n}\r\nUBEntityAclRlsMixin.prototype = Object.create(UBEntityMixin.prototype)\r\nUBEntityAclRlsMixin.prototype.constructor = UBEntityAclRlsMixin\r\n// defaults\r\nUBEntityAclRlsMixin.prototype.aclRlsUseUnityName = false\r\nUBEntityAclRlsMixin.prototype.aclRlsSelectionRule = 'exists'\r\n\r\n/**\r\n * Full text search mixin\r\n * @class\r\n * @extends UBEntityMixin\r\n * @param mixinInfo\r\n * @param i18n\r\n * @param mixinCode\r\n */\r\nfunction UBEntityFtsMixin (mixinInfo, i18n, mixinCode) {\r\n  UBEntityMixin.apply(this, arguments)\r\n}\r\nUBEntityFtsMixin.prototype = Object.create(UBEntityMixin.prototype)\r\nUBEntityFtsMixin.prototype.constructor = UBEntityFtsMixin\r\n/**\r\n * scope\r\n * @type {string}\r\n */\r\nUBEntityFtsMixin.prototype.scope = 'connection' // sConnection\r\n/**\r\n * Data provider type\r\n * @type {string}\r\n */\r\nUBEntityFtsMixin.prototype.dataProvider = 'mixin'// dcMixin\r\n/**\r\n * Attribute level security mixin\r\n * @param mixinInfo\r\n * @param i18n\r\n * @param mixinCode\r\n * @constructor\r\n * @extends UBEntityMixin\r\n */\r\nfunction UBEntityAlsMixin (mixinInfo, i18n, mixinCode) {\r\n  UBEntityMixin.apply(this, arguments)\r\n}\r\nUBEntityAlsMixin.prototype = Object.create(UBEntityMixin.prototype)\r\nUBEntityAlsMixin.prototype.constructor = UBEntityAlsMixin\r\n/**\r\n * Is optimistic\r\n * @type {boolean}\r\n */\r\nUBEntityAlsMixin.prototype.alsOptimistic = true\r\n\r\nmodule.exports = UBDomain\r\n\n\n\n// WEBPACK FOOTER //\n// ./../base/UBDomain.js","/**\r\n * Internal class, returned as a result of {@link UBConnection#authorize UBConnection.authorize()}\r\n * @module @unitybase/base/UBSession\r\n */\r\n/*\r\n @author pavel.mash\r\n */\r\n\r\n/* global ncrc32 */\r\n\r\n// ***********   !!!!WARNING!!!!! **********************\r\n// Module shared between server and client code\r\n/**\r\n * Internal class, returned as a result of {@link UBConnection#authorize UBConnection.authorize()}\r\n * The main method is {@link UBSession.signature UBSession.signature()}\r\n *\r\n * Developer never create this class directly.\r\n * @class\r\n * @protected\r\n */\r\nfunction UBSession (authResponse, secretWord, authSchema) {\r\n  var data = authResponse\r\n  var hexa8ID = hexa8(data.result.split('+')[ 0 ])\r\n  var userData = data.uData ? JSON.parse(data.uData) : { lang: 'en', login: 'anonymous' }\r\n  var sessionWord = data.result\r\n  var sessionPwdHash = secretWord || ''\r\n  var sessionSaltCRC = (typeof window === 'undefined') ? ncrc32(0, sessionWord + sessionPwdHash) : null\r\n\r\n  if (!userData.login) {\r\n    userData.login = data.logonname\r\n  }\r\n\r\n    /** @property {String} sessionID user session id converted to {@link UBSession#hexa8}\r\n     * @protected\r\n     * @readonly\r\n     */\r\n  Object.defineProperty(this, 'sessionID', {enumerable: true, writable: false, value: hexa8ID})\r\n    /**\r\n     * User logon name. Better to access this value using {@link UBConnection#userLogin UBConnection.userLogin()} method.\r\n     * @type {String}\r\n     * @private\r\n     * @readonly\r\n     */\r\n  this.logonname = data.logonname\r\n\r\n    /** Contain custom user data. Usually filled inside **server** `onUserLogon` event handlers\r\n     *\r\n     * Do not use it directly, instead use helper method {@link UBConnection#userData UBConnection.userData()} instead.\r\n     *\r\n     * @type {Object}\r\n     * @protected\r\n     * @readonly\r\n     */\r\n  this.userData = userData\r\n\r\n    /**\r\n     * Name of authentication schema\r\n     * @type {String}\r\n     * @protected\r\n     * @readonly\r\n     */\r\n  this.authSchema = authSchema || 'UB'\r\n\r\n    /**\r\n     * Session signature for authorized request. Can be added as LAST parameter in url, or to Authorization header (preferred way)\r\n     *\r\n     *      $App.connection.authorize().then(function(session){\r\n     *          // for URL\r\n     *          return 'session_signature=' + session.signature()\r\n     *          //for header\r\n     *          return {Authorization: session.authSchema + ' ' + session.signature()}\r\n     *      });\r\n     *\r\n     * @returns {string}\r\n     */\r\n  this.signature = function () {\r\n    var timeStampI, hexaTime\r\n    switch (this.authSchema) {\r\n      case 'None':\r\n        return ''\r\n      case 'UBIP':\r\n        return this.logonname\r\n      default:\r\n        timeStampI = Math.floor((new Date()).getTime() / 1000)\r\n        hexaTime = hexa8(timeStampI)\r\n        return hexa8ID + hexaTime + hexa8((typeof window === 'undefined') ? ncrc32(sessionSaltCRC, hexaTime) : crc32(sessionWord + sessionPwdHash + hexaTime)) // + url?\r\n    }\r\n        // 1.7 return  hexa8ID + hexa8(timeStampI) + hexa8(crc32(timeStampI + '' + crc32SessionWord ));\r\n  }\r\n\r\n    /**\r\n     * Current session is anonymous session\r\n     * @returns {boolean}\r\n     */\r\n  this.isAnonymous = function () {\r\n    return (this.authSchema === 'None')\r\n  }\r\n\r\n    /**\r\n     * Return authorization header\r\n     *\r\n     *      $App.connection.authorize().then(function(session){\r\n     *          return {Authorization: session.authHeader()}\r\n     *      });\r\n     *\r\n     * @returns {string}\r\n     */\r\n  this.authHeader = function () {\r\n    return this.isAnonymous() ? '' : (this.authSchema + ' ' + this.signature())\r\n  }\r\n}\r\n\r\n/**\r\n * Return hexadecimal string of 8 character length from value\r\n * @param {String|Number} value\r\n * @returns {String}\r\n */\r\nUBSession.prototype.hexa8 = function hexa8 (value) {\r\n  var num = parseInt(value, 10)\r\n  var res = isNaN(num) ? '00000000' : num.toString(16)\r\n  while (res.length < 8) {\r\n    res = '0' + res\r\n  }\r\n  return res\r\n}\r\nvar hexa8 = UBSession.prototype.hexa8\r\n\r\nvar CRC32_POLYTABLES = {}\r\n/* jslint bitwise: true */\r\n/**\r\n * Calculate CRC32 checksum for string\r\n * @param {String} s string to calculate CRC32\r\n * @param {Number} [polynomial] polynomial basis. default to 0x04C11DB7\r\n * @param {Number} [initialValue] initial crc value. default to 0xFFFFFFFF\r\n * @param {Number} [finalXORValue] default to 0xFFFFFFFF\r\n * @returns {Number}\r\n */\r\nUBSession.prototype.crc32 = function crc32 (s, polynomial, initialValue, finalXORValue) {\r\n  var table, i, j, c, crc\r\n  s = String(s)\r\n  polynomial = polynomial || 0x04C11DB7\r\n  initialValue = initialValue || 0xFFFFFFFF\r\n  finalXORValue = finalXORValue || 0xFFFFFFFF\r\n  crc = initialValue\r\n\r\n  table = CRC32_POLYTABLES[polynomial]\r\n  if (!table) {\r\n    table = CRC32_POLYTABLES[polynomial] = (function build () {\r\n      var i, j, c\r\n      var table = []\r\n      var reverse = function (x, n) {\r\n        var b = 0\r\n        while (n) {\r\n          b = b * 2 + x % 2\r\n          x /= 2\r\n          x -= x % 1\r\n          n--\r\n        }\r\n        return b\r\n      }\r\n      for (i = 255; i >= 0; i--) {\r\n        c = reverse(i, 32)\r\n\r\n        for (j = 0; j < 8; j++) {\r\n          c = ((c * 2) ^ (((c >>> 31) % 2) * polynomial)) >>> 0\r\n        }\r\n\r\n        table[i] = reverse(c, 32)\r\n      }\r\n      return table\r\n    })()\r\n  }\r\n\r\n  for (i = 0; i < s.length; i++) {\r\n    c = s.charCodeAt(i)\r\n    if (c > 255) {\r\n      throw new RangeError()\r\n    }\r\n    j = (crc % 256) ^ c\r\n    crc = ((crc / 256) ^ table[j]) >>> 0\r\n  }\r\n  return (crc ^ finalXORValue) >>> 0\r\n}\r\nvar crc32 = UBSession.prototype.crc32\r\n\r\nmodule.exports = UBSession\r\n\n\n\n// WEBPACK FOOTER //\n// ./../base/UBSession.js","// Originally found on  from https://github.com/mozilla/localForage\r\nlet dbInfo = {\r\n  name: 'UB',\r\n  stores: ['permanent', 'session', 'userData'],\r\n  version: 1\r\n}\r\n\r\n// Initialize IndexedDB; fall back to vendor-prefixed versions if needed.\r\n// noinspection JSUnresolvedVariable\r\nconst iDB = window.indexedDB || window.webkitIndexedDB ||\r\n    window.mozIndexedDB || window.OIndexedDB || window.msIndexedDB\r\n\r\n/**\r\n * @classdesc\r\n * Client side cache. Wrapper around <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB\">indexedDB</a>\r\n * !!! Don't try to refactor this code - starting of transaction in separate promise is not work for Firefox!!! see <a href=\"http://stackoverflow.com/questions/28388129/inconsistent-interplay-between-indexeddb-transactions-and-promises\">this topic</a>\r\n *\r\n * Contain functions for simple key/value manipulations and advanced (entity related) manipulations.\r\n *\r\n * Create separate <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase\">database</a>\r\n * for each connection inside application.\r\n *\r\n * For every database will create three <a href =\"https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase.createObjectStore\">store</a>\r\n *\r\n *  - **permanent** for data persistent between sessions and\r\n *  - **session** for data, live inside user session only (from login to login)\r\n *  - **user** for custom data\r\n *\r\n * Usage sample\r\n\r\n        var c = new UBCache('mydb');\r\n        c.put([\r\n            {key: 'note1', value: {prop1: 1, prop2: 'do something'} },\r\n            {key: 'note2', value: 'do something else'}\r\n        ]).then();\r\n        c.get('note1').then(UB.logDebug); //output result to console\r\n        c.clear();\r\n        c.get('note1').then(function(value){\r\n            console.log(value === undefined ? 'all cleared': 'hm... something wrong')\r\n        });\r\n\r\n * @class UBCache\r\n * @author pavel.mash on 17.04.2014 (rewrites to ES6 on 12.2016)\r\n * @param {String} dbName Name of indexedDB database we create. Usually this is {@link UBConnection#baseURL}. Constructor lower case dbName during creation\r\n * @param {Number} [version] Optionally database version.\r\n */\r\nfunction UBCache (dbName, version) {\r\n  /** indexedDB name\r\n   * @property {String} dbName\r\n   * @readonly\r\n   */\r\n  this.dbName = dbName.toLowerCase()\r\n\r\n  let _dbPromise = new Promise((resolve, reject) => {\r\n    if (!iDB) {\r\n      reject({errMsg: 'unsupportedBrowser', errDetails: 'indexedDB not found'})\r\n    }\r\n    let openRequest = iDB.open(this.dbName, version || 1)\r\n    openRequest.onerror = function withStoreOnError (e) {\r\n      reject(e) // openRequest.error.name\r\n    }\r\n    openRequest.onblocked = function () {\r\n      reject({errMsg: 'databaseIsBlocked', errDetails: 'we need to upgrade database, but some other browser tab also open it'})\r\n    }\r\n    openRequest.onsuccess = function withStoreOnSuccess () {\r\n      resolve(openRequest.result)\r\n    }\r\n    openRequest.onupgradeneeded = function withStoreOnUpgradeNeeded (e) {\r\n      // First time setup: create an empty object stores\r\n      let db = e.target.result\r\n      let tx = e.target.transaction\r\n      console.log('upgrading database \"' + db.name + '\" from version ' + e.oldVersion +\r\n        ' to version ' + e.newVersion + '...')\r\n      dbInfo.stores.forEach(function (storeName) {\r\n        // noinspection JSUnresolvedVariable\r\n        if (!db.objectStoreNames.contains(storeName)) {\r\n          db.createObjectStore(storeName)\r\n        } else {\r\n          // noinspection JSUnresolvedFunction\r\n          tx.objectStore(storeName).clear()\r\n        }\r\n      })\r\n    }\r\n  })\r\n\r\n  /**\r\n   * Must be call before access to UBCache methods\r\n   * @method\r\n   * @private\r\n   * @returns {Promise} resolved to IDBDatabase\r\n   */\r\n  this.ready = function () {\r\n    return _dbPromise\r\n  }\r\n}\r\n\r\n/**\r\n * SESSION store name\r\n * @readonly\r\n * @type {String}\r\n */\r\nUBCache.SESSION = 'session'\r\n/**\r\n * PERMANENT store name\r\n * @readonly\r\n * @type {String}\r\n */\r\nUBCache.PERMANENT = 'permanent'\r\n\r\n/**\r\n * Possible cache types for businnes logic data\r\n * @readonly\r\n * @enum\r\n */\r\nUBCache.cacheTypes = {\r\n    /**\r\n     * Кэширование не осуществляется. Запрос на сервер отправляется всегда.\r\n     *\r\n     * @type String\r\n     */\r\n  None: 'None',\r\n\r\n    /**\r\n     * Кэширование осуществляется на уровне сущности. Запрос на сервер отправляется всегда. При этом в запрос добавляется версия закэшированных данных, если таковые имеются.\r\n     * Результат запроса содержит\r\n     * или данные и версию данных, которые помещаются в кэш;\r\n     * или флаг notModified. В этом случае данные считываются из кэша.\r\n     *\r\n     * Если в запросе в whereList присутствует ID - кэширование не осуществляется. Запрос на сервер отправляется всегда.\r\n     *\r\n     * @type String\r\n     */\r\n  Entity: 'Entity',\r\n\r\n    /**\r\n     * Кэширование осуществляется на уровне сессии. Запрос на сервер отправляется только один раз при старте сессии. При старте сессии все закэшированные сущности удаляются из кэша.\r\n     *\r\n     * Если в запросе в whereList присутствует ID - кэширование не осуществляется. Запрос на сервер отправляется всегда.\r\n     *\r\n     * @type String\r\n     */\r\n  Session: 'Session',\r\n\r\n    /**\r\n     * Кеширование осуществляется на уровне сессии и сущности. Запрос на сервер отправляетсятолько один раз при старте сессии. При этом в запрос добавляется версия закэшированных данных, если таковые имеются.\r\n     * Результат запроса содержит\r\n     * или данные и версию данных, которые помещаются в кэш;\r\n     * или флаг notModified. В этом случае данные считываются из кэша.\r\n     *\r\n     * Если в запросе в whereList присутствует ID - кэширование не осуществляется. Запрос на сервер отправляется всегда.\r\n     *\r\n     * @type String\r\n     */\r\n  SessionEntity: 'SessionEntity'\r\n}\r\n\r\n/**\r\n * Predefined callback functions, called when indexedDB transaction complete.\r\n * Can be customized after UBCache is created.\r\n * Default implementation will do nothing\r\n * @type {function(e)}\r\n */\r\nUBCache.prototype.onTransactionComplete = function (e) {\r\n    // if (e.target.mode !== 'readonly'){\r\n    //   UB.logDebug('IDB ' + e.target.mode + ' transaction complete');\r\n    // }\r\n}\r\n\r\n/**\r\n * Predefined callback functions, called when indexedDB transaction aborted.\r\n * Can be customized after UBCache is created.\r\n * Default implementation will put error to log\r\n * @type {function(e)}\r\n */\r\nUBCache.prototype.onTransactionAbort = function (e) {\r\n  if (window.console) {\r\n    window.console.error('IDB transaction aborted: ' + (e.target.error.message || e.target.errorCode))\r\n  }\r\n}\r\n/**\r\n * Predefined callback functions, called when error occurred during indexedDB transaction.\r\n * Can be customized after UBCache is created.\r\n * Default implementation will put error to log\r\n * @type {function(e)}\r\n */\r\nUBCache.prototype.onTransactionError = function (e) {\r\n  if (window.console) {\r\n    window.console.error('IDB transaction failed: ' + e.target.errorCode)\r\n  }\r\n}\r\n\r\n/**\r\n * Retrieve data from store by key. If key not found - resolve result to `undefined`\r\n * @method\r\n * @param {String} key\r\n * @param {String} [storeName] default to 'userData'\r\n * @returns {Promise} resolved to key value.\r\n */\r\nUBCache.prototype.get = function (key, storeName = 'userData') {\r\n  let me = this\r\n  return this.ready().then(function (db) {\r\n    let trans = db.transaction([storeName], 'readwrite')\r\n    trans.oncomplete = me.onTransactionComplete\r\n    trans.onabort = me.onTransactionAbort\r\n    trans.onerror = me.onTransactionError\r\n    return new Promise((resolve, reject) => {\r\n      let req = trans.objectStore(storeName).get(key)\r\n      req.onsuccess = function getItemOnSuccess () {\r\n        resolve(req.result)\r\n      }\r\n      req.onerror = function getItemOnError () {\r\n        reject({errMsg: req.error.name})\r\n      }\r\n    })\r\n  })\r\n}\r\n\r\n/**\r\n * Retrieves all values from store. **This is slow operation - try to avoid it**\r\n * @param {String} [storeName] default to 'userData'\r\n * @returns {Promise} resolved to Array of store keys\r\n */\r\nUBCache.prototype.getAllKeys = function (storeName = 'userData') {\r\n  let me = this\r\n  return this.ready().then(function (db) {\r\n    let trans = db.transaction([storeName], 'readwrite')\r\n    trans.oncomplete = me.onTransactionComplete\r\n    trans.onabort = me.onTransactionAbort\r\n    trans.onerror = me.onTransactionError\r\n    return new Promise((resolve, reject) => {\r\n      let results = []\r\n      let req = trans.objectStore(storeName).openCursor()\r\n      req.onsuccess = function (e) {\r\n        let cursor = e.target.result\r\n        if (cursor) {\r\n          results.push(cursor.key)\r\n          cursor.continue()\r\n        } else {\r\n          resolve(results)\r\n        }\r\n      }\r\n      req.onerror = function (e) {\r\n        reject(e.target.result)\r\n      }\r\n    })\r\n  })\r\n}\r\n\r\n/**\r\n * Put one or several values to store (in single transaction).\r\n * Modifies existing values or inserts as new value if nonexistent.\r\n *\r\n * **If value === `undefined` we put null instead, to understand in future get this is null value or key not exist**\r\n * @param {{key: string, value}|Array<{key: string, value}>} data\r\n * @param [storeName] default to 'userData'\r\n * @returns {Promise}\r\n */\r\nUBCache.prototype.put = function (data, storeName = 'userData') {\r\n  let me = this\r\n  return this.ready().then(function (db) {\r\n    let trans = db.transaction([storeName], 'readwrite')\r\n    trans.oncomplete = me.onTransactionComplete\r\n    trans.onabort = me.onTransactionAbort\r\n    trans.onerror = me.onTransactionError\r\n\r\n    return new Promise((resolve, reject) => {\r\n      let req\r\n      if (Array.isArray(data)) {\r\n        data.forEach(function (item, i) {\r\n          req = trans.objectStore(storeName).put(item.value === undefined ? null : item.value, item.key)\r\n          req.onerror = function (e) {\r\n            reject(e.target.result)\r\n          }\r\n          req.onsuccess = function (e) {\r\n            if (i === data.length - 1) {\r\n              resolve(e.target.result)\r\n            }\r\n          }\r\n        })\r\n      } else {\r\n        req = trans.objectStore(storeName).put(data.value === undefined ? null : data.value, data.key)\r\n        req.onsuccess = req.onerror = function (e) {\r\n          resolve(e.target.result)\r\n        }\r\n      }\r\n    })\r\n  })\r\n}\r\n\r\n/**\r\n * Removes all data from the store\r\n * @param {String} [storeName] default to 'userData'\r\n * @returns {Promise}\r\n */\r\nUBCache.prototype.clear = function (storeName = 'userData') {\r\n  let me = this\r\n  return this.ready().then(function (db) {\r\n    let trans = db.transaction([storeName], 'readwrite')\r\n    trans.oncomplete = me.onTransactionComplete\r\n    trans.onabort = me.onTransactionAbort\r\n    trans.onerror = me.onTransactionError\r\n    return new Promise((resolve, reject) => {\r\n      let req = trans.objectStore(storeName).clear()\r\n      req.onsuccess = function (e) {\r\n        resolve(e.target.result)\r\n      }\r\n      req.onerror = function (e) {\r\n        reject(e.target.result)\r\n      }\r\n    })\r\n  })\r\n}\r\n\r\n/**\r\n * Remove data from store.\r\n *\r\n * - If key is *String* - we delete one key;\r\n * - If key is *Array*  - we delete all keys in array;\r\n *\r\n * @method\r\n * @example\r\n\r\n//remove data with key = 'key1' from userData store\r\n$App.cache.remove('key1').then();\r\n\r\n//remove 2 rows: with key = 'key1' and 'key2'  from session store\r\n$App.cache.remove(['key1', 'key2'], UBCache.SESSION).then();\r\n\r\n * @param {String|Array<String>|RegExp} key\r\n * @param [storeName] default to 'userData'\r\n * @returns {Promise}\r\n */\r\nUBCache.prototype.remove = function (key, storeName = 'userData') {\r\n  let me = this\r\n  return this.ready().then(function (db) {\r\n    let trans = db.transaction([storeName], 'readwrite')\r\n    trans.oncomplete = me.onTransactionComplete\r\n    trans.onabort = me.onTransactionAbort\r\n    trans.onerror = me.onTransactionError\r\n    return new Promise((resolve, reject) => {\r\n      let req\r\n      if (typeof key === 'string') {\r\n        req = trans.objectStore(storeName).delete(key)\r\n        req.onsuccess = req.onerror = function (e) {\r\n          resolve(e.target.result)\r\n        }\r\n      } else if (Array.isArray(key)) { // non empty array\r\n        if (key.length) {\r\n          key.forEach(function (item, i) {\r\n            req = trans.objectStore(storeName).delete(item)\r\n            req.onerror = function (e) {\r\n              reject(e.target.result)\r\n            }\r\n            req.onsuccess = function (e) {\r\n              if (i === key.length - 1) {\r\n                resolve(e.target.result)\r\n              }\r\n            }\r\n          })\r\n        } else {\r\n          resolve(true) // empty array passed - nothing to delete\r\n        }\r\n      } else {\r\n        reject({errMsg: 'invalid key for UBCache.remove call'})\r\n      }\r\n    })\r\n  })\r\n}\r\n\r\n/**\r\n * Remove data from store where keys match regExp.\r\n * Internally use {@link UBCache#getAllKeys} so is slow.\r\n * Better to use `remove([key1, ..keyN])`\r\n * @method\r\n *\r\n * @example\r\n\r\nconsole.time('removeIfMach');\r\n$App.cache.removeIfMach(/^admin:ru:cdn_/, 'permanent').then(function(){\r\n   console.timeEnd('removeIfMach');\r\n})\r\n\r\n * @param {RegExp} regExp\r\n * @param [storeName] default to 'userData'\r\n * @returns {Promise}\r\n */\r\nUBCache.prototype.removeIfMach = function (regExp, storeName) {\r\n  let me = this\r\n  return me.getAllKeys(storeName).then(function (allKeys) {\r\n    let machKeys = allKeys.filter((item) => regExp.test(item))\r\n    return me.remove(machKeys, storeName)\r\n  })\r\n}\r\n\r\nmodule.exports = UBCache\r\n\n\n\n// WEBPACK FOOTER //\n// ./UBCache.js","/*\r\n  Rewrited to ES6 from UB 1.12sources by pavel.mash on 12.2016\r\n */\r\n\r\n/* global Blob */\r\nconst _ = require('lodash')\r\nconst EventEmitter = require('./events')\r\nconst ubUtils = require('./utils')\r\nconst i18n = require('./i18n').i18n\r\nconst transport = require('./transport')\r\nconst UBSession = require('@unitybase/base/UBSession')\r\nconst LocalDataStore = require('@unitybase/base/LocalDataStore')\r\nconst UBDomain = require('@unitybase/base/UBDomain')\r\nconst UBCache = require('./UBCache')\r\nconst CryptoJSCore = require('@unitybase/CryptoJS/core')\r\nconst SHA256 = require('@unitybase/CryptoJS/sha256')\r\nconst MD5 = require('@unitybase/CryptoJS/md5')\r\nconst UBNativeDSTUCrypto = require('./UBNativeDSTUCrypto')\r\nconst UBNativeIITCrypto = require('./UBNativeIITCrypto')\r\nconst UBNotifierWSProtocol = require('./UBNotifierWSProtocol')\r\nconst ClientRepository = require('./ClientRepository')\r\n\r\n// regular expression for URLs server not require authorization.\r\nconst NON_AUTH_URLS_RE = /(\\/|^)(models|auth|getAppInfo|downloads)(\\/|\\?|$)/\r\n// regular expression for URLs server not require encryption. Note - all non-auth method not require encryption also\r\nconst NON_ENCRYPTED_URLS_RE = /(\\/|^)(initEncryption)(\\/|\\?|$)/\r\n// all request passed in this timeout to run will be send into one runList server method execution\r\nconst BUFFERED_DELAY = 20\r\n\r\nconst AUTH_METHOD_URL = 'auth'\r\n\r\nconst ANONYMOUS_USER = 'anonymous'\r\nconst AUTH_SCHEMA_FOR_ANONYMOUS = 'None'\r\n\r\n/**\r\n * Default anonymous credential\r\n * @param {UBConnection} conn\r\n * @param {Boolean} isRepeat\r\n * @returns {*}\r\n */\r\nfunction anonymousRequestAuthParams (conn, isRepeat) {\r\n  if (isRepeat) {\r\n    throw new ubUtils.UBError('Access deny')\r\n  } else {\r\n    return Promise.resolve({authSchema: AUTH_SCHEMA_FOR_ANONYMOUS, login: ANONYMOUS_USER})\r\n  }\r\n}\r\n\r\n/**\r\n * @classdesc\r\n *\r\n * Connection to the UnityBase server.\r\n *\r\n * In case host set to value other then `location.host` server must be configured to accept\r\n * <a href=\"https://developer.mozilla.org/en-US/docs/HTTP/Access_control_CORS\">CORS</a> requests.\r\n * Usually it done via \"HTTPAllowOrigin\" server configuration option.\r\n *\r\n * Usage sample:\r\n *\r\n       // connect using UBIP schema\r\n       let conn = new UBConnection({\r\n           host: 'http://127.0.0.1:888',\r\n           requestAuthParams: function(conn, isRepeat){\r\n               if (isRepeat){\r\n                   throw new UB.UBAbortError('invalid credential')\r\n               } else {\r\n                   return Promise.resolve({authSchema: 'UBIP', login: 'admin'})\r\n               }\r\n            }\r\n       });\r\n       conn.query({entity: 'uba_user', method: 'select', fieldList: ['ID', 'name']}).then(UB.logDebug);\r\n\r\n       // Anonymous connect. Allow access to entity methods, granted by ELS rules to `Anonymous` role\r\n       // Request below will be success if we grant a `ubm_navshortcut.select` to `Anonymous` on the server side\r\n       let conn = new UBConnection({\r\n         host: 'http://127.0.0.1:888'\r\n       });\r\n       conn.query({entity: 'ubm_navshortcut', method: 'select', fieldList: ['ID', 'name']}).then(UB.logDebug);\r\n\r\n * This class mixes an EventEmitter, so you can subscribe for `authorized` and `authorizationFail` events:\r\n *\r\n       conn.on('authorizationFail', function(reason){\r\n            // indicate user credential is wrong\r\n       });\r\n\r\n       conn.on('authorized', function(ubConnection, session, authParams){console.debug(arguments)} );\r\n *\r\n * @class\r\n * @mixes EventEmitter\r\n * @param {Object} connectionParams connection parameters\r\n * @param {String} connectionParams.host UnityBase server host\r\n * @param {String} [connectionParams.appName='/'] UnityBase application to connect to\r\n * @param {Function} [connectionParams.requestAuthParams] Handler to log in.\r\n *      Must return promise & fulfill it by authorization parameters: {authSchema: authType, login: login, password: password }\r\n *          for openIDConnect must be fulfilled with  {data: uData, secretWord: ???}\r\n *      Called with arguments: {UBConnection} conn, {Boolean} isRepeat;\r\n *      isRepeat === true in case first auth request is invalid.\r\n *\r\n *      For Anonymous requests can be either omitted, or return promise, resolved to  `{authSchema: 'None'}`\r\n * @param {String} [connectionParams.protocol] either 'https' or 'http' (default)\r\n */\r\nfunction UBConnection (connectionParams) {\r\n  let host = connectionParams.host || 'http://localhost:888'\r\n  let appName = connectionParams.appName || '/'\r\n  let requestAuthParams = connectionParams.requestAuthParams\r\n  let baseURL, serverURL\r\n  /*\r\n   * Current session (Promise). Result of {@link UBConnection#auth auth} method\r\n   * {@link UBConnection#xhr} use this promise as a first `then` in call chain. In case of 401 response\r\n   * authPromise recreated.\r\n   */\r\n  let currentSession\r\n\r\n  EventEmitter.call(this)\r\n  _.assign(this, EventEmitter.prototype)\r\n\r\n  /**\r\n   * WebSocket `ubNotifier` protocol instance\r\n   * @type {UBNotifierWSProtocol}\r\n   */\r\n  this.ubNotifier = null\r\n\r\n  /**\r\n   * Application settings transferred form a server\r\n   * @type {{}}\r\n   */\r\n  this.appConfig = {}\r\n\r\n  /**\r\n   * The preferred (used in previous user session if any or a default for application) locale\r\n   * @type {string}\r\n   */\r\n  this.preferredLocale = 'en'\r\n\r\n  /**\r\n   * Domain information. Initialized after promise, returned by by function {@link UBConnection#getDomainInfo getDomainInfo} isresolved\r\n   * @type {UBDomain}\r\n   */\r\n  this.domain = null\r\n\r\n  if (appName.charAt(0) !== '/') {\r\n    appName = '/' + appName\r\n  }\r\n  if (!requestAuthParams) {\r\n    requestAuthParams = anonymousRequestAuthParams\r\n  }\r\n  serverURL = host + appName\r\n    /** UB Server URL with protocol and host.\r\n     * @type {string}\r\n     * @readonly\r\n     */\r\n  this.serverUrl = serverURL\r\n  baseURL = (window.location.origin === host) ? appName : serverURL\r\n  if (baseURL.charAt(baseURL.length - 1) !== '/') baseURL = baseURL + '/'\r\n    /**\r\n     * The base of all urls of your requests. Will be prepend to all urls while call UB.xhr\r\n     * @type {String}\r\n     * @readonly\r\n     */\r\n  this.baseURL = baseURL\r\n    /** UB application name\r\n     * @type {String}\r\n     * @readonly\r\n     */\r\n  this.appName = appName\r\n\r\n    /** Result of last key agreement. Resolved to object,\r\n     * contain time when it was done inside\r\n     * - **doneTime** property\r\n     *  Usually this is result of UBConnection.doKeyExchange method call\r\n     * @private\r\n     * @type {Promise}\r\n     */\r\n  this.exchangeKeysPromise = null\r\n\r\n    /** UBNativeDSTUCrypto instance used for encryption\r\n     * @type {UBNativeDSTUCrypto}\r\n     */\r\n  this.channelEncryptor = null\r\n\r\n    /** UBNativeIITCrypto instance used for PKI relative operations (read keys / signatures)\r\n     * @private\r\n     * @readonly\r\n     * @type {UBNativeIITCrypto}\r\n     */\r\n  this._pki = null\r\n\r\n    /**\r\n     * Check current connection use PKI\r\n     * @protected\r\n     * @returns {boolean}\r\n     */\r\n  this.isPKIReady = function () {\r\n    return this._pki !== null\r\n  }\r\n\r\n  this.cache = null\r\n\r\n  /**\r\n   * Last successful login name. Filled AFTER first 401 response\r\n   * @type {String}\r\n   */\r\n  this.lastLoginName = ''\r\n  /**\r\n   * Cache flag to enable a hack appending the current timestamp\r\n   * to your requests to prevent IE from caching them and always returning the same result.\r\n   * If \"true\", will set the param with the name \"_\"\r\n   * If a string, will use it as the param name\r\n   * @type {Boolean|String}\r\n   */\r\n  this.useCacheForXHR = window && (window.ActiveXObject || 'ActiveXObject' in window)\r\n\r\n  this._bufferedRequests = []\r\n  this._bufferTimeoutID = 0\r\n\r\n  /**\r\n   * Is user currently logged in. There is no guaranty what session actually exist in server.\r\n   * @returns {boolean}\r\n   */\r\n  this.isAuthorized = function () {\r\n    return (currentSession !== undefined)\r\n  }\r\n  /**\r\n   * Return current user logon name or 'anonymous' in case not logged in\r\n   * @returns {String}\r\n   */\r\n  this.userLogin = function () {\r\n    return this.userData('login')\r\n  }\r\n\r\n  /**\r\n   * Return current user language or 'en' in case not logged in\r\n   * @returns {String}\r\n   */\r\n  this.userLang = function () {\r\n    return this.userData('lang')\r\n  }\r\n\r\n  /**\r\n   * Return custom data for logged in user, or {lang: 'en', login: 'anonymous'} in case not logged in\r\n   *\r\n   * If key is provided - return only key part of user data:\r\n   *\r\n   *      $App.connection.userData('lang');\r\n   *      // or the same but dedicated alias\r\n   *      $App.connection.userLang()\r\n   *\r\n   * @param {String} [key] Optional key\r\n   * @returns {*}\r\n   */\r\n  this.userData = function (key) {\r\n    let uData = this.isAuthorized()\r\n      ? currentSession.userData\r\n      : { lang: 'en', login: ANONYMOUS_USER }\r\n\r\n    return key ? uData[ key ] : uData\r\n  }\r\n\r\n  /**\r\n   * The starter method for all authorized requests to UB server. Return authorization promise resolved to {@link UBSession}.\r\n   * In case unauthorized:\r\n   *\r\n   *  - call requestAuthParams method passed to UBConnection constructor to retrieve user credentials\r\n   *  - call {@link UBConnection#doAuth} method\r\n   *\r\n   * Used inside {@link UBConnection#xhr}, therefore developer rarely call it directly.\r\n   * @method\r\n   * @param {boolean} [isRepeat] in case user provide wrong credential - we must show logon window\r\n   * @returns {Promise<UBSession>} Resolved to {UBSession} if auth success or rejected to `{errMsg: string, errCode: number, errDetails: string}` if fail\r\n   */\r\n  this.authorize = function (isRepeat) {\r\n    let me = this\r\n    if (currentSession) return Promise.resolve(currentSession)\r\n\r\n    this.exchangeKeysPromise = null\r\n    return requestAuthParams(this, isRepeat)\r\n      .then(function (authParams) {\r\n        return me.doAuth(authParams).then(function (session) {\r\n          currentSession = session\r\n          /**\r\n           * Fired for {@link UBConnection} instance after success authorization. Accept 3 args (conn: UBConnection, session: UBSession, authParams)\r\n           * @event authorized\r\n           */\r\n          me.emit('authorized', me, session, authParams)\r\n          return session\r\n        }).catch(function (reason) {\r\n          if (!reason || !(reason instanceof ubUtils.UBAbortError)) {\r\n            /**\r\n             * Fired for {@link UBConnection} instance in case of bad authorization Accept 1 args (reason)\r\n             * @event authorizationFail\r\n             */\r\n            me.emit('authorizationFail', reason)\r\n          }\r\n          return me.authorize(true)\r\n        })\r\n      })\r\n  }\r\n\r\n    /**\r\n     * Clear current user authorization promise. Next request repeat authorization\r\n     * @private\r\n     */\r\n  this.authorizationClear = function () {\r\n    this.lastLoginName = this.userLogin()\r\n    currentSession = undefined\r\n  }\r\n\r\n  /**\r\n   * UBIP Auth schema implementation\r\n   * @param authParams\r\n   * @returns {Promise}\r\n   */\r\n  this.authHandshakeUBIP = function (authParams) {\r\n    if (!authParams.login) {\r\n      return Promise.reject({errMsg: 'invalid user name'})\r\n    }\r\n\r\n    return this.post(AUTH_METHOD_URL, '', {headers: {Authorization: authParams.authSchema + ' ' + authParams.login}})\r\n  }\r\n\r\n  /**\r\n   * openID Connect auth schema.\r\n   * This function act as a proxy but change authSchema back to 'UB' for authorization token generation\r\n   * @param authParams\r\n   * @return {*}\r\n   */\r\n  this.authHandshakeOpenIDConnect = function (authParams) {\r\n    return Promise.resolve(authParams).then(function (authParams) {\r\n      authParams.authSchema = 'UB'\r\n      return authParams\r\n    })\r\n  }\r\n\r\n  /**\r\n   * UB Auth schema implementation\r\n   * @param authParams\r\n   * @returns {Promise}\r\n   */\r\n  this.authHandshakeUB = function (authParams) {\r\n    let me = this\r\n    let secretWord\r\n\r\n    if (!authParams.login || !authParams.password) {\r\n      return Promise.reject({errMsg: 'invalid user name or password'})\r\n    }\r\n\r\n    return this.post(AUTH_METHOD_URL, '', {\r\n      params: {\r\n        AUTHTYPE: authParams.authSchema,\r\n        userName: authParams.login\r\n      }\r\n    }).then(function (resp) {\r\n      let serverNonce, pwdHash, pwdForAuth\r\n      let request = {\r\n        params: {\r\n          AUTHTYPE: authParams.authSchema,\r\n          userName: authParams.login,\r\n          password: ''\r\n        }\r\n      }\r\n      let clientNonce = SHA256(new Date().toISOString().substr(0, 16)).toString()\r\n      request.params.clientNonce = clientNonce\r\n      if (resp.data.connectionID) {\r\n        request.params.connectionID = resp.data.connectionID\r\n      }\r\n      // LDAP AUTH?\r\n      let realm = resp.data.realm\r\n      if (realm) {\r\n        serverNonce = resp.data.nonce\r\n        if (!serverNonce) {\r\n          throw new Error('invalid LDAP auth response')\r\n        }\r\n        if (resp.data.useSasl) {\r\n          pwdHash = MD5(authParams.login.split('\\\\')[1].toUpperCase() + ':' + realm + ':' + authParams.password)\r\n                    // we must calculate md5(login + ':' + realm + ':' + password) in binary format\r\n          pwdHash.concat(CryptoJSCore.enc.Utf8.parse(':' + serverNonce + ':' + clientNonce))\r\n          pwdForAuth = MD5(pwdHash).toString()\r\n          secretWord = pwdForAuth // :( medium unsecured\r\n        } else {\r\n          pwdForAuth = window.btoa(authParams.password)\r\n          secretWord = pwdForAuth // todo -  very unsecured!!\r\n        }\r\n      } else {\r\n        serverNonce = resp.data.result\r\n        if (!serverNonce) {\r\n          throw new Error('invalid auth response')\r\n        }\r\n        pwdHash = SHA256('salt' + authParams.password).toString()\r\n        let appForAuth = appName === '/' ? '/' : appName.replace(/\\//g, '')\r\n        pwdForAuth = SHA256(appForAuth.toLowerCase() + serverNonce + clientNonce + authParams.login + pwdHash).toString()\r\n        secretWord = pwdHash\r\n      }\r\n      request.params.password = pwdForAuth\r\n      return me.post(AUTH_METHOD_URL, '', request).then(function (response) {\r\n        response.secretWord = secretWord\r\n        return response\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * CERT auth schema implementation\r\n   * @param authParams\r\n   * @returns {Promise}\r\n   */\r\n  this.authHandshakeCERT = function (authParams) {\r\n    let me = this\r\n    let pki, secretWord\r\n    let urlParams = {\r\n      AUTHTYPE: authParams.authSchema\r\n    }\r\n\r\n    if (authParams.login) {\r\n      urlParams.userName = authParams.login\r\n    }\r\n    if (authParams.password) {\r\n      urlParams.password = authParams.password\r\n    }\r\n    if (authParams.registration) {\r\n      urlParams.registration = authParams.registration\r\n    }\r\n\r\n    return me.pki().then(function (pkiInit) {\r\n      pki = pkiInit\r\n            // noinspection JSCheckFunctionSignatures\r\n      return pki.readPK(me)\r\n    }).then(function (certInfo) {\r\n      let reqData = certInfo.ownIITCert\r\n            // in case we have different certificates for signing and encryption - pass them all\r\n      if (certInfo.ownIITEncryptCert && certInfo.ownIITEncryptCert !== '') {\r\n        reqData = [certInfo.ownIITCert, certInfo.ownIITEncryptCert, certInfo.ownIITEncryptSignature].join(' ')\r\n      }\r\n      return me.xhr({\r\n        url: AUTH_METHOD_URL,\r\n        method: 'POST',\r\n        headers: {'Content-Type': 'application/octet-stream'},\r\n        params: urlParams,\r\n        responseType: 'arraybuffer',\r\n        data: reqData\r\n      })\r\n    }).then(function () {\r\n      throw new ubUtils.UBError('msgInvalidCertAuth')\r\n    }, function (resp) {\r\n      let aValues, authData, serverMessage\r\n\r\n      if ((resp instanceof Error) || (resp instanceof ubUtils.UBError)) {\r\n        throw resp\r\n      }\r\n      if (resp.status !== 401) {\r\n        if (resp.data && resp.data instanceof ArrayBuffer && resp.data.byteLength > 1) {\r\n          try {\r\n            // noinspection JSCheckFunctionSignatures\r\n            let respObj = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(resp.data)))\r\n            if ((respObj.errCode === 65 || respObj.errCode === 0) && respObj.errMsg && /<<<.*>>>/.test(respObj.errMsg)) {\r\n              serverMessage = respObj.errMsg.match(/<<<(.*)>>>/)[1]\r\n            }\r\n          } catch (err) {}\r\n          if (serverMessage) throw new ubUtils.UBError(serverMessage)\r\n        }\r\n        throw new ubUtils.UBError('msgInvalidCertAuth')\r\n      }\r\n\r\n      // begin phrase 2 of auth.\r\n      // wait for response WWW-Authenticate: CERT connectionId server_certificate\r\n      // and encrypted by client certificate secret word in body\r\n      authData = resp.headers('WWW-Authenticate')\r\n      if (!authData && (authData.substr(0, 5) !== 'CERT ')) {\r\n        throw new Error('invalidCertAuthRespAuthType')\r\n      }\r\n      aValues = authData.split(' ')\r\n      if (aValues.length !== 3) throw new Error('invalidCertAuthResponse')\r\n      urlParams.CONNECTIONID = aValues[1]\r\n      return pki.setRecipientCertificate(aValues[2]).then(function () {\r\n        return ubUtils.base64FromAny(resp.data)\r\n      }).then(function (envelop) {\r\n        if (!envelop || (envelop === '')) { throw new Error('invalidCertAuthEnvelop') }\r\n        // decrypt secret word using client private key\r\n        return pki.decryptEnvelope(envelop, true)\r\n      }).then(function (secretWordB64) {\r\n        // memorize it\r\n        secretWord = window.atob(secretWordB64)\r\n        // encrypt secret word with server public key\r\n        return pki.encryptEnvelope(secretWordB64, true)\r\n      }).then(function (encryptEnvelopeRes) {\r\n        let envelop = ubUtils.base64toArrayBuffer(encryptEnvelopeRes)\r\n        if (envelop.byteLength === 0) { throw new Error('invalidCertAuthEnvelopOut') }\r\n        // repeat request with encrypted secret word\r\n        return me.xhr({\r\n          url: AUTH_METHOD_URL,\r\n          method: 'POST',\r\n          headers: {'Content-Type': 'application/octet-stream'},\r\n          params: urlParams,\r\n          data: envelop\r\n        })\r\n      }).then(function (response) {\r\n        response.secretWord = secretWord\r\n        return response\r\n      })\r\n    }).then( // a-la fin\r\n      function () { if (pki) pki.closePK() },\r\n      function () { if (pki) pki.closePK() }\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Do authentication in UnityBase server. Usually called from UBConnection #authorize method in case authorization expire or user not authorized.\r\n   * Resolve to {@link UBSession} session object.\r\n   *\r\n   * @private\r\n   * @param {Object} authParams\r\n   * @param {String} [authParams.authSchema] Either 'UB' (default) or 'CERT'. On case of CERT UBDesktop service NPI extension must be installed in browser\r\n   * @param {String} [authParams.login] Optional login\r\n   * @param {String} [authParams.password] Optional password\r\n   * @returns {Promise} Authentication promise. Resolved to {@link UBSession} is auth success or rejected to {errMsg: string, errCode: number, errDetails: string} if fail\r\n   */\r\n  this.doAuth = function (authParams) {\r\n    let me = this\r\n    let promise\r\n\r\n    authParams.authSchema = authParams.authSchema || 'UB'\r\n    if (me.isAuthorized()) {\r\n      return Promise.reject({errMsg: 'invalid auth call', errDetails: 'contact developers'})\r\n    }\r\n\r\n    switch (authParams.authSchema) {\r\n      case AUTH_SCHEMA_FOR_ANONYMOUS:\r\n        promise = Promise.resolve({data: {result: '0+0', uData: JSON.stringify({login: ANONYMOUS_USER})}, secretWord: ''})\r\n        break\r\n      case 'UB':\r\n        promise = me.authHandshakeUB(authParams)\r\n        break\r\n      case 'CERT':\r\n        promise = me.authHandshakeCERT(authParams)\r\n        break\r\n      case 'UBIP':\r\n        promise = me.authHandshakeUBIP(authParams)\r\n        break\r\n      case 'OpenIDConnect':\r\n        promise = me.authHandshakeOpenIDConnect(authParams)\r\n        break\r\n      case 'Negotiate':\r\n        promise = me.post(AUTH_METHOD_URL, '', {\r\n          params: {\r\n            USERNAME: '',\r\n            AUTHTYPE: authParams.authSchema\r\n          }\r\n        }).then(function (resp) {\r\n          resp.secretWord = resp.data.logonname\r\n          return resp\r\n        })\r\n        break\r\n      default:\r\n        promise = Promise.reject({errMsg: 'invalid authentication schema ' + authParams.authSchema})\r\n        break\r\n    }\r\n    promise = promise.then(function (authResponse) {\r\n      let ubSession = new UBSession(authResponse.data, authResponse.secretWord, authParams.authSchema)\r\n      let userData = ubSession.userData\r\n      if (!userData.lang || me.appConfig.supportedLanguages.indexOf(userData.lang) === -1) {\r\n        userData.lang = me.appConfig.supportedLanguages[0]\r\n      }\r\n      return ubSession\r\n    }, function (rejectReason) {\r\n      let errInfo = {}\r\n      if (!(rejectReason instanceof Error)) {\r\n        if (rejectReason.data) {\r\n          errInfo = {\r\n            errMsg: rejectReason.data.errMsg,\r\n            errCode: rejectReason.data.errCode,\r\n            errDetails: rejectReason.data.errMsg\r\n          }\r\n        }\r\n        if (rejectReason.status === 403) {\r\n          errInfo.errMsg = (authParams.authSchema === 'UB') ? 'msgInvalidUBAuth' : 'msgInvalidCertAuth'\r\n        } else {\r\n          if (!errInfo.errMsg) { errInfo.errMsg = 'unknownError' } // internalServerError\r\n        }\r\n        if (rejectReason.status === 0) {\r\n          errInfo.errDetails = 'network error'\r\n        }\r\n        if (/<<<.*>>>/.test(errInfo.errMsg)) {\r\n          errInfo.errMsg = errInfo.errMsg.match(/<<<(.*)>>>/)[1]\r\n        }\r\n\r\n        let codeMsg = me.serverErrorByCode(errInfo.errCode)\r\n        if (codeMsg) {\r\n          errInfo.errDetails = codeMsg + ' ' + errInfo.errDetails\r\n          if (i18n(codeMsg) !== codeMsg) {\r\n            errInfo.errMsg = codeMsg\r\n          }\r\n        }\r\n\r\n        throw new ubUtils.UBError(errInfo.errMsg, errInfo.errDetails, errInfo.errCode)\r\n      } else {\r\n        throw rejectReason // rethrow error\r\n      }\r\n    })\r\n    return promise\r\n  }\r\n\r\n  this.recordedXHRs = []\r\n    /**\r\n     * Set this to `true` to memorize all requests to this.recordedXHRs array (for debug only!).\r\n     * @type {Boolean}\r\n     */\r\n  this.recorderEnabled = false\r\n}\r\n\r\n/**\r\n * Initialize client cache. Called from application after obtain userDbVersion (in case of Ext-based client called from {@link UB.core.UBApp#launch}.\r\n *\r\n * - recreate Indexed Db database if version changed\r\n * - create instance of UBCache (accessible via {@link UBConnection#cache UBConnection.cache} property) and clear UBCache.SESSION store.\r\n *\r\n * @param {Number} userDbVersion Indexed DB database version required for current application\r\n * @returns {Promise}\r\n */\r\nUBConnection.prototype.initCache = function (userDbVersion) {\r\n  let me = this\r\n    /**\r\n     * @property {UBCache} cache\r\n     * @readonly\r\n     * @type {UBCache}\r\n     */\r\n  me.cache = new UBCache(me.baseURL, userDbVersion)\r\n    /**\r\n     * List of keys, requested in the current user session.\r\n     * Cleared each time login done\r\n     * @protected\r\n     * @property {Object} cachedSessionEntityRequested\r\n     */\r\n  me.cachedSessionEntityRequested = {}\r\n    // clear use session store\r\n  return me.cache.clear(UBCache.SESSION)\r\n}\r\n\r\n/**\r\n * Calculate cache key for request. This key is used to store data inside UBCache\r\n * @param {String} root This is usually entity name\r\n * @param {Array<string>} [attributes] if present - add attributes hash. This is usually array of entity attributes we want to put inside cache\r\n * @returns {String}\r\n */\r\nUBConnection.prototype.cacheKeyCalculate = function (root, attributes) {\r\n  let me = this\r\n  let keyPart = [me.userLogin().toLowerCase(), me.userLang(), root]\r\n  if (Array.isArray(attributes)) {\r\n    keyPart.push(MD5(JSON.stringify(attributes)).toString())\r\n  }\r\n  return keyPart.join('#').replace(/[\\\\:\\.]/g, '#') // replace all :, \\ -> #;\r\n}\r\n\r\n/**\r\n * Refresh all cache occurrence for root depending on cacheType:\r\n *\r\n * - if `Session` - clear indexedDB for this root.\r\n * - if `SessionEntity` - remove entry in {@link UBConnection#cachedSessionEntityRequested}\r\n * - else - do nothing\r\n * @param {String} root Root part of cache key. The same as in {@link UBConnection#cacheKeyCalculate}\r\n * @param {UBCache.cacheTypes} cacheType\r\n * @returns {Promise}\r\n */\r\nUBConnection.prototype.cacheOccurrenceRefresh = function (root, cacheType) {\r\n  let me = this\r\n  let cacheKey, machKeys, machRe\r\n  let promise = Promise.resolve(true)\r\n  let domain, mixin, domainMixin\r\n\r\n  if (cacheType === UBCache.cacheTypes.Session || cacheType === UBCache.cacheTypes.SessionEntity) {\r\n    domain = this.domain.get(root)\r\n    if (domain && domain.hasMixin('unity')) {\r\n      mixin = domain.mixin('unity')\r\n      domainMixin = this.domain.get(mixin.entity)\r\n      if (domainMixin && (mixin.entity !== root) && (domainMixin.cacheType !== UBCache.cacheTypes.None)) {\r\n        promise = promise.then(function () {\r\n          me.cacheOccurrenceRefresh(mixin.entity, domainMixin.cacheType)\r\n        })\r\n      }\r\n    }\r\n    cacheKey = me.cacheKeyCalculate(root)\r\n    machRe = new RegExp('^' + cacheKey)\r\n    machKeys = Object.keys(me.cachedSessionEntityRequested).filter(function (item) {\r\n      return machRe.test(item)\r\n    })\r\n    machKeys.forEach(function (key) {\r\n      delete me.cachedSessionEntityRequested[key]\r\n    })\r\n    if (cacheType === UBCache.cacheTypes.Session) {\r\n      promise = promise.then(function () {\r\n        me.cache.removeIfMach(machRe, UBCache.SESSION)\r\n      })\r\n    }\r\n  }\r\n  return promise\r\n}\r\n\r\n/**\r\n * Remove all cache occurrence for root depending on cacheType:\r\n *\r\n * - clear indexedDB for this root.\r\n * - remove entry in {@link UBConnection#cachedSessionEntityRequested}\r\n\r\n * @param {String} root Root part of cache key. The same as in {@link UBConnection#cacheKeyCalculate}\r\n * @param {String} cacheType One of {@link UBCache#cacheTypes}\r\n * @returns {Promise}\r\n */\r\nUBConnection.prototype.cacheOccurrenceRemove = function (root, cacheType) {\r\n  let me = this\r\n\r\n  let cacheKey = me.cacheKeyCalculate(root)\r\n  let machRe = new RegExp('^' + cacheKey)\r\n  let machKeys = Object.keys(me.cachedSessionEntityRequested).filter(function (item) {\r\n    return machRe.test(item)\r\n  })\r\n  machKeys.forEach(function (key) {\r\n    delete me.cachedSessionEntityRequested[key]\r\n  })\r\n  let cacheStore = (cacheType === UBCache.cacheTypes.Session) ? UBCache.SESSION : UBCache.PERMANENT\r\n  return me.cache.removeIfMach(machRe, cacheStore)\r\n}\r\n\r\n/**\r\n * Clear all local cache (indexedDB session & permanent and UBConnection.cachedSessionEntityRequested)\r\n * @returns {Promise}\r\n */\r\nUBConnection.prototype.cacheClearAll = function () {\r\n  let me = this\r\n  Object.keys(me.cachedSessionEntityRequested).forEach(function (item) {\r\n    delete me.cachedSessionEntityRequested[item]\r\n  })\r\n  return Promise.all([me.cache.clear(UBCache.SESSION), me.cache.clear(UBCache.PERMANENT)])\r\n}\r\n\r\n/**\r\n * Return instance of UBNativeIITCrypto for PKI operation\r\n * @returns {Promise<UBNativeIITCrypto>}\r\n */\r\nUBConnection.prototype.pki = function () {\r\n  let me = this\r\n  return new Promise(function(resolve, reject){\r\n    if (!me._pki) {\r\n      me._pki = new UBNativeIITCrypto()\r\n      me._pkiInit = me._pki.init()\r\n    }\r\n    me._pkiInit.then(function () {\r\n      resolve(me._pki)\r\n    }, function (reason) {\r\n      reject(reason)\r\n    })\r\n  })\r\n}\r\n\r\n/**\r\n * Perform key exchange in case of encrypted communication\r\n * @param session\r\n * @returns {Promise}\r\n */\r\nUBConnection.prototype.exchangeKeys = function (session) {\r\n  let doneAt, now\r\n  let me = this\r\n  if (!me.exchangeKeysPromise) {\r\n    me.exchangeKeysPromise = this.doKeyExchange(session)\r\n  } else {\r\n        // check session key is near to expire. do key exchange if yes\r\n    if (me.exchangeKeysPromise.isFulfilled() && me.encryptionKeyLifetime > 0) {\r\n      doneAt = me.exchangeKeysPromise.valueOf().doneTime\r\n      now = (new Date()).getTime()\r\n      if ((now - doneAt) / 1000 > this.encryptionKeyLifetime - 10) {\r\n        me.exchangeKeysPromise = me.doKeyExchange(session)\r\n      }\r\n    }\r\n  }\r\n  return me.exchangeKeysPromise\r\n}\r\n/**\r\n * Shortcut method to perform authorized `GET` request to application we connected\r\n * @param {string} url Relative or absolute URL specifying the destination of the request\r\n * @param {Object=} [config] Optional configuration object as in {xhr}\r\n * @returns {Promise} Future object\r\n */\r\nUBConnection.prototype.get = function (url, config) {\r\n  return this.xhr(_.assign({}, config, {\r\n    method: 'GET',\r\n    url: url\r\n  }))\r\n}\r\n\r\n/**\r\n * Shortcut method to perform authorized `POST` request to application we connected\r\n * @param {string} url Relative or absolute URL specifying the destination of the request\r\n * @param {*} data Request content\r\n * @param {Object=} [config] Optional configuration object as in {xhr}\r\n * @returns {Promise} Future object\r\n */\r\nUBConnection.prototype.post = function (url, data, config) {\r\n  return this.xhr(_.assign({}, config, {\r\n    method: 'POST',\r\n    url: url,\r\n    data: data\r\n  }))\r\n}\r\n\r\n/**\r\n * Shortcut method to perform authorized/encrypted request to application we connected.\r\n * Will:\r\n *\r\n *  - add Authorization header for non-anonymous sessions\r\n *  - add {@link UBConnection#baseURL} to config.url\r\n *  - call {@link ub-core.xhr}\r\n *  - in case server return 401 clear current authorization,\r\n *  call {UBConnection#authorize) and repeat the request\r\n *\r\n * @param config Request configuration as described in {transport.xhr}\r\n * @return {Promise}\r\n */\r\nUBConnection.prototype.xhr = function (config) {\r\n  let me = this\r\n  let cfg = _.assign({headers: {}}, config)\r\n  let url = cfg.url\r\n  let isBase64 = false\r\n  let promise\r\n\r\n  if (me.recorderEnabled) {\r\n    me.recordedXHRs.push(config)\r\n  }\r\n    // prepend baseURl only if not already prepended\r\n  if (url.length < me.baseURL.length || url.substring(0, me.baseURL.length) !== me.baseURL) {\r\n    cfg.url = me.baseURL + cfg.url\r\n  }\r\n\r\n  if (NON_AUTH_URLS_RE.test(url)) { // request not require authentication - pass is as is\r\n    promise = transport.xhr(cfg)\r\n  } else {\r\n    promise = me.authorize()\r\n    if (me.trafficEncryption && !NON_ENCRYPTED_URLS_RE.test(url)) {\r\n      promise = promise.then(function (session) {\r\n        return me.exchangeKeys(session)\r\n      }).then(function () {\r\n        let dataType = typeof cfg.data\r\n        // string and stringified objects is not need to be base64 encoded. Anything else - must\r\n        if ((dataType === 'string') || ((dataType === 'object') && !(cfg.data instanceof Blob) && !(cfg.data.byteLength))) {\r\n          return JSON.stringify(cfg.data)\r\n        } else {\r\n          isBase64 = true\r\n          return ubUtils.base64FromAny(cfg.data)\r\n        }\r\n      }).then(function (sendData) {\r\n        cfg.transformResponse = decryptResponse\r\n        cfg.responseType = 'arraybuffer'\r\n        cfg.transformRequest = function (data) { return data } // NOP\r\n        if (sendData) {\r\n          let compress = (sendData.length > 1000)\r\n          return me.channelEncryptor.encryptToArray(sendData, isBase64, compress)\r\n            .then(function (encryptToArrayRes) {\r\n              cfg.headers['Content-Encoding'] = compress ? 'UBEZ' : 'UBE'\r\n              cfg.data = new Uint8Array(encryptToArrayRes)\r\n            })\r\n        } else {\r\n          return true\r\n        }\r\n      })\r\n    }\r\n    promise = promise.then(function () {\r\n            // we must repeat authorize to obtain new session key ( because key exchange may happens before)\r\n      return me.authorize().then(/** @param {UBSession} session */ function (session) {\r\n        let head = session.authHeader()\r\n        if (head) cfg.headers.Authorization = head // do not add header for anonymous session\r\n        return transport.xhr(cfg)\r\n      })\r\n    }).catch(function (reason) {  // in case of 401 - do auth and repeat request\r\n      let errMsg = ''\r\n      if (reason.status === 401) {\r\n        ubUtils.logDebug('unauth: %o', reason)\r\n        if (me.isAuthorized()) {\r\n          me.authorizationClear()\r\n        }\r\n                // reason.config.url: \"/bla-bla/logout\"\r\n        if (reason.config.url && /\\/logout/.test(reason.config.url)) {\r\n          me.lastLoginName = ''\r\n        } else {\r\n          transport.xhr.allowRequestReiteration() // prevent a monkeyRequestsDetected error during relogon [UB-1699]\r\n          return me.xhr(config)\r\n        }\r\n      }\r\n\r\n      if (reason.data && reason.data.hasOwnProperty('errCode')) { // this is server side error response\r\n        let errCode = reason.data.errCode\r\n        let errDetails = errMsg = reason.data.errMsg\r\n\r\n        if (/<<<.*>>>/.test(errMsg)) { // this is custom error\r\n          errMsg = i18n(errMsg.match(/<<<(.*)>>>/)[1]) // extract rear message and translate\r\n        }\r\n                /**\r\n                 * Fired for {@link UBConnection} instance in case user password is expired. The only valid endpoint after this is `changePassword`\r\n                 * @event passwordExpired\r\n                 */\r\n        if ((errCode === 72) && me.emit('passwordExpired')) {\r\n          throw new ubUtils.UBAbortError()\r\n        }\r\n        throw new ubUtils.UBError(errMsg, errDetails, errCode)\r\n      } else {\r\n        throw reason //! Important - rethrow the reason is important. Do not create a new Error here\r\n      }\r\n    })\r\n  }\r\n  return promise\r\n\r\n  function decryptResponse (data, headers) {\r\n    let encoding = (headers('content-encoding') || '').toUpperCase()\r\n    let compressed = encoding === 'UBEZ'\r\n    let encrypted = compressed || (encoding === 'UBE')\r\n    let jsonContent = (headers('content-type') || '').indexOf('json') >= 0\r\n    let resAsBase64 = (config.responseType === 'arraybuffer')\r\n\r\n    let promise = Promise.resolve(data)\r\n    if (encrypted) {\r\n      promise = promise.then(function (dataPromise) {\r\n        return me.channelEncryptor.decryptArr(dataPromise, resAsBase64, compressed)\r\n      })\r\n    }\r\n    return promise.then(function (dataPromise) {\r\n      if (config.responseType === 'arraybuffer') {\r\n        dataPromise = ubUtils.base64toArrayBuffer(dataPromise)\r\n      }\r\n      if (typeof dataPromise === 'string' && jsonContent) {\r\n        try {\r\n          dataPromise = JSON.parse(dataPromise)\r\n        } catch (err) {\r\n          console.log(dataPromise)\r\n          throw err\r\n        }\r\n      }\r\n      return dataPromise\r\n    })\r\n  }\r\n}\r\n/**\r\n * Base64 encoded server certificate\r\n * @property {String} serverCertificate\r\n * @readonly */\r\n/** Lifetime (in second) of session encryption\r\n * @property {Number} encryptionKeyLifetime\r\n * @readonly */\r\n/**\r\n * Possible server authentication method\r\n * @property {Array.<string>} authMethods\r\n * @readonly */\r\n/**\r\n * Retrieve application information. Usually this is first method developer must call after create connection\r\n * @method\r\n * @returns {Promise}  Promise resolved to result of getAppInfo method\r\n */\r\nUBConnection.prototype.getAppInfo = function () {\r\n  let me = this\r\n  return me.get('getAppInfo') // non-auth request\r\n    .then(function (resp) {\r\n      let appInfo = resp.data\r\n      /** Is server require content encryption\r\n       * @property {Boolean} trafficEncryption\r\n       * The base of all urls of your requests. Will be prepend to all urls.\r\n       * @readonly */\r\n      Object.defineProperty(me, 'trafficEncryption', {enumerable: true, writable: false, value: appInfo.trafficEncryption || false})\r\n      /** The server certificate for cryptographic operations (base46 encoded)\r\n       * @property {Boolean} serverCertificate\r\n       * @readonly */\r\n      Object.defineProperty(me, 'serverCertificate', {enumerable: true, writable: false, value: appInfo.serverCertificate || ''})\r\n      Object.defineProperty(me, 'encryptionKeyLifetime', {enumerable: true, writable: false, value: appInfo.encryptionKeyLifetime || 0})\r\n      Object.defineProperty(me, 'authMethods', {enumerable: true, writable: false, value: appInfo.authMethods})\r\n      /**\r\n       * An array of WebSocket protocol names supported by server\r\n       * @property {Array<String>} supportedWSProtocols\r\n       */\r\n      Object.defineProperty(me, 'supportedWSProtocols', {enumerable: true, writable: false, value: appInfo.supportedWSProtocols || []})\r\n      /** UnityBase server version\r\n       * @property {String} serverVersion\r\n       * @readonly\r\n       */\r\n      Object.defineProperty(me, 'serverVersion', {enumerable: true, writable: false, value: appInfo.serverVersion || ''})\r\n      ubUtils.apply(me.appConfig, appInfo.uiSettings.adminUI)\r\n      return appInfo\r\n    })\r\n}\r\n\r\n/**\r\n * Retrieve domain information from server. Promise resolve instance of UBDomain.\r\n * @param {Function} [callBack] This parameter will be deleted in next version\r\n * @returns {Promise}\r\n */\r\nUBConnection.prototype.getDomainInfo = function (callBack) {\r\n  let me = this\r\n  return me.get('getDomainInfo', {params: {\r\n    v: 4, userName: this.userLogin()}\r\n    }).then(function (response) {\r\n      let result = response.data\r\n      let domain = new UBDomain(result)\r\n      me.domain = domain\r\n      if (callBack) {\r\n        callBack(result, domain)\r\n      }\r\n      return domain\r\n    })\r\n}\r\n\r\n/**\r\n * If connection require encryption then initialize UBConnection.channelEncryptor\r\n * @return {Promise}\r\n */\r\nUBConnection.prototype.initEncriptionIfNeed = function () {\r\n  let me = this\r\n  if (me.trafficEncryption && !me.channelEncryptor) {\r\n    if (!me.serverCertificate) {\r\n      me.channelEncryptor = null\r\n      return Promise.reject(new Error('During call to getAppInfo server not return certificate required for encrypted communication'))\r\n    } else {\r\n      me.channelEncryptor = new UBNativeDSTUCrypto()\r\n      return me.channelEncryptor.init(me.serverCertificate)\r\n    }\r\n  } else {\r\n    return Promise.resolve(true)\r\n  }\r\n}\r\n\r\n/**\r\n * Generate session encryption key and send it to server inside envelope.\r\n * Must be called for encrypted communication AFTER call to\r\n *  {@link UBConnection#getAppInfo getAppInfo} and authenticate user\r\n * @returns {Promise}\r\n * @private\r\n */\r\nUBConnection.prototype.doKeyExchange = function (session) {\r\n  let me = this\r\n  if (!me.trafficEncryption) {\r\n    return Promise.resolve({\r\n      doneTime: 0,\r\n      trafficEncryption: me.trafficEncryption\r\n    })\r\n  }\r\n  if (!me.isAuthorized()) {\r\n    return Promise.reject({errMsg: 'must be authorized before do key agreement'})\r\n  }\r\n    // TODO - wait for pending requests before call to getEnvelopeWithKey\r\n    // let envelope =\r\n  return me.channelEncryptor.getEnvelopeWithKey()\r\n    .then(function (envelope) {\r\n      let initEncryptionRequest = {\r\n        url: 'initEncryption',\r\n        method: 'POST',\r\n        data: envelope,\r\n        headers: {\r\n          'Content-Type': 'application/octet-stream',\r\n          'Authorization': 'UB ' + session.signature()\r\n        }\r\n      }\r\n      return me.xhr(initEncryptionRequest)\r\n    })\r\n    .then(function () {\r\n      return {\r\n        doneTime: new Date().getTime(),\r\n        trafficEncryption: me.trafficEncryption\r\n      }\r\n    })\r\n}\r\n\r\n/**\r\n * Process buffered requests from this._bufferedRequests\r\n * @private\r\n */\r\nUBConnection.prototype.processBuffer = function processBuffer () {\r\n  let me = this\r\n  let bufferCopy = me._bufferedRequests\r\n  // get ready to new buffer queue\r\n  me._bufferTimeoutID = 0\r\n  me._bufferedRequests = []\r\n\r\n  me.post('ubql', _.map(bufferCopy, 'request')).then(function (responses) {\r\n    // we expect responses in order we send requests to server\r\n    bufferCopy.forEach(function (bufferedRequest, num) {\r\n      bufferedRequest.deferred.resolve(responses.data[num])\r\n    })\r\n  }, function (failReason) {\r\n    bufferCopy.forEach(function (bufferedRequest) {\r\n      bufferedRequest.deferred.reject(failReason)\r\n    })\r\n  })\r\n}\r\n\r\n/**\r\n * Promise of running UBQL command(s) (asynchronously).\r\n * The difference from {@link UBConnection.post} is:\r\n *\r\n * - ability to buffer request: can merge several `query` in the 20ms period into one ubql call\r\n *\r\n * For well known UnityBase methods use aliases (addNew, select, insert, update, doDelete)\r\n * @param {Object} ubq    Request to execute\r\n * @param {String} ubq.entity Entity to execute the method\r\n * @param {String} ubq.method Method of entity to executed\r\n * @param {Array.<String>} [ubq.fieldList]\r\n * @param {Object} [ubq.whereList]\r\n * @param {Object} [ubq.execParams]\r\n * @param {Number} [ubq.ID]\r\n * @param {Object} [ubq.options]\r\n * @param {String} [ubq.lockType]\r\n * @param {Boolean} [ubq.__skipOptimisticLock] In case this parameter true and in the buffered\r\n * @param {Boolean} [ubq.__nativeDatasetFormat]\r\n * @param {Boolean} [allowBuffer] Allow buffer this request to single runList. False by default\r\n * @method\r\n * @returns {Promise}\r\n *\r\n * Example:\r\n *\r\n *      //this two execution is passed to single ubql server execution\r\n *      $App.connection.query({entity: 'uba_user', method: 'select', fieldList: ['*']}, true).then(UB.logDebug);\r\n *      $App.connection.query({entity: 'ubm_navshortcut', method: 'select', fieldList: ['*']}, true).then(UB.logDebug);\r\n *\r\n *      //but this request is passed in separate ubql (because allowBuffer false in first request\r\n *      $App.connection.query({entity: 'uba_user', method: 'select', fieldList: ['*']}).then(UB.logDebug);\r\n *      $App.connection.query({entity: 'ubm_desktop', method: 'select', fieldList: ['*']}, true).then(UB.logDebug);\r\n */\r\nUBConnection.prototype.query = function query (ubq, allowBuffer) {\r\n  let me = this\r\n  if (allowBuffer === undefined || allowBuffer === false || !BUFFERED_DELAY) {\r\n    return me.post('ubql', [ubq]).then(function (response) {\r\n      return response.data[0]\r\n    })\r\n  } else {\r\n    if (!this._bufferTimeoutID) {\r\n      this._bufferTimeoutID = setTimeout(me.processBuffer.bind(me), BUFFERED_DELAY)\r\n    }\r\n    return new Promise(function (resolve, reject) {\r\n      me._bufferedRequests.push({ request: ubq, deferred: { resolve, reject } })\r\n    })\r\n  }\r\n}\r\n\r\n/**\r\n * @deprecated Since UB 1.11 use `query` method\r\n * @private\r\n */\r\nUBConnection.prototype.run = UBConnection.prototype.query\r\n\r\n/**\r\n * Convert raw server response data to javaScript data according to attribute types.\r\n * Called by {@link UBConnection#select}\r\n * Currently only Data/DateTime & boolean conversion done\r\n * If resultLock present - resultLock.lockTime also converted\r\n *\r\n *      // convert all string representation of date/dateTime to Date object, integer representation of bool to Boolean\r\n *      return me.query({entity: 'my_entity', method: 'select'}, true)\r\n *          .then(me.convertResponseDataToJsTypes.bind(me));\r\n *\r\n * @method\r\n * @param serverResponse\r\n * @returns {*}\r\n */\r\nUBConnection.prototype.convertResponseDataToJsTypes = function (serverResponse) {\r\n  let convertRules, rulesLen, dataLen, data, d, r, column\r\n  if (serverResponse.entity && // fieldList &&  serverResponse.fieldList\r\n      serverResponse.resultData &&\r\n      !serverResponse.resultData.notModified &&\r\n      serverResponse.resultData.fields &&\r\n      serverResponse.resultData.data && serverResponse.resultData.data.length\r\n  ) {\r\n    convertRules = this.domain.get(serverResponse.entity).getConvertRules(serverResponse.resultData.fields)\r\n    rulesLen = convertRules.length\r\n    data = serverResponse.resultData.data\r\n    dataLen = data.length\r\n    if (rulesLen) {\r\n      for (d = 0; d < dataLen; d++) {\r\n        for (r = 0; r < rulesLen; r++) {\r\n          column = convertRules[r].index\r\n          data[d][column] = convertRules[r].convertFn(data[d][column])\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if (serverResponse.resultLock && serverResponse.resultLock.lockTime) {\r\n    serverResponse.resultLock.lockTime = ubUtils.iso8601Parse(serverResponse.resultLock.lockTime)\r\n  }\r\n  return serverResponse\r\n}\r\n\r\n/**\r\n * Call a {@link LocalDataStore#doFilterAndSort} - see a parameters there\r\n * @protected\r\n * @param {TubCachedData} cachedData\r\n * @param {TubSelectRequest} ubRequest\r\n * @returns {Object}\r\n */\r\nUBConnection.prototype.doFilterAndSort = function (cachedData, ubRequest) {\r\n  return LocalDataStore.doFilterAndSort(cachedData, ubRequest)\r\n}\r\n\r\n/**\r\n * Promise of running UBQL command with `addNew` method (asynchronously).\r\n * Two difference from {@link UBConnection.query}:\r\n *\r\n * - ubRequest.method set to 'addnew'\r\n * - requests is always buffered in the 20ms period into one ubql call\r\n * - `Date` & 'DateTime' entity attributes are converted from ISO8601 text representation to javaScript Date object\r\n *\r\n * Example:\r\n *\r\n *      $App.connection.addNew({entity: 'uba_user', fieldList: ['*']}).then(UB.logDebug);\r\n *\r\n * @param {Object} serverRequest    Request to execute\r\n * @param {String} serverRequest.entity Entity to execute the method\r\n * @param {String} [serverRequest.method] Method of entity to executed. Default to 'select'\r\n * @param {Array.<string>} serverRequest.fieldList\r\n * @param {Object} [serverRequest.execParams]\r\n * @param {Object} [serverRequest.options]\r\n * @param {String} [serverRequest.lockType]\r\n * @param {Boolean} [serverRequest.alsNeed]\r\n * @returns {Promise}\r\n */\r\nUBConnection.prototype.addNew = function (serverRequest) {\r\n  let me = this\r\n  serverRequest.method = 'addnew'\r\n  return me.query(serverRequest, true)\r\n    .then(me.convertResponseDataToJsTypes.bind(me))\r\n}\r\n\r\n/**\r\n * Called in update/insert/delete methods and if request entity is cached then clear cache\r\n * @private\r\n * @param serverResponse\r\n * @return {Promise} Promise resolved to serverResponse\r\n */\r\nUBConnection.prototype.invalidateCache = function (serverResponse) {\r\n  let me = this\r\n  let cacheType = me.domain.get(serverResponse.entity).cacheType\r\n  if (cacheType === UBCache.cacheTypes.none) {\r\n    return serverResponse\r\n  }\r\n  return me.cacheOccurrenceRefresh(serverResponse.entity, cacheType).then(function () {\r\n    return serverResponse\r\n  })\r\n}\r\n\r\n/**\r\n * Promise of running UBQL command with `update` method (asynchronously).\r\n * Difference from {@link UBConnection.query}:\r\n *\r\n * - ubRequest.method set to 'update'\r\n * - `Date` & 'DateTime' entity attributes are converted from ISO8601 text representation to javaScript Date object\r\n * - if necessary it will clear cache\r\n *\r\n * Example:\r\n *\r\n *      $App.connection.update({entity: 'uba_user', fieldList: ['ID','name'], execParams: {ID: 1, name:'newName'}}).then(UB.logDebug);\r\n *\r\n * @param {Object} serverRequest    Request to execute\r\n * @param {String} serverRequest.entity Entity to execute the method\r\n * @param {String} [serverRequest.method] Method of entity to executed. Default to 'update'\r\n * @param {Array.<string>} serverRequest.fieldList\r\n * @param {Object} [serverRequest.execParams]\r\n * @param {Object} [serverRequest.options]\r\n * @param {String} [serverRequest.lockType]\r\n * @param {Boolean} [serverRequest.alsNeed]\r\n * @param {Boolean} [allowBuffer] Default - false. Allow several \"in the same time\" request to be buffered to one transaction.\r\n * @returns {Promise}\r\n */\r\nUBConnection.prototype.update = function (serverRequest, allowBuffer) {\r\n  let me = this\r\n  serverRequest.method = serverRequest.method || 'update'\r\n  return me.query(serverRequest, allowBuffer)\r\n    .then(me.convertResponseDataToJsTypes.bind(me))\r\n    .then(me.invalidateCache.bind(me))\r\n}\r\n\r\n/**\r\n * Promise of running UnityBase UBQL command with `insert` method (asynchronously).\r\n * Difference from {@link UBConnection.query}:\r\n *\r\n * - ubRequest.method set to 'insert'\r\n * - `Date` & 'DateTime' entity attributes are converted from ISO8601 text representation to javaScript Date object\r\n * - if necessary it will clear cache\r\n *\r\n * @param {Object} serverRequest    Request to execute\r\n * @param {String} serverRequest.entity Entity to execute the method\r\n * @param {String} [serverRequest.method] Method of entity to executed. Default to 'insert'\r\n * @param {Array.<string>} serverRequest.fieldList\r\n * @param {Object} [serverRequest.execParams]\r\n * @param {Object} [serverRequest.options]\r\n * @param {String} [serverRequest.lockType]\r\n * @param {Boolean} [serverRequest.alsNeed]\r\n *\r\n * @param {Boolean} [allowBuffer] Default - false. Allow several \"in the same time\" request to be buffered to one transaction.\r\n *\r\n * @method\r\n * @returns {Promise}\r\n *\r\n * Example:\r\n *\r\n *      $App.connection.insert({entity: 'uba_user', fieldList: ['ID','name'], execParams: {ID: 1, name:'newName'}).then(UB.logDebug);\r\n *\r\n */\r\nUBConnection.prototype.insert = function (serverRequest, allowBuffer) {\r\n  let me = this\r\n  serverRequest.method = serverRequest.method || 'insert'\r\n  return me.query(serverRequest, allowBuffer)\r\n    .then(me.convertResponseDataToJsTypes.bind(me))\r\n    .then(me.invalidateCache.bind(me))\r\n}\r\n\r\n/**\r\n * Promise of running UBQL command with delete method (asynchronously).\r\n * Difference from {@link UBConnection.query}:\r\n *\r\n * - ubRequest.method set to 'delete' by default\r\n * - if necessary it will clear cache\r\n *\r\n * @param {Object} serverRequest    Request to execute\r\n * @param {String} serverRequest.entity Entity to execute the method\r\n * @param {String} [serverRequest.method] Method of entity to executed. Default to 'delete'\r\n * @param {Object} [serverRequest.execParams]\r\n * @param {Object} [serverRequest.options]\r\n * @param {String} [serverRequest.lockType]\r\n * @param {Boolean} [serverRequest.alsNeed]\r\n *\r\n * @param {Boolean} [allowBuffer] Default - false. Allow several \"in the same time\" request to be buffered to one transaction.\r\n *\r\n * @method\r\n * @returns {Promise}\r\n *\r\n * Example:\r\n *\r\n *      $App.connection.doDelete({entity: 'uba_user', fieldList: ['ID','name'], execParams: {ID: 1, name:'newName'}).then(UB.logDebug);\r\n *\r\n */\r\nUBConnection.prototype.doDelete = function (serverRequest, allowBuffer) {\r\n  let me = this\r\n  serverRequest.method = serverRequest.method || 'delete'\r\n  return me.query(serverRequest, allowBuffer)\r\n    .then(me.invalidateCache.bind(me))\r\n}\r\n\r\n/**\r\n * Promise of running UBQL (asynchronously).\r\n * Two difference from {@link UBConnection.query}:\r\n *\r\n * - ubRequest.method by default set to 'select'\r\n * - requests is always buffered in the 20ms period into one ubql call\r\n * - `Date` & 'DateTime' entity attributes are converted from ISO8601 text representation to javaScript Date object\r\n * - if request entity is cached - cache used\r\n *\r\n * @param {Object} serverRequest    Request to execute\r\n * @param {String} serverRequest.entity Entity to execute the method\r\n * @param {String} [serverRequest.method] Method of entity to executed. Default to 'select'\r\n * @param {Number} [serverRequest.ID] if passed - request bypass cache, where & order list is ignored. Can be used to load single record from server\r\n * @param {Array.<string>} serverRequest.fieldList\r\n * @param {Object} [serverRequest.whereList]\r\n * @param {Object} [serverRequest.execParams]\r\n * @param {Object} [serverRequest.options]\r\n * @param {String} [serverRequest.lockType]\r\n * @param {Boolean} [serverRequest.alsNeed]\r\n * @param {Boolean} [serverRequest.__skipOptimisticLock] In case this parameter true and in the buffered\r\n * @param {Boolean} [bypassCache=false] Do not use cache while request even if entity cached.\r\n *   If  `__mip_disablecache: true` is passed in serverRequest cache is also disabled.\r\n * @method\r\n * @returns {Promise}\r\n *\r\n * Example:\r\n *\r\n *      //retrieve users\r\n *      $App.connection.select({entity: 'uba_user', fieldList: ['*']}).then(UB.logDebug);\r\n *\r\n *      //retrieve users and desktops and then both done - do something\r\n *      Promise.all($App.connection.select({entity: 'uba_user', fieldList: ['ID', 'name']})\r\n *        $App.connection.select({entity: 'ubm_desktop', fieldList: ['ID', 'code']})\r\n *      ).then(UB.logDebug);\r\n */\r\nUBConnection.prototype.select = function (serverRequest, bypassCache) {\r\n  let me = this\r\n  let cacheTypes = UBCache.cacheTypes\r\n  let serverRequestWOLimits = {}\r\n  let dataPromise, cKey, cacheStoreName\r\n  /**\r\n   *\r\n   * @param {Object} serverResponse\r\n   * @param {Object} serverResponse.resultData       miscmimi\r\n   * @param {Boolean} [serverResponse.resultData.notModified]\r\n   * @param {String} storeName\r\n   * @returns {*}\r\n   */\r\n  let processVersionedResponse = function (serverResponse, storeName) {\r\n    if (serverResponse.resultData.notModified) {\r\n              // in case we refresh cachedSessionEntityRequested or just after login - put version to cachedSessionEntityRequested\r\n      me.cachedSessionEntityRequested[cKey] = serverResponse.version\r\n      return me.cache.get(cKey, storeName)\r\n    } else {\r\n      return me.cache.put([\r\n                  {key: cKey + ':v', value: serverResponse.version},\r\n                  {key: cKey, value: serverResponse.resultData}\r\n      ], storeName)\r\n                  .then(function () {\r\n                    me.cachedSessionEntityRequested[cKey] = serverResponse.version\r\n                    return serverResponse.resultData\r\n                  })\r\n    }\r\n  }\r\n\r\n  bypassCache = bypassCache || (serverRequest.__mip_disablecache === true)\r\n  let cacheType = bypassCache || serverRequest.ID || serverRequest.bypassCache\r\n    ? UBCache.cacheTypes.None\r\n    : me.domain.get(serverRequest.entity).cacheType\r\n\r\n  if (!serverRequest.method) {\r\n    serverRequest.method = 'select'\r\n  }\r\n    // if exist expression where ID = ... bypass cache\r\n//        if (idInWhere(serverRequest.whereList)){\r\n//            cacheType = cacheTypes.None;\r\n//        }\r\n  if (cacheType === cacheTypes.None) { // where & order is done by server side\r\n    dataPromise = me.query(serverRequest, true)\r\n      .then(me.convertResponseDataToJsTypes.bind(me))\r\n      .then(function (response) {\r\n        let responseWithTotal = {}\r\n        ubUtils.apply(responseWithTotal, response)\r\n        if (response.__totalRecCount) {\r\n          responseWithTotal.total = response.__totalRecCount\r\n        } else if (response.resultData && response.resultData.data) {\r\n          let resRowCount = response.resultData.data.length\r\n          if (!serverRequest.options) {\r\n            responseWithTotal.total = resRowCount\r\n          } else {\r\n            let opt = serverRequest.options || {}\r\n            let start = opt.start ? opt.start : 0\r\n            let limit = opt.limit || 0\r\n                  // in case we fetch less data then requested - this is last page and we know total\r\n            responseWithTotal.total = (resRowCount < limit) ? start + resRowCount : -1\r\n          }\r\n        }\r\n        return responseWithTotal\r\n      })\r\n  } else { // where & order is done by client side\r\n        // TODO check all filtered attribute is present in whereList - rewrite me.checkFieldList(operation);\r\n    cKey = me.cacheKeyCalculate(serverRequest.entity, serverRequest.fieldList)\r\n    cacheStoreName = (cacheType === cacheTypes.Session) ? UBCache.SESSION : UBCache.PERMANENT\r\n        // retrieve data either from cache or from server\r\n    dataPromise = me.cache.get(cKey + ':v', cacheStoreName).then(function (version) {\r\n      let cachedPromise\r\n      if (!version || // no data in cache or invalid version\r\n          // or must re-validate version\r\n          (version && cacheType === cacheTypes.Entity) ||\r\n          // or SessionEntity cached not this current cache version\r\n          (version && cacheType === cacheTypes.SessionEntity && me.cachedSessionEntityRequested[cKey] !== version)\r\n      ) {\r\n        ubUtils.apply(serverRequestWOLimits, serverRequest)\r\n        delete serverRequestWOLimits.whereList\r\n        delete serverRequestWOLimits.orderList\r\n        delete serverRequestWOLimits.options\r\n        serverRequestWOLimits.version = version || '-1'\r\n        cachedPromise = me.query(serverRequestWOLimits, true)\r\n          .then(me.convertResponseDataToJsTypes.bind(me))\r\n          .then(function (response) {\r\n            return processVersionedResponse(response, cacheStoreName)\r\n          })\r\n      } else { // retrieve data from cache\r\n        cachedPromise = me.cache.get(cKey, cacheStoreName)\r\n      }\r\n      return cachedPromise\r\n    }).then(function (cacheResponse) {\r\n           // noinspection JSCheckFunctionSignatures\r\n      return me.doFilterAndSort(cacheResponse, serverRequest)\r\n    })\r\n  }\r\n  return dataPromise\r\n}\r\n\r\n/**\r\n * Alias to {@link LocalDataStore#selectResultToArrayOfObjects LocalDataStore.selectResultToArrayOfObjects}\r\n *\r\n * @param {{resultData: {data: Array.<Array>, fields: Array.<String>}}} selectResult\r\n * @returns {Array.<*>}\r\n * @private\r\n * @deprecated Use LocalDataStore.selectResultToArrayOfObjects\r\n */\r\nUBConnection.selectResultToArrayOfObjects = LocalDataStore.selectResultToArrayOfObjects\r\n\r\n/**\r\n * Execute numbers of ubRequest in one server request (one transaction)\r\n *\r\n *      $App.connection.runTrans([\r\n *           { entity: 'my_entity', method: 'update', ID: 1, execParams: {code: 'newCode'} },\r\n *           { entity: 'my_entity', method: 'update', ID: 2, execParams: {code: 'newCodeforElementWithID=2'} },\r\n *       ]).then(UB.logDebug);\r\n *\r\n * @method\r\n * @param {Array.<ubRequest>} ubRequestArray\r\n * @returns {Promise} Resolved to response.data\r\n */\r\nUBConnection.prototype.runTrans = function run (ubRequestArray) {\r\n  let me = this\r\n  return me.post('ubql', ubRequestArray).then(function (response) {\r\n    return response.data\r\n  })\r\n}\r\n\r\nconst ALLOWED_GET_DOCUMENT_PARAMS = ['entity', 'attribute', 'ID', 'id', 'isDirty', 'forceMime', 'fileName', 'store', 'revision']\r\n/**\r\n * Retrieve content of `document` type attribute field from server. Usage samples:\r\n *\r\n *      //Retrieve content of document as string using GET\r\n *      $App.connection.getDocument({\r\n *          entity:'ubm_form',\r\n *          attribute: 'formDef',\r\n *          ID: 100000232003\r\n *       }).then(function(result){console.log(typeof result)}); // string\r\n *\r\n *      //The same, but using POST for bypass cache\r\n *      $App.connection.getDocument({\r\n *          entity:'ubm_form',\r\n *          attribute: 'formDef',\r\n *          ID: 100000232003\r\n *       }, {\r\n *          bypassCache: true\r\n *       }).then(function(result){console.log(typeof result)}); // string\r\n *\r\n *\r\n *      //Retrieve content of document as ArrayBuffer and bypass cache\r\n *      $App.connection.getDocument({\r\n *          entity:'ubm_form',\r\n *          attribute: 'formDef',\r\n *          ID: 100000232003\r\n *       }, {\r\n *          bypassCache: true, resultIsBinary: true\r\n *       }).then(function(result){\r\n *          console.log('Result is', typeof result, 'of length' , result.byteLength, 'bytes'); //output: Result is object of length 2741 bytes\r\n *       });\r\n *\r\n * @param {Object} params\r\n * @param {String} params.entity Code of entity to retrieve from\r\n * @param {String} params.attribute `document` type attribute code\r\n * @param {Number} params.id Instance ID\r\n * @param {String} [params.forceMime] If passed and server support transformation from source MIME type to `forceMime` server perform transformation and return documenRt representation in the passed MIME\r\n * @param {Number} [params.revision] Optional revision of the documnet (if supported by server-side store configuration). Default is current revision.\r\n * @param {String} [params.fileName] ????\r\n * @param {Boolean} [params.isDirty=false] Optional ability to retrieve document in **dirty** state\r\n * @param {String} [params.store] ????\r\n *\r\n * @param {Object} [options] Additional request options\r\n * @param {Boolean} [options.resultIsBinary=false] if true - return document content as arrayBuffer\r\n * @param {Boolean} [options.bypassCache] HTTP POST verb will be used instead of GET for bypass browser cache\r\n * @returns {Promise} Resolved to document content (either ArrayBuffer in case options.resultIsBinary===true or text/json)\r\n */\r\nUBConnection.prototype.getDocument = function (params, options) {\r\n  let opt = _.defaults({}, options)\r\n  let reqParams = {\r\n    url: 'getDocument',\r\n    method: opt.bypassCache ? 'POST' : 'GET'\r\n  }\r\n  if (options && options.resultIsBinary) {\r\n    reqParams.responseType = 'arraybuffer'\r\n  }\r\n  if (opt.bypassCache) {\r\n    reqParams.data = _.clone(params)\r\n    Object.keys(reqParams.data).forEach(function (key) {\r\n      if (ALLOWED_GET_DOCUMENT_PARAMS.indexOf(key) === -1) {\r\n        delete reqParams.data[key]\r\n        ubUtils.logDebug('invalid parameter \"' + key + '\" passed to getDocument request')\r\n      }\r\n    })\r\n  } else {\r\n    reqParams.params = params\r\n  }\r\n  return this.xhr(reqParams)\r\n        .then(function (response) {\r\n          return response.data\r\n        })\r\n}\r\n\r\n/**\r\n * Alias to {@link UBSession.hexa8 UBSession.hexa8}\r\n * @private\r\n * @deprecated since 1.8 use UBSession.prototype.hexa8 instead\r\n */\r\nUBConnection.prototype.hexa8 = UBSession.prototype.hexa8\r\n\r\n/**\r\n * Alias to {@link UBSession.hexa8 UBSession.crc32}\r\n * @private\r\n * @deprecated since 1.8 use UBSession.prototype.crc32 instead\r\n */\r\nUBConnection.prototype.crc32 = UBSession.prototype.crc32\r\n\r\n/**\r\n * Log out user from server\r\n */\r\nUBConnection.prototype.logout = function () {\r\n  let me = this\r\n  if (me.isAuthorized()) {\r\n    return me.post('logout', {})\r\n            .then(function () {\r\n              return new Promise(function (resolve) {\r\n                setTimeout(function () {\r\n                  if (me._pki) {\r\n                    me._pki.closePK()\r\n                  }\r\n                  resolve(true)\r\n                }, 20)\r\n              })\r\n            })\r\n  } else {\r\n    return Promise.resolve(true)\r\n  }\r\n}\r\n\r\n/**\r\n * Known server-side error codes\r\n * @enum\r\n * @private\r\n */\r\nUBConnection.prototype.serverErrorCodes = {\r\n  1: 'ubErrNotImplementedErrnum',\r\n  2: 'ubErrRollbackedErrnum',\r\n  3: 'ubErrNotExecutedErrnum',\r\n  4: 'ubErrInvaliddataforrunmethod',\r\n  5: 'ubErrInvaliddataforrunmethodlist',\r\n  6: 'ubErrNoMethodParameter',\r\n  7: 'ubErrMethodNotExist',\r\n  8: 'ubErrElsAccessDeny',\r\n  9: 'ubErrElsInvalidUserOrPwd',\r\n  10: 'ubErrElsNeedAuth',\r\n  11: 'ubErrNoEntityParameter',\r\n  13: 'ubErrNoSuchRecord',\r\n  14: 'ubErrInvalidDocpropFldContent',\r\n  15: 'ubErrEntityNotExist',\r\n  16: 'ubErrAttributeNotExist',\r\n  17: 'ubErrNotexistEntitymethod',\r\n  18: 'ubErrInvalidSetdocData',\r\n  19: 'ubErrSoftlockExist',\r\n  20: 'ubErrNoErrorDescription',\r\n  21: 'ubErrUnknownStore',\r\n  22: 'ubErrObjdatasrcempty',\r\n  23: 'ubErrObjattrexprbodyempty',\r\n  24: 'ubErrNecessaryfieldNotExist',\r\n  25: 'ubErrRecordmodified',\r\n  26: 'ubErrNotexistnecessparam',\r\n  27: 'ubErrNotexistfieldlist',\r\n  28: 'ubErrUpdaterecnotfound',\r\n  29: 'ubErrNecessaryparamnotexist',\r\n  30: 'ubErrInvalidstoredirs',\r\n  31: 'ubErrNofileinstore',\r\n  32: 'ubErrAppnotsupportconnection',\r\n  33: 'ubErrAppnotsupportstore',\r\n  34: 'ubErrDeleterecnotfound',\r\n  35: 'ubErrNotfoundlinkentity',\r\n  36: 'ubErrEntitynotcontainmixinaslink',\r\n  37: 'ubErrEssnotinherfromessaslink',\r\n  38: 'ubErrInstancedatanameisreadonly',\r\n  39: 'ubErrManyrecordsforsoftlock',\r\n  40: 'ubErrNotfoundidentfieldsl',\r\n  41: 'ubErrInvalidlocktypevalue',\r\n  42: 'ubErrLockedbyanotheruser',\r\n  43: 'ubErrInvalidwherelistinparams',\r\n  44: 'ubErrRecnotlocked',\r\n  45: 'ubErrManyrecordsforchecksign',\r\n  46: 'ubErrNotfoundparamnotrootlevel',\r\n  47: 'ubErrCantcreatedirlogmsg',\r\n  48: 'ubErrCantcreatedirclientmsg',\r\n  49: 'ubErrConnectionNotExist',\r\n  50: 'ubErrDirectUnityModification',\r\n  51: 'ubErrCantdelrecthisvalueusedinassocrec',\r\n  52: 'ubErrAssocattrnotfound',\r\n  53: 'ubErrAttrassociationtoentityisempty',\r\n  54: 'ubErrNotfoundconforentityinapp',\r\n  55: 'ubErrNewversionrecnotfound',\r\n  56: 'ubErrElsAccessDenyEntity',\r\n  57: 'ubErrAlsAccessDenyEntityattr',\r\n  58: 'ubErrDatastoreEmptyentity',\r\n    // 59: \"ubErrCustomerror\"\r\n  67: 'ubErrTheServerHasExceededMaximumNumberOfConnections',\r\n  69: 'ubErrFtsForAppDisabled',\r\n  72: 'ubErrElsPwdIsExpired',\r\n  73: 'ELS_USER_NOT_FOUND',\r\n  74: 'VALUE_MUST_ME_UNIQUE'\r\n}\r\n\r\n/**\r\n * Return server-side error message by error number\r\n * @param {Number} errorNum\r\n * @return {String}\r\n */\r\nUBConnection.prototype.serverErrorByCode = function (errorNum) {\r\n  return this.serverErrorCodes[errorNum]\r\n}\r\n\r\n/**\r\n * Create a new instance of repository\r\n * @param {String} entityName name of Entity we create for\r\n * @returns {ServerRepository}\r\n */\r\nUBConnection.prototype.Repository = function (entityName) {\r\n  return new ClientRepository(this, entityName)\r\n}\r\n\r\nconst LDS = (window && window.localStorage)\r\n/**\r\n * Connect to UnityBase server\r\n *\r\n * Example:\r\n *\r\n const UB = require('@unitybase/ub-core')\r\n let conn = UB.connect({\r\n    host: window.location.origin,\r\n    path: window.location.pathname,\r\n    onCredentialRequired: function(conn, isRepeat){\r\n        if (isRepeat){\r\n            throw new UB.UBAbortError('invalid')\r\n        } else {\r\n            return Promise.resolve({authSchema: 'UB', login: 'admin', password: 'admin'})\r\n        }\r\n    },\r\n    onAuthorizationFail:  function(reason){\r\n        alert(reason);\r\n    }\r\n });\r\n conn.then(function(conn){\r\n    conn.get('stat').then(function(statResp){\r\n        document.getElementById('ubstat').innerText = JSON.stringify(statResp.data, null, '\\t');\r\n    });\r\n\r\n    conn.Repository('ubm_navshortcut').attrs(['ID', 'code', 'caption']).selectAsArray().then(function(data){\r\n        let tmpl = _.template(document.getElementById('repo-template').innerHTML);\r\n        let result = tmpl(data.resultData);\r\n        // document.getElementById('ubnav').innerText = JSON.stringify(data.resultData);\r\n        document.getElementById('ubnav').innerHTML = result;\r\n    });\r\n });\r\n\r\n * @param cfg\r\n * @param {string} cfg.host Server host\r\n * @param {string} [cfg.path] API path - the same as in Server config `httpServer.path`\r\n * @param cfg.onCredentialRequired Callback for requesting a user creadentials. See {@link UBConnection} constructor `requestAuthParams` parameter description\r\n * @param [cfg.onAuthorizationFail] Callback for authorization failure. See {@link authorizationFail} event.\r\n * @param [cfg.onNeedChangePassword] Callback for a password exparition. See {@link passwordExpired} event\r\n * @param [cfg.onGotApplicationConfig]\r\n * @param [cfg.onGotApplicationDomain]\r\n * @return Promise<UBConnection>\r\n */\r\nfunction connect (cfg) {\r\n  let config = this.config = _.clone(cfg)\r\n\r\n  let connection = new UBConnection({\r\n    host: config.host,\r\n    appName: config.path || '/',\r\n    requestAuthParams: config.onCredentialRequired\r\n  })\r\n  if (config.onAuthorizationFail) {\r\n    connection.on('authorizationFail', config.onAuthorizationFail)\r\n  }\r\n  if (config.onNeedChangePassword) {\r\n    connection.on('passwordExpired', config.onNeedChangePassword)\r\n  }\r\n\r\n  return connection.getAppInfo().then(function (appInfo) {\r\n    // apply a default app settings to the gerAppInfo result\r\n    connection.appConfig = _.defaults(_.clone(appInfo), {\r\n      applicationName: 'UnityBase',\r\n      applicationTitle: 'UnityBase',\r\n      loginWindowTopLogoURL: '',\r\n      loginWindowBottomLogoURL: '',\r\n      themeName: 'UBGrayTheme',\r\n      userDbVersion: null,\r\n      defaultLang: 'en',\r\n      supportedLanguages: ['en']\r\n    })\r\n    // create ubNotifier after retrieve appInfo (we need to know supported WS protocols)\r\n    connection.ubNotifier = new UBNotifierWSProtocol(connection)\r\n    // try to determinate default user language\r\n    let preferredLocale = LDS && LDS.getItem(connection.appName + 'preferredLocale')\r\n    if (!preferredLocale) {\r\n      preferredLocale = connection.appConfig.defaultLang\r\n    }\r\n    // is language supported by application?\r\n    if (connection.appConfig.supportedLanguages.indexOf(preferredLocale) === -1) {\r\n      preferredLocale = connection.appConfig.defaultLang\r\n    }\r\n    connection.preferredLocale = preferredLocale\r\n    return config.onGotApplicationConfig ? config.onGotApplicationConfig(connection) : true\r\n  }).then(function () {\r\n    return connection.initEncriptionIfNeed()\r\n  }).then(function () {\r\n    return connection.initCache(connection.appConfig.userDbVersion)\r\n  }).then(function () {\r\n    return connection.authorize()\r\n  }).then(function () {\r\n    // here we authorized and know a user-related data\r\n    let myLocale = connection.userData('lang')\r\n    LDS && LDS.setItem(connection.appName + 'preferredLocale', myLocale)\r\n    connection.preferredLocale = myLocale\r\n    return connection.getDomainInfo(config.onGotApplicationDomain)\r\n  }).then(function (domain) {\r\n    connection.domain = domain\r\n    return connection\r\n  })\r\n}\r\n\r\nmodule.exports = {\r\n  UBConnection,\r\n  connect\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./UBConnection.js","/*\r\n @author pavel.mash\r\n */\r\nvar ubUtils = require('./utils')\r\nvar UBNativeMessage = require('./UBNativeMessage')\r\n\r\n/**\r\n * @class UBNativeDSTUCrypto\r\n * Ukrainian DSTU cryptographic service. Require native messages feature 'dstu' to be installed.\r\n * @constructor\r\n * Construct new Cryptography service\r\n * @param {Object} config initial parameters\r\n * @param {Number} [config.waitTimeout=180000] Default timeout for cryptographic operation (in ms)\r\n */\r\nfunction UBNativeDSTUCrypto (config) {\r\n  var\r\n    crypto = Object.create(UBNativeDSTUCrypto.prototype),\r\n    nm,\r\n    initialized = false\r\n\r\n  nm = new UBNativeMessage('dstu')\r\n    /**\r\n     * Native messages plugin instance\r\n     * @property {UBNativeMessage} plugin\r\n     * @protected\r\n     */\r\n  crypto.nm = nm\r\n  crypto.nm.callTimeOut = (config && config.waitTimeout) || 180000\r\n\r\n    /**\r\n     * Initialize encryption\r\n     * @param {String} serverCertificate base64 encoded server side certificate\r\n     * @return {Promise<UBNativeDSTUCrypto>} resolved to self\r\n     */\r\n  crypto.init = function (serverCertificate) {\r\n    if (initialized) {\r\n      return Promise.resolve(crypto)\r\n    } else {\r\n      return nm.connect().then(function (nm) {\r\n        return nm.invoke('init', serverCertificate).then(function () {\r\n          initialized = true\r\n          return crypto\r\n        })\r\n      })\r\n    }\r\n  }\r\n\r\n    /**\r\n     * Encrypt data and return result as array buffer\r\n     * @method\r\n     * @param {String} data\r\n     * @param {Boolean} isBase64\r\n     * @param {Boolean} [compress=false] (Optional)\r\n     * @returns {Promise} ArrayBuffer\r\n     */\r\n  crypto.encryptToArray = function (data, isBase64, compress) {\r\n    return nm.invoke('encrypt', {data: data, isBase64: isBase64, compress: compress || false}).then(function (base64encrypted) {\r\n      return ubUtils.base64toArrayBuffer(base64encrypted)\r\n    })\r\n  }\r\n\r\n    /**\r\n     * Decrypt array buffer data\r\n     * @method\r\n     * @param {ArrayBuffer} data\r\n     * @param {Boolean} toBase64\r\n     * @param {Boolean} [isCompressed=false] (optional)\r\n     * @returns {Promise} as Base64\r\n     */\r\n  crypto.decryptArr = function (data, toBase64, isCompressed) {\r\n    if (!data) {\r\n      throw new Error('Do not call decryptArr method with empty value')\r\n    }\r\n    return ubUtils.base64FromAny(data).then(function (b64) {\r\n      return nm.invoke('decrypt', {data: b64, toBase64: toBase64, isCompressed: isCompressed || false})\r\n    })\r\n  }\r\n\r\n    /**\r\n     * Creating an envelope with an encryption key.\r\n     * @returns {Promise} resolver to encryption key envelope\r\n     */\r\n  crypto.getEnvelopeWithKey = function () {\r\n    return nm.invoke('getEnvelopeWithKey')\r\n  }\r\n\r\n  return crypto\r\n}\r\n\r\nmodule.exports = UBNativeDSTUCrypto\r\n\n\n\n// WEBPACK FOOTER //\n// ./UBNativeDSTUCrypto.js","/*\r\n @author v.orel\r\n */\r\nvar ubUtils = require('./utils')\r\nvar UBNativeMessage = require('./UBNativeMessage')\r\n\r\n/**\r\n * @class UBNativeIITCrypto\r\n * Ukrainian IIT cryptographic service. Require native messages feature 'iit' to be installed.\r\n *\r\n * In Ext-based application instance of  UBNativeIITCrypto accessible via $App.connection.pki()\r\n * Usage sample:\r\n *\r\n        var file = fileInputEl.dom.files[0];\r\n        $App.connection.pki().then(function(pki){\r\n            return pki.readPK().then(function(){\r\n                return {pki: pki, b64File: UB.base64fromAny(file)}\r\n            }).then(function(params) {\r\n                return params.pki.signData(params.b64File);\r\n            }).then(function(signature){\r\n                console.log('Base64 p7s file representation:', signature);\r\n            });\r\n\t});\r\n\r\n * @constructor\r\n * Construct new Cryptography service\r\n * @param {Object} [config] initial parameters\r\n * @param {Number} [config.waitTimeout=180000] Default timeout for cryptographic operation (in ms)\r\n */\r\nfunction UBNativeIITCrypto (config) {\r\n  var\r\n    crypto = Object.create(UBNativeIITCrypto.prototype),\r\n    nm,\r\n    initialized = false\r\n\r\n  nm = new UBNativeMessage('iit')\r\n    /**\r\n     * Native messages nm instance\r\n     * @property {UBNativeMessage} nm\r\n     * @protected\r\n     */\r\n  crypto.nm = nm\r\n  crypto.nm.callTimeOut = (config && config.waitTimeout) || 180000\r\n\r\n    /**\r\n     * Initialize encryption\r\n     * @return {Promise<UBNativeIITCrypto>} resolved to self\r\n     */\r\n  crypto.init = function () {\r\n    if (initialized) {\r\n      return Promise.resolve(crypto)\r\n    } else {\r\n      return nm.connect().then(function (nm) {\r\n        return nm.invoke('init', null).then(function () {\r\n          initialized = true\r\n          return crypto\r\n        })\r\n      })\r\n    }\r\n  }\r\n    /**\r\n     * for IIT try load pk on error select cert and set it in store\r\n     * @param {UBConnection} connection\r\n     * @returns {Promise}\r\n     */\r\n  crypto.readPK = function (connection) {\r\n    var me = this,\r\n      promise\r\n\r\n    promise = me.nm.invoke('getPrivateKeyReaded')\r\n            .then(function (keyIsReaded) {\r\n              if (keyIsReaded) {\r\n                return true\r\n              } else {\r\n                return me.nm.invoke('CheckSettings')\r\n                        .then(function (settingsOk) {\r\n                          if (settingsOk) {\r\n                            return me.nm.invoke('readPK', [], 300000)\r\n                                    .then(function (pkResult) {\r\n                                      switch (parseInt(pkResult.result, 10)) {\r\n                                        case 0: // everything is OK\r\n                                          return pkResult.result\r\n                                        case 12: // read of private key is canceled by user\r\n                                          throw new ubUtils.UBAbortError('readPKCanceled')\r\n                                        case 51: // certificate not found - either user certificate not in certificate store, or root certificates not loaded to certificate store\r\n                                          return me.nm.invoke('loadCertDialog', [], 300000)\r\n                                                    .then(function () {\r\n                                                        // download root certs\r\n                                                      return connection.get('downloads/cert/CertList.json')\r\n                                                    })\r\n                                                    .then(loadCerts)\r\n                                                    .then(function () {\r\n                                                      return me.nm.invoke('readPK', [], 300000)\r\n                                                            .then(function (pkResult) {\r\n                                                              if (parseInt(pkResult.result, 10) === 51) {\r\n                                                                throw new ubUtils.UBError('invalidPrivateKeyCertificate', pkResult.lastError)\r\n                                                              } else {\r\n                                                                return pkResult.result\r\n                                                              }\r\n                                                            })\r\n                                                    })\r\n                                        default: // unknown result\r\n                                          if (pkResult.lastError) {\r\n                                            throw new ubUtils.UBError(pkResult.lastError, pkResult.result)\r\n                                          } else {\r\n                                            throw new Error(pkResult.result)\r\n                                          }\r\n                                      }\r\n                                    })\r\n                          } else {\r\n                            return Promise.reject({errMsg: 'nm.CheckSettings() fail'})\r\n                          }\r\n                        })\r\n              }\r\n            })\r\n\r\n        // here private key is readed\r\n    return promise.then(function () {\r\n      var certificateInfo = {}\r\n\r\n      return me.nm.invoke('getOwnCert').then(function (ownIITCer) {\r\n        certificateInfo.ownIITCert = ownIITCer\r\n        if (!certificateInfo.ownIITCert || (certificateInfo.ownIITCert === '')) {\r\n          throw new Error('getOwnCertFail')\r\n        }\r\n        return me.nm.invoke('getOwnCertEncrypt').then(function (ownIITEncryptCert) {\r\n          certificateInfo.ownIITEncryptCert = ownIITEncryptCert\r\n          return me.nm.invoke('getOwnCertEncryptSignature').then(function (ownIITEncryptSignature) {\r\n            certificateInfo.ownIITEncryptSignature = ownIITEncryptSignature\r\n            return certificateInfo\r\n          })\r\n        })\r\n      })\r\n    }, function (rejection) {\r\n      me.nm.invoke('closePK')\r\n      throw rejection\r\n    })\r\n\r\n    function loadCerts (certListResult) {\r\n      var certificates = certListResult.data,\r\n        reqArr = [], req\r\n      _.forEach(certificates, function (certName) {\r\n        req = connection.get('downloads/cert/' + certName, {\r\n          responseType: 'arraybuffer'\r\n        }).then(function (cert) {\r\n          return ubUtils.base64FromAny(cert.data)\r\n        }).then(function (base64Data) {\r\n          return me.nm.invoke('AddCert', base64Data)\r\n        })\r\n        reqArr.push(req)\r\n      })\r\n      return Promise.all(reqArr)\r\n    }\r\n  }\r\n\r\n    /**\r\n     * Set server side certificate\r\n     * @deprecated Due to wrong name this function is deprecated since UB 4.0. Use setRecipientCertificate instead.\r\n     * @param {String} base64encodedCert\r\n     */\r\n  crypto.setServerCertificate = function (base64encodedCert) {\r\n    return this.nm.invoke('setServerCert', base64encodedCert)\r\n  }\r\n\r\n    /**\r\n     * Set recipient certificate for use in encryption operations\r\n     * @param {String} base64encodedCert\r\n     */\r\n  crypto.setRecipientCertificate = function (base64encodedCert) {\r\n    return this.nm.invoke('setServerCert', base64encodedCert)\r\n  }\r\n\r\n    /**\r\n     * Decrypt envelope to string using client private key.\r\n     * {@link UBNativeIITCrypto#readPK} must be called before\r\n     * @param {String} envelope base64 encoded envelope\r\n     * @param {Boolean} resultAsBase64\r\n     * @method\r\n     * @returns {Promise}\r\n     */\r\n  crypto.decryptEnvelope = function (envelope, resultAsBase64) {\r\n    return this.nm.invoke('decryptEnvelope', {data: envelope, toBase64: resultAsBase64})\r\n  }\r\n\r\n    /**\r\n     * Encrypt string to envelope using the public key, previously loaded by {@link UBNativeIITCrypto#setRecipientCertificate}\r\n     * @param {String} base64string\r\n     * @param {Boolean} resultAsBase64\r\n     * @method\r\n     * @returns {Promise}\r\n     */\r\n  crypto.encryptEnvelope = function (base64string, resultAsBase64) {\r\n    return this.nm.invoke('encryptEnvelope', {data: base64string, isBase64: resultAsBase64})\r\n  }\r\n\r\n    /**\r\n     * Close previously opened private key.\r\n     * @returns {Promise}\r\n     */\r\n  crypto.closePK = function () {\r\n    return this.nm.invoke('closePK')\r\n  }\r\n\r\n    /**\r\n     * Sign data and return base 64 encoded signature of it. Data can be either base64 encoded binary data or string\r\n     * @param {String} data\r\n     * @param {Boolean} [dataIsBase64=true]\r\n     * @returns {Promise} Resolved to base64 encoded <a href=\"http://habrahabr.ru/post/256367/\">p7s</a> data signature\r\n     */\r\n  crypto.signData = function (data, dataIsBase64) {\r\n    return this.nm.invoke('IITSignData', {data: data, isBase64: typeof dataIsBase64 === 'undefined' ? true : dataIsBase64})\r\n  }\r\n\r\n    /**\r\n     * Verify data signature. If successfully - return promise, resolved to signature info, else - reject with reason\r\n     * @param {String} data\r\n     * @param {String} signature Base64 encoded data signature\r\n     * @param {Boolean} [dataIsBase64=true]\r\n     * @returns {Promise}\r\n     */\r\n  crypto.verifySignature = function (data, signature, dataIsBase64) {\r\n    return this.nm.invoke('IITVerifyData', {data: data, signature: signature, isBase64: typeof dataIsBase64 === 'undefined' ? true : dataIsBase64})\r\n  }\r\n//\r\n//        /**\r\n//         * Encrypt data and return result as array buffer\r\n//         * @method\r\n//         * @param {String} data\r\n//         * @param {Boolean} isBase64\r\n//         * @param {Boolean} [compress=false] (Optional)\r\n//         * @returns {Promise} ArrayBuffer\r\n//         */\r\n//        crypto.encryptToArray = function(data, isBase64, compress){\r\n//            return nm.invoke('encrypt', {data: data, isBase64: isBase64, compress: compress || false}).then(function(base64encrypted){\r\n//                return UB.base64toArrayBuffer(base64encrypted);\r\n//            });\r\n//        };\r\n//\r\n//        /**\r\n//         * Decrypt array buffer data\r\n//         * @method\r\n//         * @param {ArrayBuffer} data\r\n//         * @param {Boolean} toBase64\r\n//         * @param {Boolean} [isCompressed=false] (Optional)\r\n//         * @returns {Promise} as Base64\r\n//         */\r\n//        crypto.decryptArr = function(data, toBase64, isCompressed){\r\n//            var base64str;\r\n//\r\n//            if (!data){\r\n//                throw new Error('Do not call decryptArr method with empty value');\r\n//            }\r\n//            base64str = UB.base64fromArrayBuffer(data);\r\n//            return nm.invoke('decrypt', {data: base64str, toBase64: toBase64, isCompressed: isCompressed});\r\n//        };\r\n//\r\n//        /**\r\n//         * Creating an envelope with an encryption key.\r\n//         * @returns {Promise} resolver to encryption key envelope\r\n//         */\r\n//        crypto.getEnvelopeWithKey = function(){\r\n//            return nm.invoke('getEnvelopeWithKey');\r\n//        };\r\n\r\n  return crypto\r\n}\r\n\r\nmodule.exports = UBNativeIITCrypto\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// ./UBNativeIITCrypto.js","/*\r\n * Created by pavel.mash on 14.03.2016.\r\n */\r\nconst _ = require('lodash')\r\nconst EventEmitter = require('./events')\r\n\r\nconst WS_PROTOCOL = 'ubNotifier'\r\nconst MAX_BUFFERED_COMMANDS = 100\r\n\r\n/**\r\n * @classdesc\r\n *\r\n * WebSocket connection to UnityBase server using ubNotifier protocol.\r\n * The property `supported` indicate `ubNotifier` protocol is supported by server.\r\n * Class mixes an EventEmitter. After got a command from a server the event with command code\r\n * is fired.\r\n *\r\n * The event flow are:\r\n *\r\n *  - just after webSocket connection is established `connected` event are fired, when\r\n *  - after server accept (verify a user credential) `accepted` are fired - here you can got\r\n *    a connectionID of a current connection\r\n *  - next is a series of protocol events ( `test_command` for example )\r\n *  - in case of protocol error `error` are fired\r\n *  - when WebSocket connection are closed `disconnected` event are fired\r\n *\r\n * You do not need to **connect** or **reconnect** a WebSocket manually - UBNotifierWSProtocol recreate\r\n * a WebSocket automatically just after corresponding UBConnection fires a `authorized` event.\r\n *\r\n * For `adminUI` instance of this class is accessible from $App.ubNotifier just after $App.launch\r\n *\r\n * Usage sample:\r\n *\r\n *      // Server side\r\n *      const WebSockets = require('WebSockets');\r\n *      var notifier = WebSockets.getWSNotifier();\r\n *      if (notifier) {\r\n *          notifier.broadcast('test_command', {name: 'Homer', like: 'donuts'});\r\n *      }\r\n *\r\n *      // Client side\r\n *      // Will output 'Homer like donuts' after got a `test_command` from server\r\n *      $App.ubNotifier.on('test_command', function(params}{\r\n *          console.debug(params.name, 'like', params.like)\r\n *      }\r\n *\r\n * @class\r\n * @mixes EventEmitter\r\n * @param {UBConnection} connection Warning - only one instance of UBNotifierWSProtocol for a connection is valid.\r\n */\r\nfunction UBNotifierWSProtocol (connection) {\r\n  var notifier = this\r\n  var supported = (connection.supportedWSProtocols.indexOf(WS_PROTOCOL) !== -1)\r\n    /**\r\n     * Indicate `ubNotifier` protocol is supported by server.\r\n     * If not supported all calls to send() will be ignored.\r\n     * @type {boolean}\r\n     */\r\n  this.supported = supported\r\n\r\n  EventEmitter.call(this)\r\n  _.assign(this, EventEmitter.prototype)\r\n\r\n  var\r\n    doDebug = function () {},\r\n    inDebug = false\r\n    /**\r\n     * Enable output all webSocket interaction to console\r\n     * @property {boolean} debugMode\r\n     */\r\n  Object.defineProperty(notifier, 'debugMode', {\r\n    get: function () { return inDebug },\r\n    set: function (newValue) {\r\n      if (inDebug !== newValue) {\r\n        inDebug = newValue\r\n        doDebug = inDebug ? console.debug.bind(console, 'ubNotifier') : function () {}\r\n      }\r\n    },\r\n    enumerable: true,\r\n    configurable: true\r\n  })\r\n\r\n  var wsURL = 'ws' + connection.serverUrl.slice(4) + 'ws' // remove http part, so in case http://.. we got ws://.., in case https://.. -> wss://..\r\n  var $ws = null\r\n  var isConnectionAccepted = false\r\n  var bufferedCommands = []\r\n\r\n  function _createWSConnection (session) {\r\n    if (supported) {\r\n      $ws = new WebSocket(wsURL + '?SESSION_SIGNATURE=' + session.signature(), 'ubNotifier')\r\n\r\n      $ws.onopen = function (e) {\r\n        doDebug('connected to', e.target.url, 'protocol:', e.target.protocol)\r\n                /**\r\n                 * Emitted for {@link UBNotifierWSProtocol} just after WS connection is established, but before it accepted by server.\r\n                 * Params: url, protocol\r\n                 * @event connected\r\n                 */\r\n        notifier.emit('connected', e.target.url, e.target.protocol)\r\n      }\r\n\r\n      $ws.onmessage = function (e) {\r\n        var msg\r\n        doDebug('Got a raw data', e.data)\r\n        try {\r\n          msg = JSON.parse(e.data)\r\n        } catch (err) {\r\n          console.error('ubNotifier: Invalid command from server:', e.data)\r\n        }\r\n        var\r\n          command = msg.command,\r\n          params = msg.params,\r\n          delayedCmd\r\n\r\n        doDebug('Got a command', command, 'with params', params)\r\n        switch (command) {\r\n          case 'accepted': // send a buffered request if any\r\n            isConnectionAccepted = true\r\n            while ((delayedCmd = bufferedCommands.shift()) && isConnectionAccepted) {\r\n              notifier.sendCommand(delayedCmd.command, delayedCmd.params)\r\n            }\r\n            bufferedCommands = []\r\n                        /**\r\n                         * If server accept a ubNotifier WS connection this event will be emitted for {@link UBNotifierWSProtocol} with `connectionID` parameter\r\n                         * @event accepted\r\n                         */\r\n            notifier.emit('accepted', params.connectionID)\r\n            break\r\n          case 'error':\r\n            doDebug('Got an error from server', params)\r\n            notifier.emit('error', params)\r\n            break\r\n          default:\r\n            doDebug('Emit event ', command, 'with params', params)\r\n            notifier.emit(command, params)\r\n            break\r\n        }\r\n      }\r\n\r\n      $ws.onclose = function (e) {\r\n        isConnectionAccepted = false\r\n        doDebug('Connection closed. Code:', e.code, 'Reason:', e.reason)\r\n        notifier.emit('disconnected', e.code, e.reason)\r\n      }\r\n    }\r\n  }\r\n\r\n    /**\r\n     * Sand a command to server\r\n     *\r\n     *  - if WS connection is not accepted yet will buffer the commands and send it just after connection is accepted\r\n     *  - if `ubNotifier` protocol not supported by server will do nothing\r\n     *\r\n     * @method\r\n     * @param {string} command\r\n     * @param {*} params\r\n     */\r\n  this.sendCommand = function (command, params) {\r\n    if (supported) {\r\n      if (isConnectionAccepted) {\r\n        $ws.send(JSON.stringify({command: command, params: params}))\r\n      } else { // add to delayed buffer\r\n        bufferedCommands.push({command: command, params: params})\r\n        if (bufferedCommands.length > MAX_BUFFERED_COMMANDS) bufferedCommands.shift()\r\n      }\r\n    }\r\n  }\r\n\r\n  function _onUBConnectionAuthorized (ubConnection, session, authParams) {\r\n    isConnectionAccepted = false\r\n    if (connection.supportedWSProtocols.indexOf(WS_PROTOCOL) !== -1) {\r\n      _createWSConnection(session)\r\n    } else {\r\n      console.warn('ubNotifier: protocol not supported')\r\n    }\r\n  }\r\n  connection.on('authorized', _onUBConnectionAuthorized)\r\n}\r\nmodule.exports = UBNotifierWSProtocol\r\n\n\n\n// WEBPACK FOOTER //\n// ./UBNotifierWSProtocol.js","let __loadedScript = {}\r\nlet __head = document.getElementsByTagName('head')[0]\r\n\r\n/**\r\n * Inject external script or css to DOM and return a promise to be resolved when script is loaded.\r\n *\r\n * Implement single load mode (if script successfully loaded using inject it not loaded anymore.\r\n *\r\n * @example\r\n *\r\n //Load script.js:\r\n UB.inject('jslibs/script.js')\r\n\r\n //Load several script at once and error handling:\r\n Promise.all([UB.inject('jslibs/script.js'), UB.inject('script2.js')])\r\n .catch(function(err){\r\n   console.log('Oh! error occurred: ' + err)\r\n });\r\n\r\n //Load one script and then load other\r\n UB.inject('jslibs/js_beautify.js')\r\n .then(function(){\r\n     console.log('first script loaded. Continue to load second')\r\n     return UB.inject('jslibs/js_beautify1.js')\r\n });\r\n\r\n //Load couple of resources:\r\n Promise.all([UB.inject('css/first.css'), UB.inject('css/second.css')])\r\n\r\n * @param {String} url either *js* or *css* resource to load\r\n * @param {String} [charset]\r\n * @return {Promise}\r\n */\r\nfunction inject (url, charset) {\r\n  let res\r\n  if (__loadedScript[url]) {\r\n    res = __loadedScript[url]\r\n  } else {\r\n    // Create and inject script tag at end of DOM body and load the external script\r\n    // attach event listeners that will trigger the Deferred.\r\n    res = __loadedScript[url] = new Promise(function (resolve, reject) {\r\n      let elm = null\r\n      let isCSS = /\\.css(?:\\?|$)/.test(url)\r\n      if (isCSS) {\r\n        elm = document.createElement('link')\r\n        elm.rel = 'stylesheet'\r\n        elm.async = true\r\n      } else {\r\n        elm = document.createElement('script')\r\n        elm.type = 'text/javascript'\r\n        if (charset) {\r\n          elm.charset = charset\r\n        }\r\n        elm.async = true\r\n      }\r\n      elm.onerror = function (oError) {\r\n        let reason = 'Required ' + (oError.target.href || oError.target.src) + ' is not accessible'\r\n        delete __loadedScript[url]\r\n        elm.onerror = elm.onload = elm.onreadystatechange = null\r\n        reject(new Error(reason))\r\n      }\r\n\r\n      elm.onload = function () {\r\n        elm.onerror = elm.onload = elm.onreadystatechange = null\r\n        setTimeout(function () { // script must evaluate first\r\n          let _elm = elm\r\n          resolve()\r\n          // Remove the script (do not remove CSS) ???\r\n          if (_elm.parentNode && !_elm.rel) {\r\n            _elm.parentNode.removeChild(elm)\r\n            elm = null\r\n          }\r\n        }, 0)\r\n      }\r\n      // if ('readyState' in elm) {   // for <IE9 Compatability\r\n      //   elm.onreadystatechange = function () {\r\n      //     if (this.readyState === 'loaded' || this.readyState === 'complete') {\r\n      //       resultHandler()\r\n      //     }\r\n      //   }\r\n      // }\r\n\r\n      __head.appendChild(elm)\r\n      // src must be set AFTER onload && onerror && appendChild\r\n      if (isCSS) {\r\n        elm.href = addResourceVersion(url)\r\n      } else {\r\n        elm.src = addResourceVersion(url)\r\n      }\r\n    })\r\n  }\r\n  return res\r\n}\r\n\r\n/**\r\n *  In case window contains __ubVersion property {@link addResourceVersion addResourceVersion} will add\r\n *  version parameter to scripts inside models.\r\n *\r\n *  @private\r\n */\r\nconst __ubVersion = window.__ubVersion\r\nconst MODEL_RE = new RegExp('models/(.+?)/') // speculative search. w/o ? found maximum string length\r\n\r\n/**\r\n * Search for resource version in the  window.__ubVersion global const\r\n * IF any,  return 'ver=version' else ''\r\n * @param {String} uri\r\n * @returns {String}\r\n */\r\nfunction getResourceVersion (uri) {\r\n  let modelName = MODEL_RE.test(uri) ? MODEL_RE.exec(uri)[1] : '_web'\r\n  return (__ubVersion && __ubVersion[modelName])\r\n    ? '?ubver=' + __ubVersion[modelName]\r\n    : ''\r\n}\r\n\r\n/**\r\n * Append UnityBase model version to the URL\r\n * @param {String} uri\r\n * @returns {String} uri with added resource version\r\n */\r\nfunction addResourceVersion (uri) {\r\n  let ver = getResourceVersion(uri)\r\n  return ver ? uri + ver : uri\r\n}\r\n\r\nmodule.exports = {\r\n  inject,\r\n  addResourceVersion\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./injection.js"],"sourceRoot":""}